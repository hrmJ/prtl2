
/**
 * Client
**/

import * as runtime from './runtime/data-proxy';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions

export type PrismaPromise<T> = $Public.PrismaPromise<T>


export type backgroundsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "backgrounds"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: number
    filename: string | null
    description: string | null
  }, ExtArgs["result"]["backgrounds"]>
  composites: {}
}

/**
 * Model backgrounds
 * 
 */
export type backgrounds = runtime.Types.DefaultSelection<backgroundsPayload>
export type biblesegmentsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "biblesegments"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: number
    start_book: string | null
    start_chap: number | null
    start_verse: number | null
    end_book: string | null
    end_chap: number | null
    end_verse: number | null
  }, ExtArgs["result"]["biblesegments"]>
  composites: {}
}

/**
 * Model biblesegments
 * 
 */
export type biblesegments = runtime.Types.DefaultSelection<biblesegmentsPayload>
export type collected_offeringsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "collected_offerings"
  objects: {
    offering_goals: offering_goalsPayload<ExtArgs>
    services: servicesPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    target_id: number
    service_id: number
    amount: Prisma.Decimal | null
  }, ExtArgs["result"]["collected_offerings"]>
  composites: {}
}

/**
 * Model collected_offerings
 * 
 */
export type collected_offerings = runtime.Types.DefaultSelection<collected_offeringsPayload>
export type commentsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "comments"
  objects: {
    services: servicesPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    service_id: number
    reply_to: number | null
    content: string | null
    commentator: string | null
    theme: string | null
    comment_time: Date | null
  }, ExtArgs["result"]["comments"]>
  composites: {}
}

/**
 * Model comments
 * 
 */
export type comments = runtime.Types.DefaultSelection<commentsPayload>
export type eventsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "events"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: number
    name: string | null
    place_and_time: string | null
    description: string | null
    event_date: Date | null
    has_songs: boolean | null
  }, ExtArgs["result"]["events"]>
  composites: {}
}

/**
 * Model events
 * 
 */
export type events = runtime.Types.DefaultSelection<eventsPayload>
export type headersPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "headers"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: number
    template_name: string | null
    maintext: string | null
    imgname: string | null
    imgposition: string | null
    is_aside: boolean | null
  }, ExtArgs["result"]["headers"]>
  composites: {}
}

/**
 * Model headers
 * 
 */
export type headers = runtime.Types.DefaultSelection<headersPayload>
export type infosPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "infos"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: number
    service_id: number
    slot_name: string | null
    content_id: number
    addedclass: string | null
    header_id: number | null
  }, ExtArgs["result"]["infos"]>
  composites: {}
}

/**
 * Model infos
 * 
 */
export type infos = runtime.Types.DefaultSelection<infosPayload>
export type infosegmentsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "infosegments"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: number
    maintext: string | null
    header: string | null
    genheader: string | null
    subgenheader: string | null
    imgname: string | null
    imgposition: string | null
  }, ExtArgs["result"]["infosegments"]>
  composites: {}
}

/**
 * Model infosegments
 * 
 */
export type infosegments = runtime.Types.DefaultSelection<infosegmentsPayload>
export type liturgicalsegmentsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "liturgicalsegments"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: number
    text_title: string | null
    use_as_header: boolean | null
  }, ExtArgs["result"]["liturgicalsegments"]>
  composites: {}
}

/**
 * Model liturgicalsegments
 * 
 */
export type liturgicalsegments = runtime.Types.DefaultSelection<liturgicalsegmentsPayload>
export type ltextdataPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "ltextdata"
  objects: {
    ltextversedata: ltextversedataPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: number
    title: string | null
  }, ExtArgs["result"]["ltextdata"]>
  composites: {}
}

/**
 * Model ltextdata
 * 
 */
export type ltextdata = runtime.Types.DefaultSelection<ltextdataPayload>
export type ltextversedataPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "ltextversedata"
  objects: {
    ltextdata: ltextdataPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    ltext_id: number
    verse: string | null
  }, ExtArgs["result"]["ltextversedata"]>
  composites: {}
}

/**
 * Model ltextversedata
 * 
 */
export type ltextversedata = runtime.Types.DefaultSelection<ltextversedataPayload>
export type offering_goalsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "offering_goals"
  objects: {
    collected_offerings: collected_offeringsPayload<ExtArgs>[]
    offering_targets: offering_targetsPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    target_id: number
    name: string | null
    description: string | null
    amount: Prisma.Decimal | null
    is_default: boolean | null
  }, ExtArgs["result"]["offering_goals"]>
  composites: {}
}

/**
 * Model offering_goals
 * 
 */
export type offering_goals = runtime.Types.DefaultSelection<offering_goalsPayload>
export type offering_targetsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "offering_targets"
  objects: {
    offering_goals: offering_goalsPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: number
    name: string | null
    description: string | null
  }, ExtArgs["result"]["offering_targets"]>
  composites: {}
}

/**
 * Model offering_targets
 * 
 */
export type offering_targets = runtime.Types.DefaultSelection<offering_targetsPayload>
export type presentation_contentPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "presentation_content"
  objects: {
    presentation_structure: presentation_structurePayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    slot_id: number
    content_type: string | null
    new_slide: string | null
    content: string | null
  }, ExtArgs["result"]["presentation_content"]>
  composites: {}
}

/**
 * Model presentation_content
 * 
 */
export type presentation_content = runtime.Types.DefaultSelection<presentation_contentPayload>
export type presentation_structurePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "presentation_structure"
  objects: {
    presentation_content: presentation_contentPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: number
    service_id: number | null
    slot_name: string | null
    slot_number: number | null
    slot_type: string | null
    id_in_type_table: string | null
    addedclass: string | null
    header_id: number | null
    content_id: number
    instruction: string | null
  }, ExtArgs["result"]["presentation_structure"]>
  composites: {}
}

/**
 * Model presentation_structure
 * 
 */
export type presentation_structure = runtime.Types.DefaultSelection<presentation_structurePayload>
export type responsibilitiesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "responsibilities"
  objects: {
    services: servicesPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    service_id: number
    responsibility: string | null
    responsible: string | null
  }, ExtArgs["result"]["responsibilities"]>
  composites: {}
}

/**
 * Model responsibilities
 * 
 */
export type responsibilities = runtime.Types.DefaultSelection<responsibilitiesPayload>
export type responsibilities_metaPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "responsibilities_meta"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: number
    responsibility: string | null
    description: string | null
  }, ExtArgs["result"]["responsibilities_meta"]>
  composites: {}
}

/**
 * Model responsibilities_meta
 * 
 */
export type responsibilities_meta = runtime.Types.DefaultSelection<responsibilities_metaPayload>
export type seasonsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "seasons"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: number
    startdate: Date | null
    enddate: Date | null
    theme: string | null
    comments: string | null
    name: string | null
  }, ExtArgs["result"]["seasons"]>
  composites: {}
}

/**
 * Model seasons
 * 
 */
export type seasons = runtime.Types.DefaultSelection<seasonsPayload>
export type service_specific_presentation_structurePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "service_specific_presentation_structure"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: number
    service_id: number
    slot_name: string | null
    slot_number: number | null
    slot_type: string | null
    id_in_type_table: string | null
    content_id: number
    addedclass: string | null
    header_id: number | null
    instruction: string | null
  }, ExtArgs["result"]["service_specific_presentation_structure"]>
  composites: {}
}

/**
 * Model service_specific_presentation_structure
 * 
 */
export type service_specific_presentation_structure = runtime.Types.DefaultSelection<service_specific_presentation_structurePayload>
export type servicesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "services"
  objects: {
    collected_offerings: collected_offeringsPayload<ExtArgs>[]
    comments: commentsPayload<ExtArgs>[]
    responsibilities: responsibilitiesPayload<ExtArgs>[]
    servicesongs: servicesongsPayload<ExtArgs>[]
    serviceverses: serviceversesPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: number
    servicedate: Date | null
    theme: string | null
  }, ExtArgs["result"]["services"]>
  composites: {}
}

/**
 * Model services
 * 
 */
export type services = runtime.Types.DefaultSelection<servicesPayload>
export type servicesongsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "servicesongs"
  objects: {
    services: servicesPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: bigint
    service_id: number
    song_title: string | null
    verses: string | null
    is_instrumental: string | null
    song_id: number | null
    songtype: string
    position: number | null
  }, ExtArgs["result"]["servicesongs"]>
  composites: {}
}

/**
 * Model servicesongs
 * 
 */
export type servicesongs = runtime.Types.DefaultSelection<servicesongsPayload>
export type serviceversesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "serviceverses"
  objects: {
    services: servicesPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    service_id: number
    segment_name: string | null
    testament: string | null
    startbook: string | null
    endbook: string | null
    startchapter: number | null
    endchapter: number | null
    startverse: number | null
    endverse: number | null
  }, ExtArgs["result"]["serviceverses"]>
  composites: {}
}

/**
 * Model serviceverses
 * 
 */
export type serviceverses = runtime.Types.DefaultSelection<serviceversesPayload>
export type smallgroupsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "smallgroups"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: number
    name: string | null
    description: string | null
    resp_name: string | null
    day: string | null
    time_and_place: string | null
    is_active: boolean | null
  }, ExtArgs["result"]["smallgroups"]>
  composites: {}
}

/**
 * Model smallgroups
 * 
 */
export type smallgroups = runtime.Types.DefaultSelection<smallgroupsPayload>
export type songdataPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "songdata"
  objects: {
    songtags: songtagsPayload<ExtArgs>[]
    versedata: versedataPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: number
    title: string | null
    composer: string | null
    lyrics: string | null
    version_description: string | null
  }, ExtArgs["result"]["songdata"]>
  composites: {}
}

/**
 * Model songdata
 * 
 */
export type songdata = runtime.Types.DefaultSelection<songdataPayload>
export type songsegmentsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "songsegments"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: number
    songdescription: string | null
    restrictedto: string | null
    singlename: string | null
    is_multi: boolean | null
    segment_name_is_title: boolean | null
  }, ExtArgs["result"]["songsegments"]>
  composites: {}
}

/**
 * Model songsegments
 * 
 */
export type songsegments = runtime.Types.DefaultSelection<songsegmentsPayload>
export type songtagsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "songtags"
  objects: {
    songdata: songdataPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    song_id: number
    tag: string | null
  }, ExtArgs["result"]["songtags"]>
  composites: {}
}

/**
 * Model songtags
 * 
 */
export type songtags = runtime.Types.DefaultSelection<songtagsPayload>
export type stylesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "styles"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: number
    classname: string | null
    tagname: string | null
    attr: string | null
    value: string | null
    stylesheet: string | null
  }, ExtArgs["result"]["styles"]>
  composites: {}
}

/**
 * Model styles
 * 
 */
export type styles = runtime.Types.DefaultSelection<stylesPayload>
export type usersPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "users"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: number
    username: string | null
    password: string | null
  }, ExtArgs["result"]["users"]>
  composites: {}
}

/**
 * Model users
 * 
 */
export type users = runtime.Types.DefaultSelection<usersPayload>
export type versedataPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "versedata"
  objects: {
    songdata: songdataPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    song_id: number
    verse: string | null
    versetype: string | null
  }, ExtArgs["result"]["versedata"]>
  composites: {}
}

/**
 * Model versedata
 * 
 */
export type versedata = runtime.Types.DefaultSelection<versedataPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Backgrounds
 * const backgrounds = await prisma.backgrounds.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false,
  ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Backgrounds
   * const backgrounds = await prisma.backgrounds.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => Promise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.backgrounds`: Exposes CRUD operations for the **backgrounds** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Backgrounds
    * const backgrounds = await prisma.backgrounds.findMany()
    * ```
    */
  get backgrounds(): Prisma.backgroundsDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.biblesegments`: Exposes CRUD operations for the **biblesegments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Biblesegments
    * const biblesegments = await prisma.biblesegments.findMany()
    * ```
    */
  get biblesegments(): Prisma.biblesegmentsDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.collected_offerings`: Exposes CRUD operations for the **collected_offerings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Collected_offerings
    * const collected_offerings = await prisma.collected_offerings.findMany()
    * ```
    */
  get collected_offerings(): Prisma.collected_offeringsDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.comments`: Exposes CRUD operations for the **comments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comments.findMany()
    * ```
    */
  get comments(): Prisma.commentsDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.events`: Exposes CRUD operations for the **events** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Events
    * const events = await prisma.events.findMany()
    * ```
    */
  get events(): Prisma.eventsDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.headers`: Exposes CRUD operations for the **headers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Headers
    * const headers = await prisma.headers.findMany()
    * ```
    */
  get headers(): Prisma.headersDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.infos`: Exposes CRUD operations for the **infos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Infos
    * const infos = await prisma.infos.findMany()
    * ```
    */
  get infos(): Prisma.infosDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.infosegments`: Exposes CRUD operations for the **infosegments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Infosegments
    * const infosegments = await prisma.infosegments.findMany()
    * ```
    */
  get infosegments(): Prisma.infosegmentsDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.liturgicalsegments`: Exposes CRUD operations for the **liturgicalsegments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Liturgicalsegments
    * const liturgicalsegments = await prisma.liturgicalsegments.findMany()
    * ```
    */
  get liturgicalsegments(): Prisma.liturgicalsegmentsDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.ltextdata`: Exposes CRUD operations for the **ltextdata** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ltextdata
    * const ltextdata = await prisma.ltextdata.findMany()
    * ```
    */
  get ltextdata(): Prisma.ltextdataDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.ltextversedata`: Exposes CRUD operations for the **ltextversedata** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ltextversedata
    * const ltextversedata = await prisma.ltextversedata.findMany()
    * ```
    */
  get ltextversedata(): Prisma.ltextversedataDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.offering_goals`: Exposes CRUD operations for the **offering_goals** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Offering_goals
    * const offering_goals = await prisma.offering_goals.findMany()
    * ```
    */
  get offering_goals(): Prisma.offering_goalsDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.offering_targets`: Exposes CRUD operations for the **offering_targets** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Offering_targets
    * const offering_targets = await prisma.offering_targets.findMany()
    * ```
    */
  get offering_targets(): Prisma.offering_targetsDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.presentation_content`: Exposes CRUD operations for the **presentation_content** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Presentation_contents
    * const presentation_contents = await prisma.presentation_content.findMany()
    * ```
    */
  get presentation_content(): Prisma.presentation_contentDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.presentation_structure`: Exposes CRUD operations for the **presentation_structure** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Presentation_structures
    * const presentation_structures = await prisma.presentation_structure.findMany()
    * ```
    */
  get presentation_structure(): Prisma.presentation_structureDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.responsibilities`: Exposes CRUD operations for the **responsibilities** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Responsibilities
    * const responsibilities = await prisma.responsibilities.findMany()
    * ```
    */
  get responsibilities(): Prisma.responsibilitiesDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.responsibilities_meta`: Exposes CRUD operations for the **responsibilities_meta** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Responsibilities_metas
    * const responsibilities_metas = await prisma.responsibilities_meta.findMany()
    * ```
    */
  get responsibilities_meta(): Prisma.responsibilities_metaDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.seasons`: Exposes CRUD operations for the **seasons** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Seasons
    * const seasons = await prisma.seasons.findMany()
    * ```
    */
  get seasons(): Prisma.seasonsDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.service_specific_presentation_structure`: Exposes CRUD operations for the **service_specific_presentation_structure** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Service_specific_presentation_structures
    * const service_specific_presentation_structures = await prisma.service_specific_presentation_structure.findMany()
    * ```
    */
  get service_specific_presentation_structure(): Prisma.service_specific_presentation_structureDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.services`: Exposes CRUD operations for the **services** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Services
    * const services = await prisma.services.findMany()
    * ```
    */
  get services(): Prisma.servicesDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.servicesongs`: Exposes CRUD operations for the **servicesongs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Servicesongs
    * const servicesongs = await prisma.servicesongs.findMany()
    * ```
    */
  get servicesongs(): Prisma.servicesongsDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.serviceverses`: Exposes CRUD operations for the **serviceverses** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Serviceverses
    * const serviceverses = await prisma.serviceverses.findMany()
    * ```
    */
  get serviceverses(): Prisma.serviceversesDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.smallgroups`: Exposes CRUD operations for the **smallgroups** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Smallgroups
    * const smallgroups = await prisma.smallgroups.findMany()
    * ```
    */
  get smallgroups(): Prisma.smallgroupsDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.songdata`: Exposes CRUD operations for the **songdata** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Songdata
    * const songdata = await prisma.songdata.findMany()
    * ```
    */
  get songdata(): Prisma.songdataDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.songsegments`: Exposes CRUD operations for the **songsegments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Songsegments
    * const songsegments = await prisma.songsegments.findMany()
    * ```
    */
  get songsegments(): Prisma.songsegmentsDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.songtags`: Exposes CRUD operations for the **songtags** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Songtags
    * const songtags = await prisma.songtags.findMany()
    * ```
    */
  get songtags(): Prisma.songtagsDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.styles`: Exposes CRUD operations for the **styles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Styles
    * const styles = await prisma.styles.findMany()
    * ```
    */
  get styles(): Prisma.stylesDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.versedata`: Exposes CRUD operations for the **versedata** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Versedata
    * const versedata = await prisma.versedata.findMany()
    * ```
    */
  get versedata(): Prisma.versedataDelegate<GlobalReject, ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export type Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export type Args<T, F extends $Public.Operation> = $Public.Args<T, F>
  export type Payload<T, F extends $Public.Operation> = $Public.Payload<T, F>
  export type Result<T, A, F extends $Public.Operation> = $Public.Result<T, A, F>
  export type Exact<T, W> = $Public.Exact<T, W>

  /**
   * Prisma Client JS version: 4.16.2
   * Query Engine version: 4bc8b6e1b66cb932731fb1bdbbc550d1e010de81
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    backgrounds: 'backgrounds',
    biblesegments: 'biblesegments',
    collected_offerings: 'collected_offerings',
    comments: 'comments',
    events: 'events',
    headers: 'headers',
    infos: 'infos',
    infosegments: 'infosegments',
    liturgicalsegments: 'liturgicalsegments',
    ltextdata: 'ltextdata',
    ltextversedata: 'ltextversedata',
    offering_goals: 'offering_goals',
    offering_targets: 'offering_targets',
    presentation_content: 'presentation_content',
    presentation_structure: 'presentation_structure',
    responsibilities: 'responsibilities',
    responsibilities_meta: 'responsibilities_meta',
    seasons: 'seasons',
    service_specific_presentation_structure: 'service_specific_presentation_structure',
    services: 'services',
    servicesongs: 'servicesongs',
    serviceverses: 'serviceverses',
    smallgroups: 'smallgroups',
    songdata: 'songdata',
    songsegments: 'songsegments',
    songtags: 'songtags',
    styles: 'styles',
    users: 'users',
    versedata: 'versedata'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.Args}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'backgrounds' | 'biblesegments' | 'collected_offerings' | 'comments' | 'events' | 'headers' | 'infos' | 'infosegments' | 'liturgicalsegments' | 'ltextdata' | 'ltextversedata' | 'offering_goals' | 'offering_targets' | 'presentation_content' | 'presentation_structure' | 'responsibilities' | 'responsibilities_meta' | 'seasons' | 'service_specific_presentation_structure' | 'services' | 'servicesongs' | 'serviceverses' | 'smallgroups' | 'songdata' | 'songsegments' | 'songtags' | 'styles' | 'users' | 'versedata'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      backgrounds: {
        payload: backgroundsPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.backgroundsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<backgroundsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.backgroundsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<backgroundsPayload>
          }
          findFirst: {
            args: Prisma.backgroundsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<backgroundsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.backgroundsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<backgroundsPayload>
          }
          findMany: {
            args: Prisma.backgroundsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<backgroundsPayload>[]
          }
          create: {
            args: Prisma.backgroundsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<backgroundsPayload>
          }
          createMany: {
            args: Prisma.backgroundsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.backgroundsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<backgroundsPayload>
          }
          update: {
            args: Prisma.backgroundsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<backgroundsPayload>
          }
          deleteMany: {
            args: Prisma.backgroundsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.backgroundsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.backgroundsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<backgroundsPayload>
          }
          aggregate: {
            args: Prisma.BackgroundsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBackgrounds>
          }
          groupBy: {
            args: Prisma.BackgroundsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BackgroundsGroupByOutputType>[]
          }
          count: {
            args: Prisma.backgroundsCountArgs<ExtArgs>,
            result: $Utils.Optional<BackgroundsCountAggregateOutputType> | number
          }
        }
      }
      biblesegments: {
        payload: biblesegmentsPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.biblesegmentsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<biblesegmentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.biblesegmentsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<biblesegmentsPayload>
          }
          findFirst: {
            args: Prisma.biblesegmentsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<biblesegmentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.biblesegmentsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<biblesegmentsPayload>
          }
          findMany: {
            args: Prisma.biblesegmentsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<biblesegmentsPayload>[]
          }
          create: {
            args: Prisma.biblesegmentsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<biblesegmentsPayload>
          }
          createMany: {
            args: Prisma.biblesegmentsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.biblesegmentsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<biblesegmentsPayload>
          }
          update: {
            args: Prisma.biblesegmentsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<biblesegmentsPayload>
          }
          deleteMany: {
            args: Prisma.biblesegmentsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.biblesegmentsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.biblesegmentsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<biblesegmentsPayload>
          }
          aggregate: {
            args: Prisma.BiblesegmentsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBiblesegments>
          }
          groupBy: {
            args: Prisma.BiblesegmentsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BiblesegmentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.biblesegmentsCountArgs<ExtArgs>,
            result: $Utils.Optional<BiblesegmentsCountAggregateOutputType> | number
          }
        }
      }
      collected_offerings: {
        payload: collected_offeringsPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.collected_offeringsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<collected_offeringsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.collected_offeringsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<collected_offeringsPayload>
          }
          findFirst: {
            args: Prisma.collected_offeringsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<collected_offeringsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.collected_offeringsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<collected_offeringsPayload>
          }
          findMany: {
            args: Prisma.collected_offeringsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<collected_offeringsPayload>[]
          }
          create: {
            args: Prisma.collected_offeringsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<collected_offeringsPayload>
          }
          createMany: {
            args: Prisma.collected_offeringsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.collected_offeringsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<collected_offeringsPayload>
          }
          update: {
            args: Prisma.collected_offeringsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<collected_offeringsPayload>
          }
          deleteMany: {
            args: Prisma.collected_offeringsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.collected_offeringsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.collected_offeringsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<collected_offeringsPayload>
          }
          aggregate: {
            args: Prisma.Collected_offeringsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCollected_offerings>
          }
          groupBy: {
            args: Prisma.Collected_offeringsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Collected_offeringsGroupByOutputType>[]
          }
          count: {
            args: Prisma.collected_offeringsCountArgs<ExtArgs>,
            result: $Utils.Optional<Collected_offeringsCountAggregateOutputType> | number
          }
        }
      }
      comments: {
        payload: commentsPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.commentsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<commentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.commentsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<commentsPayload>
          }
          findFirst: {
            args: Prisma.commentsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<commentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.commentsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<commentsPayload>
          }
          findMany: {
            args: Prisma.commentsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<commentsPayload>[]
          }
          create: {
            args: Prisma.commentsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<commentsPayload>
          }
          createMany: {
            args: Prisma.commentsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.commentsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<commentsPayload>
          }
          update: {
            args: Prisma.commentsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<commentsPayload>
          }
          deleteMany: {
            args: Prisma.commentsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.commentsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.commentsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<commentsPayload>
          }
          aggregate: {
            args: Prisma.CommentsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateComments>
          }
          groupBy: {
            args: Prisma.CommentsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CommentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.commentsCountArgs<ExtArgs>,
            result: $Utils.Optional<CommentsCountAggregateOutputType> | number
          }
        }
      }
      events: {
        payload: eventsPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.eventsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<eventsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.eventsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<eventsPayload>
          }
          findFirst: {
            args: Prisma.eventsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<eventsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.eventsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<eventsPayload>
          }
          findMany: {
            args: Prisma.eventsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<eventsPayload>[]
          }
          create: {
            args: Prisma.eventsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<eventsPayload>
          }
          createMany: {
            args: Prisma.eventsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.eventsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<eventsPayload>
          }
          update: {
            args: Prisma.eventsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<eventsPayload>
          }
          deleteMany: {
            args: Prisma.eventsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.eventsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.eventsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<eventsPayload>
          }
          aggregate: {
            args: Prisma.EventsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEvents>
          }
          groupBy: {
            args: Prisma.EventsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EventsGroupByOutputType>[]
          }
          count: {
            args: Prisma.eventsCountArgs<ExtArgs>,
            result: $Utils.Optional<EventsCountAggregateOutputType> | number
          }
        }
      }
      headers: {
        payload: headersPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.headersFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<headersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.headersFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<headersPayload>
          }
          findFirst: {
            args: Prisma.headersFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<headersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.headersFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<headersPayload>
          }
          findMany: {
            args: Prisma.headersFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<headersPayload>[]
          }
          create: {
            args: Prisma.headersCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<headersPayload>
          }
          createMany: {
            args: Prisma.headersCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.headersDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<headersPayload>
          }
          update: {
            args: Prisma.headersUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<headersPayload>
          }
          deleteMany: {
            args: Prisma.headersDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.headersUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.headersUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<headersPayload>
          }
          aggregate: {
            args: Prisma.HeadersAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateHeaders>
          }
          groupBy: {
            args: Prisma.HeadersGroupByArgs<ExtArgs>,
            result: $Utils.Optional<HeadersGroupByOutputType>[]
          }
          count: {
            args: Prisma.headersCountArgs<ExtArgs>,
            result: $Utils.Optional<HeadersCountAggregateOutputType> | number
          }
        }
      }
      infos: {
        payload: infosPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.infosFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<infosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.infosFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<infosPayload>
          }
          findFirst: {
            args: Prisma.infosFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<infosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.infosFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<infosPayload>
          }
          findMany: {
            args: Prisma.infosFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<infosPayload>[]
          }
          create: {
            args: Prisma.infosCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<infosPayload>
          }
          createMany: {
            args: Prisma.infosCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.infosDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<infosPayload>
          }
          update: {
            args: Prisma.infosUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<infosPayload>
          }
          deleteMany: {
            args: Prisma.infosDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.infosUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.infosUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<infosPayload>
          }
          aggregate: {
            args: Prisma.InfosAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInfos>
          }
          groupBy: {
            args: Prisma.InfosGroupByArgs<ExtArgs>,
            result: $Utils.Optional<InfosGroupByOutputType>[]
          }
          count: {
            args: Prisma.infosCountArgs<ExtArgs>,
            result: $Utils.Optional<InfosCountAggregateOutputType> | number
          }
        }
      }
      infosegments: {
        payload: infosegmentsPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.infosegmentsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<infosegmentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.infosegmentsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<infosegmentsPayload>
          }
          findFirst: {
            args: Prisma.infosegmentsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<infosegmentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.infosegmentsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<infosegmentsPayload>
          }
          findMany: {
            args: Prisma.infosegmentsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<infosegmentsPayload>[]
          }
          create: {
            args: Prisma.infosegmentsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<infosegmentsPayload>
          }
          createMany: {
            args: Prisma.infosegmentsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.infosegmentsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<infosegmentsPayload>
          }
          update: {
            args: Prisma.infosegmentsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<infosegmentsPayload>
          }
          deleteMany: {
            args: Prisma.infosegmentsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.infosegmentsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.infosegmentsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<infosegmentsPayload>
          }
          aggregate: {
            args: Prisma.InfosegmentsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInfosegments>
          }
          groupBy: {
            args: Prisma.InfosegmentsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<InfosegmentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.infosegmentsCountArgs<ExtArgs>,
            result: $Utils.Optional<InfosegmentsCountAggregateOutputType> | number
          }
        }
      }
      liturgicalsegments: {
        payload: liturgicalsegmentsPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.liturgicalsegmentsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<liturgicalsegmentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.liturgicalsegmentsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<liturgicalsegmentsPayload>
          }
          findFirst: {
            args: Prisma.liturgicalsegmentsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<liturgicalsegmentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.liturgicalsegmentsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<liturgicalsegmentsPayload>
          }
          findMany: {
            args: Prisma.liturgicalsegmentsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<liturgicalsegmentsPayload>[]
          }
          create: {
            args: Prisma.liturgicalsegmentsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<liturgicalsegmentsPayload>
          }
          createMany: {
            args: Prisma.liturgicalsegmentsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.liturgicalsegmentsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<liturgicalsegmentsPayload>
          }
          update: {
            args: Prisma.liturgicalsegmentsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<liturgicalsegmentsPayload>
          }
          deleteMany: {
            args: Prisma.liturgicalsegmentsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.liturgicalsegmentsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.liturgicalsegmentsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<liturgicalsegmentsPayload>
          }
          aggregate: {
            args: Prisma.LiturgicalsegmentsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLiturgicalsegments>
          }
          groupBy: {
            args: Prisma.LiturgicalsegmentsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<LiturgicalsegmentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.liturgicalsegmentsCountArgs<ExtArgs>,
            result: $Utils.Optional<LiturgicalsegmentsCountAggregateOutputType> | number
          }
        }
      }
      ltextdata: {
        payload: ltextdataPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.ltextdataFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ltextdataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ltextdataFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ltextdataPayload>
          }
          findFirst: {
            args: Prisma.ltextdataFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ltextdataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ltextdataFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ltextdataPayload>
          }
          findMany: {
            args: Prisma.ltextdataFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ltextdataPayload>[]
          }
          create: {
            args: Prisma.ltextdataCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ltextdataPayload>
          }
          createMany: {
            args: Prisma.ltextdataCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ltextdataDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ltextdataPayload>
          }
          update: {
            args: Prisma.ltextdataUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ltextdataPayload>
          }
          deleteMany: {
            args: Prisma.ltextdataDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ltextdataUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ltextdataUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ltextdataPayload>
          }
          aggregate: {
            args: Prisma.LtextdataAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLtextdata>
          }
          groupBy: {
            args: Prisma.LtextdataGroupByArgs<ExtArgs>,
            result: $Utils.Optional<LtextdataGroupByOutputType>[]
          }
          count: {
            args: Prisma.ltextdataCountArgs<ExtArgs>,
            result: $Utils.Optional<LtextdataCountAggregateOutputType> | number
          }
        }
      }
      ltextversedata: {
        payload: ltextversedataPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.ltextversedataFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ltextversedataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ltextversedataFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ltextversedataPayload>
          }
          findFirst: {
            args: Prisma.ltextversedataFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ltextversedataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ltextversedataFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ltextversedataPayload>
          }
          findMany: {
            args: Prisma.ltextversedataFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ltextversedataPayload>[]
          }
          create: {
            args: Prisma.ltextversedataCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ltextversedataPayload>
          }
          createMany: {
            args: Prisma.ltextversedataCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ltextversedataDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ltextversedataPayload>
          }
          update: {
            args: Prisma.ltextversedataUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ltextversedataPayload>
          }
          deleteMany: {
            args: Prisma.ltextversedataDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ltextversedataUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ltextversedataUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ltextversedataPayload>
          }
          aggregate: {
            args: Prisma.LtextversedataAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLtextversedata>
          }
          groupBy: {
            args: Prisma.LtextversedataGroupByArgs<ExtArgs>,
            result: $Utils.Optional<LtextversedataGroupByOutputType>[]
          }
          count: {
            args: Prisma.ltextversedataCountArgs<ExtArgs>,
            result: $Utils.Optional<LtextversedataCountAggregateOutputType> | number
          }
        }
      }
      offering_goals: {
        payload: offering_goalsPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.offering_goalsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<offering_goalsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.offering_goalsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<offering_goalsPayload>
          }
          findFirst: {
            args: Prisma.offering_goalsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<offering_goalsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.offering_goalsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<offering_goalsPayload>
          }
          findMany: {
            args: Prisma.offering_goalsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<offering_goalsPayload>[]
          }
          create: {
            args: Prisma.offering_goalsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<offering_goalsPayload>
          }
          createMany: {
            args: Prisma.offering_goalsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.offering_goalsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<offering_goalsPayload>
          }
          update: {
            args: Prisma.offering_goalsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<offering_goalsPayload>
          }
          deleteMany: {
            args: Prisma.offering_goalsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.offering_goalsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.offering_goalsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<offering_goalsPayload>
          }
          aggregate: {
            args: Prisma.Offering_goalsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOffering_goals>
          }
          groupBy: {
            args: Prisma.Offering_goalsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Offering_goalsGroupByOutputType>[]
          }
          count: {
            args: Prisma.offering_goalsCountArgs<ExtArgs>,
            result: $Utils.Optional<Offering_goalsCountAggregateOutputType> | number
          }
        }
      }
      offering_targets: {
        payload: offering_targetsPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.offering_targetsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<offering_targetsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.offering_targetsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<offering_targetsPayload>
          }
          findFirst: {
            args: Prisma.offering_targetsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<offering_targetsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.offering_targetsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<offering_targetsPayload>
          }
          findMany: {
            args: Prisma.offering_targetsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<offering_targetsPayload>[]
          }
          create: {
            args: Prisma.offering_targetsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<offering_targetsPayload>
          }
          createMany: {
            args: Prisma.offering_targetsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.offering_targetsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<offering_targetsPayload>
          }
          update: {
            args: Prisma.offering_targetsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<offering_targetsPayload>
          }
          deleteMany: {
            args: Prisma.offering_targetsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.offering_targetsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.offering_targetsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<offering_targetsPayload>
          }
          aggregate: {
            args: Prisma.Offering_targetsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOffering_targets>
          }
          groupBy: {
            args: Prisma.Offering_targetsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Offering_targetsGroupByOutputType>[]
          }
          count: {
            args: Prisma.offering_targetsCountArgs<ExtArgs>,
            result: $Utils.Optional<Offering_targetsCountAggregateOutputType> | number
          }
        }
      }
      presentation_content: {
        payload: presentation_contentPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.presentation_contentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<presentation_contentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.presentation_contentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<presentation_contentPayload>
          }
          findFirst: {
            args: Prisma.presentation_contentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<presentation_contentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.presentation_contentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<presentation_contentPayload>
          }
          findMany: {
            args: Prisma.presentation_contentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<presentation_contentPayload>[]
          }
          create: {
            args: Prisma.presentation_contentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<presentation_contentPayload>
          }
          createMany: {
            args: Prisma.presentation_contentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.presentation_contentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<presentation_contentPayload>
          }
          update: {
            args: Prisma.presentation_contentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<presentation_contentPayload>
          }
          deleteMany: {
            args: Prisma.presentation_contentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.presentation_contentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.presentation_contentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<presentation_contentPayload>
          }
          aggregate: {
            args: Prisma.Presentation_contentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePresentation_content>
          }
          groupBy: {
            args: Prisma.Presentation_contentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Presentation_contentGroupByOutputType>[]
          }
          count: {
            args: Prisma.presentation_contentCountArgs<ExtArgs>,
            result: $Utils.Optional<Presentation_contentCountAggregateOutputType> | number
          }
        }
      }
      presentation_structure: {
        payload: presentation_structurePayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.presentation_structureFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<presentation_structurePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.presentation_structureFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<presentation_structurePayload>
          }
          findFirst: {
            args: Prisma.presentation_structureFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<presentation_structurePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.presentation_structureFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<presentation_structurePayload>
          }
          findMany: {
            args: Prisma.presentation_structureFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<presentation_structurePayload>[]
          }
          create: {
            args: Prisma.presentation_structureCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<presentation_structurePayload>
          }
          createMany: {
            args: Prisma.presentation_structureCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.presentation_structureDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<presentation_structurePayload>
          }
          update: {
            args: Prisma.presentation_structureUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<presentation_structurePayload>
          }
          deleteMany: {
            args: Prisma.presentation_structureDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.presentation_structureUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.presentation_structureUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<presentation_structurePayload>
          }
          aggregate: {
            args: Prisma.Presentation_structureAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePresentation_structure>
          }
          groupBy: {
            args: Prisma.Presentation_structureGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Presentation_structureGroupByOutputType>[]
          }
          count: {
            args: Prisma.presentation_structureCountArgs<ExtArgs>,
            result: $Utils.Optional<Presentation_structureCountAggregateOutputType> | number
          }
        }
      }
      responsibilities: {
        payload: responsibilitiesPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.responsibilitiesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<responsibilitiesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.responsibilitiesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<responsibilitiesPayload>
          }
          findFirst: {
            args: Prisma.responsibilitiesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<responsibilitiesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.responsibilitiesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<responsibilitiesPayload>
          }
          findMany: {
            args: Prisma.responsibilitiesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<responsibilitiesPayload>[]
          }
          create: {
            args: Prisma.responsibilitiesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<responsibilitiesPayload>
          }
          createMany: {
            args: Prisma.responsibilitiesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.responsibilitiesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<responsibilitiesPayload>
          }
          update: {
            args: Prisma.responsibilitiesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<responsibilitiesPayload>
          }
          deleteMany: {
            args: Prisma.responsibilitiesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.responsibilitiesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.responsibilitiesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<responsibilitiesPayload>
          }
          aggregate: {
            args: Prisma.ResponsibilitiesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateResponsibilities>
          }
          groupBy: {
            args: Prisma.ResponsibilitiesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ResponsibilitiesGroupByOutputType>[]
          }
          count: {
            args: Prisma.responsibilitiesCountArgs<ExtArgs>,
            result: $Utils.Optional<ResponsibilitiesCountAggregateOutputType> | number
          }
        }
      }
      responsibilities_meta: {
        payload: responsibilities_metaPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.responsibilities_metaFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<responsibilities_metaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.responsibilities_metaFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<responsibilities_metaPayload>
          }
          findFirst: {
            args: Prisma.responsibilities_metaFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<responsibilities_metaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.responsibilities_metaFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<responsibilities_metaPayload>
          }
          findMany: {
            args: Prisma.responsibilities_metaFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<responsibilities_metaPayload>[]
          }
          create: {
            args: Prisma.responsibilities_metaCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<responsibilities_metaPayload>
          }
          createMany: {
            args: Prisma.responsibilities_metaCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.responsibilities_metaDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<responsibilities_metaPayload>
          }
          update: {
            args: Prisma.responsibilities_metaUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<responsibilities_metaPayload>
          }
          deleteMany: {
            args: Prisma.responsibilities_metaDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.responsibilities_metaUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.responsibilities_metaUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<responsibilities_metaPayload>
          }
          aggregate: {
            args: Prisma.Responsibilities_metaAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateResponsibilities_meta>
          }
          groupBy: {
            args: Prisma.Responsibilities_metaGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Responsibilities_metaGroupByOutputType>[]
          }
          count: {
            args: Prisma.responsibilities_metaCountArgs<ExtArgs>,
            result: $Utils.Optional<Responsibilities_metaCountAggregateOutputType> | number
          }
        }
      }
      seasons: {
        payload: seasonsPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.seasonsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<seasonsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.seasonsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<seasonsPayload>
          }
          findFirst: {
            args: Prisma.seasonsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<seasonsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.seasonsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<seasonsPayload>
          }
          findMany: {
            args: Prisma.seasonsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<seasonsPayload>[]
          }
          create: {
            args: Prisma.seasonsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<seasonsPayload>
          }
          createMany: {
            args: Prisma.seasonsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.seasonsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<seasonsPayload>
          }
          update: {
            args: Prisma.seasonsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<seasonsPayload>
          }
          deleteMany: {
            args: Prisma.seasonsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.seasonsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.seasonsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<seasonsPayload>
          }
          aggregate: {
            args: Prisma.SeasonsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSeasons>
          }
          groupBy: {
            args: Prisma.SeasonsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SeasonsGroupByOutputType>[]
          }
          count: {
            args: Prisma.seasonsCountArgs<ExtArgs>,
            result: $Utils.Optional<SeasonsCountAggregateOutputType> | number
          }
        }
      }
      service_specific_presentation_structure: {
        payload: service_specific_presentation_structurePayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.service_specific_presentation_structureFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<service_specific_presentation_structurePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.service_specific_presentation_structureFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<service_specific_presentation_structurePayload>
          }
          findFirst: {
            args: Prisma.service_specific_presentation_structureFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<service_specific_presentation_structurePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.service_specific_presentation_structureFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<service_specific_presentation_structurePayload>
          }
          findMany: {
            args: Prisma.service_specific_presentation_structureFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<service_specific_presentation_structurePayload>[]
          }
          create: {
            args: Prisma.service_specific_presentation_structureCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<service_specific_presentation_structurePayload>
          }
          createMany: {
            args: Prisma.service_specific_presentation_structureCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.service_specific_presentation_structureDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<service_specific_presentation_structurePayload>
          }
          update: {
            args: Prisma.service_specific_presentation_structureUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<service_specific_presentation_structurePayload>
          }
          deleteMany: {
            args: Prisma.service_specific_presentation_structureDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.service_specific_presentation_structureUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.service_specific_presentation_structureUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<service_specific_presentation_structurePayload>
          }
          aggregate: {
            args: Prisma.Service_specific_presentation_structureAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateService_specific_presentation_structure>
          }
          groupBy: {
            args: Prisma.Service_specific_presentation_structureGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Service_specific_presentation_structureGroupByOutputType>[]
          }
          count: {
            args: Prisma.service_specific_presentation_structureCountArgs<ExtArgs>,
            result: $Utils.Optional<Service_specific_presentation_structureCountAggregateOutputType> | number
          }
        }
      }
      services: {
        payload: servicesPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.servicesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.servicesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicesPayload>
          }
          findFirst: {
            args: Prisma.servicesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.servicesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicesPayload>
          }
          findMany: {
            args: Prisma.servicesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicesPayload>[]
          }
          create: {
            args: Prisma.servicesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicesPayload>
          }
          createMany: {
            args: Prisma.servicesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.servicesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicesPayload>
          }
          update: {
            args: Prisma.servicesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicesPayload>
          }
          deleteMany: {
            args: Prisma.servicesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.servicesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.servicesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicesPayload>
          }
          aggregate: {
            args: Prisma.ServicesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateServices>
          }
          groupBy: {
            args: Prisma.ServicesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ServicesGroupByOutputType>[]
          }
          count: {
            args: Prisma.servicesCountArgs<ExtArgs>,
            result: $Utils.Optional<ServicesCountAggregateOutputType> | number
          }
        }
      }
      servicesongs: {
        payload: servicesongsPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.servicesongsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicesongsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.servicesongsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicesongsPayload>
          }
          findFirst: {
            args: Prisma.servicesongsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicesongsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.servicesongsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicesongsPayload>
          }
          findMany: {
            args: Prisma.servicesongsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicesongsPayload>[]
          }
          create: {
            args: Prisma.servicesongsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicesongsPayload>
          }
          createMany: {
            args: Prisma.servicesongsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.servicesongsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicesongsPayload>
          }
          update: {
            args: Prisma.servicesongsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicesongsPayload>
          }
          deleteMany: {
            args: Prisma.servicesongsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.servicesongsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.servicesongsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicesongsPayload>
          }
          aggregate: {
            args: Prisma.ServicesongsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateServicesongs>
          }
          groupBy: {
            args: Prisma.ServicesongsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ServicesongsGroupByOutputType>[]
          }
          count: {
            args: Prisma.servicesongsCountArgs<ExtArgs>,
            result: $Utils.Optional<ServicesongsCountAggregateOutputType> | number
          }
        }
      }
      serviceverses: {
        payload: serviceversesPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.serviceversesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<serviceversesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.serviceversesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<serviceversesPayload>
          }
          findFirst: {
            args: Prisma.serviceversesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<serviceversesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.serviceversesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<serviceversesPayload>
          }
          findMany: {
            args: Prisma.serviceversesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<serviceversesPayload>[]
          }
          create: {
            args: Prisma.serviceversesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<serviceversesPayload>
          }
          createMany: {
            args: Prisma.serviceversesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.serviceversesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<serviceversesPayload>
          }
          update: {
            args: Prisma.serviceversesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<serviceversesPayload>
          }
          deleteMany: {
            args: Prisma.serviceversesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.serviceversesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.serviceversesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<serviceversesPayload>
          }
          aggregate: {
            args: Prisma.ServiceversesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateServiceverses>
          }
          groupBy: {
            args: Prisma.ServiceversesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ServiceversesGroupByOutputType>[]
          }
          count: {
            args: Prisma.serviceversesCountArgs<ExtArgs>,
            result: $Utils.Optional<ServiceversesCountAggregateOutputType> | number
          }
        }
      }
      smallgroups: {
        payload: smallgroupsPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.smallgroupsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<smallgroupsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.smallgroupsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<smallgroupsPayload>
          }
          findFirst: {
            args: Prisma.smallgroupsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<smallgroupsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.smallgroupsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<smallgroupsPayload>
          }
          findMany: {
            args: Prisma.smallgroupsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<smallgroupsPayload>[]
          }
          create: {
            args: Prisma.smallgroupsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<smallgroupsPayload>
          }
          createMany: {
            args: Prisma.smallgroupsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.smallgroupsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<smallgroupsPayload>
          }
          update: {
            args: Prisma.smallgroupsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<smallgroupsPayload>
          }
          deleteMany: {
            args: Prisma.smallgroupsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.smallgroupsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.smallgroupsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<smallgroupsPayload>
          }
          aggregate: {
            args: Prisma.SmallgroupsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSmallgroups>
          }
          groupBy: {
            args: Prisma.SmallgroupsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SmallgroupsGroupByOutputType>[]
          }
          count: {
            args: Prisma.smallgroupsCountArgs<ExtArgs>,
            result: $Utils.Optional<SmallgroupsCountAggregateOutputType> | number
          }
        }
      }
      songdata: {
        payload: songdataPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.songdataFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<songdataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.songdataFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<songdataPayload>
          }
          findFirst: {
            args: Prisma.songdataFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<songdataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.songdataFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<songdataPayload>
          }
          findMany: {
            args: Prisma.songdataFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<songdataPayload>[]
          }
          create: {
            args: Prisma.songdataCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<songdataPayload>
          }
          createMany: {
            args: Prisma.songdataCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.songdataDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<songdataPayload>
          }
          update: {
            args: Prisma.songdataUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<songdataPayload>
          }
          deleteMany: {
            args: Prisma.songdataDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.songdataUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.songdataUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<songdataPayload>
          }
          aggregate: {
            args: Prisma.SongdataAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSongdata>
          }
          groupBy: {
            args: Prisma.SongdataGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SongdataGroupByOutputType>[]
          }
          count: {
            args: Prisma.songdataCountArgs<ExtArgs>,
            result: $Utils.Optional<SongdataCountAggregateOutputType> | number
          }
        }
      }
      songsegments: {
        payload: songsegmentsPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.songsegmentsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<songsegmentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.songsegmentsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<songsegmentsPayload>
          }
          findFirst: {
            args: Prisma.songsegmentsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<songsegmentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.songsegmentsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<songsegmentsPayload>
          }
          findMany: {
            args: Prisma.songsegmentsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<songsegmentsPayload>[]
          }
          create: {
            args: Prisma.songsegmentsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<songsegmentsPayload>
          }
          createMany: {
            args: Prisma.songsegmentsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.songsegmentsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<songsegmentsPayload>
          }
          update: {
            args: Prisma.songsegmentsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<songsegmentsPayload>
          }
          deleteMany: {
            args: Prisma.songsegmentsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.songsegmentsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.songsegmentsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<songsegmentsPayload>
          }
          aggregate: {
            args: Prisma.SongsegmentsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSongsegments>
          }
          groupBy: {
            args: Prisma.SongsegmentsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SongsegmentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.songsegmentsCountArgs<ExtArgs>,
            result: $Utils.Optional<SongsegmentsCountAggregateOutputType> | number
          }
        }
      }
      songtags: {
        payload: songtagsPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.songtagsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<songtagsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.songtagsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<songtagsPayload>
          }
          findFirst: {
            args: Prisma.songtagsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<songtagsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.songtagsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<songtagsPayload>
          }
          findMany: {
            args: Prisma.songtagsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<songtagsPayload>[]
          }
          create: {
            args: Prisma.songtagsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<songtagsPayload>
          }
          createMany: {
            args: Prisma.songtagsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.songtagsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<songtagsPayload>
          }
          update: {
            args: Prisma.songtagsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<songtagsPayload>
          }
          deleteMany: {
            args: Prisma.songtagsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.songtagsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.songtagsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<songtagsPayload>
          }
          aggregate: {
            args: Prisma.SongtagsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSongtags>
          }
          groupBy: {
            args: Prisma.SongtagsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SongtagsGroupByOutputType>[]
          }
          count: {
            args: Prisma.songtagsCountArgs<ExtArgs>,
            result: $Utils.Optional<SongtagsCountAggregateOutputType> | number
          }
        }
      }
      styles: {
        payload: stylesPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.stylesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<stylesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.stylesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<stylesPayload>
          }
          findFirst: {
            args: Prisma.stylesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<stylesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.stylesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<stylesPayload>
          }
          findMany: {
            args: Prisma.stylesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<stylesPayload>[]
          }
          create: {
            args: Prisma.stylesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<stylesPayload>
          }
          createMany: {
            args: Prisma.stylesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.stylesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<stylesPayload>
          }
          update: {
            args: Prisma.stylesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<stylesPayload>
          }
          deleteMany: {
            args: Prisma.stylesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.stylesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.stylesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<stylesPayload>
          }
          aggregate: {
            args: Prisma.StylesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateStyles>
          }
          groupBy: {
            args: Prisma.StylesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<StylesGroupByOutputType>[]
          }
          count: {
            args: Prisma.stylesCountArgs<ExtArgs>,
            result: $Utils.Optional<StylesCountAggregateOutputType> | number
          }
        }
      }
      users: {
        payload: usersPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.usersFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usersFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<usersPayload>
          }
          findFirst: {
            args: Prisma.usersFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usersFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<usersPayload>
          }
          findMany: {
            args: Prisma.usersFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<usersPayload>[]
          }
          create: {
            args: Prisma.usersCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<usersPayload>
          }
          createMany: {
            args: Prisma.usersCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.usersDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<usersPayload>
          }
          update: {
            args: Prisma.usersUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<usersPayload>
          }
          deleteMany: {
            args: Prisma.usersDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.usersUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.usersUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<usersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.UsersGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.usersCountArgs<ExtArgs>,
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      versedata: {
        payload: versedataPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.versedataFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<versedataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.versedataFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<versedataPayload>
          }
          findFirst: {
            args: Prisma.versedataFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<versedataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.versedataFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<versedataPayload>
          }
          findMany: {
            args: Prisma.versedataFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<versedataPayload>[]
          }
          create: {
            args: Prisma.versedataCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<versedataPayload>
          }
          createMany: {
            args: Prisma.versedataCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.versedataDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<versedataPayload>
          }
          update: {
            args: Prisma.versedataUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<versedataPayload>
          }
          deleteMany: {
            args: Prisma.versedataDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.versedataUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.versedataUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<versedataPayload>
          }
          aggregate: {
            args: Prisma.VersedataAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateVersedata>
          }
          groupBy: {
            args: Prisma.VersedataGroupByArgs<ExtArgs>,
            result: $Utils.Optional<VersedataGroupByOutputType>[]
          }
          count: {
            args: Prisma.versedataCountArgs<ExtArgs>,
            result: $Utils.Optional<VersedataCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type LtextdataCountOutputType
   */


  export type LtextdataCountOutputType = {
    ltextversedata: number
  }

  export type LtextdataCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    ltextversedata?: boolean | LtextdataCountOutputTypeCountLtextversedataArgs
  }

  // Custom InputTypes

  /**
   * LtextdataCountOutputType without action
   */
  export type LtextdataCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LtextdataCountOutputType
     */
    select?: LtextdataCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * LtextdataCountOutputType without action
   */
  export type LtextdataCountOutputTypeCountLtextversedataArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ltextversedataWhereInput
  }



  /**
   * Count Type Offering_goalsCountOutputType
   */


  export type Offering_goalsCountOutputType = {
    collected_offerings: number
  }

  export type Offering_goalsCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    collected_offerings?: boolean | Offering_goalsCountOutputTypeCountCollected_offeringsArgs
  }

  // Custom InputTypes

  /**
   * Offering_goalsCountOutputType without action
   */
  export type Offering_goalsCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offering_goalsCountOutputType
     */
    select?: Offering_goalsCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * Offering_goalsCountOutputType without action
   */
  export type Offering_goalsCountOutputTypeCountCollected_offeringsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: collected_offeringsWhereInput
  }



  /**
   * Count Type Offering_targetsCountOutputType
   */


  export type Offering_targetsCountOutputType = {
    offering_goals: number
  }

  export type Offering_targetsCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    offering_goals?: boolean | Offering_targetsCountOutputTypeCountOffering_goalsArgs
  }

  // Custom InputTypes

  /**
   * Offering_targetsCountOutputType without action
   */
  export type Offering_targetsCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offering_targetsCountOutputType
     */
    select?: Offering_targetsCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * Offering_targetsCountOutputType without action
   */
  export type Offering_targetsCountOutputTypeCountOffering_goalsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: offering_goalsWhereInput
  }



  /**
   * Count Type Presentation_structureCountOutputType
   */


  export type Presentation_structureCountOutputType = {
    presentation_content: number
  }

  export type Presentation_structureCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    presentation_content?: boolean | Presentation_structureCountOutputTypeCountPresentation_contentArgs
  }

  // Custom InputTypes

  /**
   * Presentation_structureCountOutputType without action
   */
  export type Presentation_structureCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Presentation_structureCountOutputType
     */
    select?: Presentation_structureCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * Presentation_structureCountOutputType without action
   */
  export type Presentation_structureCountOutputTypeCountPresentation_contentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: presentation_contentWhereInput
  }



  /**
   * Count Type ServicesCountOutputType
   */


  export type ServicesCountOutputType = {
    collected_offerings: number
    comments: number
    responsibilities: number
    servicesongs: number
    serviceverses: number
  }

  export type ServicesCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    collected_offerings?: boolean | ServicesCountOutputTypeCountCollected_offeringsArgs
    comments?: boolean | ServicesCountOutputTypeCountCommentsArgs
    responsibilities?: boolean | ServicesCountOutputTypeCountResponsibilitiesArgs
    servicesongs?: boolean | ServicesCountOutputTypeCountServicesongsArgs
    serviceverses?: boolean | ServicesCountOutputTypeCountServiceversesArgs
  }

  // Custom InputTypes

  /**
   * ServicesCountOutputType without action
   */
  export type ServicesCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicesCountOutputType
     */
    select?: ServicesCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ServicesCountOutputType without action
   */
  export type ServicesCountOutputTypeCountCollected_offeringsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: collected_offeringsWhereInput
  }


  /**
   * ServicesCountOutputType without action
   */
  export type ServicesCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: commentsWhereInput
  }


  /**
   * ServicesCountOutputType without action
   */
  export type ServicesCountOutputTypeCountResponsibilitiesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: responsibilitiesWhereInput
  }


  /**
   * ServicesCountOutputType without action
   */
  export type ServicesCountOutputTypeCountServicesongsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: servicesongsWhereInput
  }


  /**
   * ServicesCountOutputType without action
   */
  export type ServicesCountOutputTypeCountServiceversesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: serviceversesWhereInput
  }



  /**
   * Count Type SongdataCountOutputType
   */


  export type SongdataCountOutputType = {
    songtags: number
    versedata: number
  }

  export type SongdataCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    songtags?: boolean | SongdataCountOutputTypeCountSongtagsArgs
    versedata?: boolean | SongdataCountOutputTypeCountVersedataArgs
  }

  // Custom InputTypes

  /**
   * SongdataCountOutputType without action
   */
  export type SongdataCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SongdataCountOutputType
     */
    select?: SongdataCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * SongdataCountOutputType without action
   */
  export type SongdataCountOutputTypeCountSongtagsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: songtagsWhereInput
  }


  /**
   * SongdataCountOutputType without action
   */
  export type SongdataCountOutputTypeCountVersedataArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: versedataWhereInput
  }



  /**
   * Models
   */

  /**
   * Model backgrounds
   */


  export type AggregateBackgrounds = {
    _count: BackgroundsCountAggregateOutputType | null
    _avg: BackgroundsAvgAggregateOutputType | null
    _sum: BackgroundsSumAggregateOutputType | null
    _min: BackgroundsMinAggregateOutputType | null
    _max: BackgroundsMaxAggregateOutputType | null
  }

  export type BackgroundsAvgAggregateOutputType = {
    id: number | null
  }

  export type BackgroundsSumAggregateOutputType = {
    id: number | null
  }

  export type BackgroundsMinAggregateOutputType = {
    id: number | null
    filename: string | null
    description: string | null
  }

  export type BackgroundsMaxAggregateOutputType = {
    id: number | null
    filename: string | null
    description: string | null
  }

  export type BackgroundsCountAggregateOutputType = {
    id: number
    filename: number
    description: number
    _all: number
  }


  export type BackgroundsAvgAggregateInputType = {
    id?: true
  }

  export type BackgroundsSumAggregateInputType = {
    id?: true
  }

  export type BackgroundsMinAggregateInputType = {
    id?: true
    filename?: true
    description?: true
  }

  export type BackgroundsMaxAggregateInputType = {
    id?: true
    filename?: true
    description?: true
  }

  export type BackgroundsCountAggregateInputType = {
    id?: true
    filename?: true
    description?: true
    _all?: true
  }

  export type BackgroundsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which backgrounds to aggregate.
     */
    where?: backgroundsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of backgrounds to fetch.
     */
    orderBy?: Enumerable<backgroundsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: backgroundsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` backgrounds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` backgrounds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned backgrounds
    **/
    _count?: true | BackgroundsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BackgroundsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BackgroundsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BackgroundsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BackgroundsMaxAggregateInputType
  }

  export type GetBackgroundsAggregateType<T extends BackgroundsAggregateArgs> = {
        [P in keyof T & keyof AggregateBackgrounds]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBackgrounds[P]>
      : GetScalarType<T[P], AggregateBackgrounds[P]>
  }




  export type BackgroundsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: backgroundsWhereInput
    orderBy?: Enumerable<backgroundsOrderByWithAggregationInput>
    by: BackgroundsScalarFieldEnum[]
    having?: backgroundsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BackgroundsCountAggregateInputType | true
    _avg?: BackgroundsAvgAggregateInputType
    _sum?: BackgroundsSumAggregateInputType
    _min?: BackgroundsMinAggregateInputType
    _max?: BackgroundsMaxAggregateInputType
  }


  export type BackgroundsGroupByOutputType = {
    id: number
    filename: string | null
    description: string | null
    _count: BackgroundsCountAggregateOutputType | null
    _avg: BackgroundsAvgAggregateOutputType | null
    _sum: BackgroundsSumAggregateOutputType | null
    _min: BackgroundsMinAggregateOutputType | null
    _max: BackgroundsMaxAggregateOutputType | null
  }

  type GetBackgroundsGroupByPayload<T extends BackgroundsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<BackgroundsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BackgroundsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BackgroundsGroupByOutputType[P]>
            : GetScalarType<T[P], BackgroundsGroupByOutputType[P]>
        }
      >
    >


  export type backgroundsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filename?: boolean
    description?: boolean
  }, ExtArgs["result"]["backgrounds"]>

  export type backgroundsSelectScalar = {
    id?: boolean
    filename?: boolean
    description?: boolean
  }


  type backgroundsGetPayload<S extends boolean | null | undefined | backgroundsArgs> = $Types.GetResult<backgroundsPayload, S>

  type backgroundsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<backgroundsFindManyArgs, 'select' | 'include'> & {
      select?: BackgroundsCountAggregateInputType | true
    }

  export interface backgroundsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['backgrounds'], meta: { name: 'backgrounds' } }
    /**
     * Find zero or one Backgrounds that matches the filter.
     * @param {backgroundsFindUniqueArgs} args - Arguments to find a Backgrounds
     * @example
     * // Get one Backgrounds
     * const backgrounds = await prisma.backgrounds.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends backgroundsFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, backgroundsFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'backgrounds'> extends True ? Prisma__backgroundsClient<$Types.GetResult<backgroundsPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__backgroundsClient<$Types.GetResult<backgroundsPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Backgrounds that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {backgroundsFindUniqueOrThrowArgs} args - Arguments to find a Backgrounds
     * @example
     * // Get one Backgrounds
     * const backgrounds = await prisma.backgrounds.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends backgroundsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, backgroundsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__backgroundsClient<$Types.GetResult<backgroundsPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Backgrounds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {backgroundsFindFirstArgs} args - Arguments to find a Backgrounds
     * @example
     * // Get one Backgrounds
     * const backgrounds = await prisma.backgrounds.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends backgroundsFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, backgroundsFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'backgrounds'> extends True ? Prisma__backgroundsClient<$Types.GetResult<backgroundsPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__backgroundsClient<$Types.GetResult<backgroundsPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Backgrounds that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {backgroundsFindFirstOrThrowArgs} args - Arguments to find a Backgrounds
     * @example
     * // Get one Backgrounds
     * const backgrounds = await prisma.backgrounds.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends backgroundsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, backgroundsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__backgroundsClient<$Types.GetResult<backgroundsPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Backgrounds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {backgroundsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Backgrounds
     * const backgrounds = await prisma.backgrounds.findMany()
     * 
     * // Get first 10 Backgrounds
     * const backgrounds = await prisma.backgrounds.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const backgroundsWithIdOnly = await prisma.backgrounds.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends backgroundsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, backgroundsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<backgroundsPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Backgrounds.
     * @param {backgroundsCreateArgs} args - Arguments to create a Backgrounds.
     * @example
     * // Create one Backgrounds
     * const Backgrounds = await prisma.backgrounds.create({
     *   data: {
     *     // ... data to create a Backgrounds
     *   }
     * })
     * 
    **/
    create<T extends backgroundsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, backgroundsCreateArgs<ExtArgs>>
    ): Prisma__backgroundsClient<$Types.GetResult<backgroundsPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Backgrounds.
     *     @param {backgroundsCreateManyArgs} args - Arguments to create many Backgrounds.
     *     @example
     *     // Create many Backgrounds
     *     const backgrounds = await prisma.backgrounds.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends backgroundsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, backgroundsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Backgrounds.
     * @param {backgroundsDeleteArgs} args - Arguments to delete one Backgrounds.
     * @example
     * // Delete one Backgrounds
     * const Backgrounds = await prisma.backgrounds.delete({
     *   where: {
     *     // ... filter to delete one Backgrounds
     *   }
     * })
     * 
    **/
    delete<T extends backgroundsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, backgroundsDeleteArgs<ExtArgs>>
    ): Prisma__backgroundsClient<$Types.GetResult<backgroundsPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Backgrounds.
     * @param {backgroundsUpdateArgs} args - Arguments to update one Backgrounds.
     * @example
     * // Update one Backgrounds
     * const backgrounds = await prisma.backgrounds.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends backgroundsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, backgroundsUpdateArgs<ExtArgs>>
    ): Prisma__backgroundsClient<$Types.GetResult<backgroundsPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Backgrounds.
     * @param {backgroundsDeleteManyArgs} args - Arguments to filter Backgrounds to delete.
     * @example
     * // Delete a few Backgrounds
     * const { count } = await prisma.backgrounds.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends backgroundsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, backgroundsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Backgrounds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {backgroundsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Backgrounds
     * const backgrounds = await prisma.backgrounds.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends backgroundsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, backgroundsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Backgrounds.
     * @param {backgroundsUpsertArgs} args - Arguments to update or create a Backgrounds.
     * @example
     * // Update or create a Backgrounds
     * const backgrounds = await prisma.backgrounds.upsert({
     *   create: {
     *     // ... data to create a Backgrounds
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Backgrounds we want to update
     *   }
     * })
    **/
    upsert<T extends backgroundsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, backgroundsUpsertArgs<ExtArgs>>
    ): Prisma__backgroundsClient<$Types.GetResult<backgroundsPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Backgrounds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {backgroundsCountArgs} args - Arguments to filter Backgrounds to count.
     * @example
     * // Count the number of Backgrounds
     * const count = await prisma.backgrounds.count({
     *   where: {
     *     // ... the filter for the Backgrounds we want to count
     *   }
     * })
    **/
    count<T extends backgroundsCountArgs>(
      args?: Subset<T, backgroundsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BackgroundsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Backgrounds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackgroundsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BackgroundsAggregateArgs>(args: Subset<T, BackgroundsAggregateArgs>): Prisma.PrismaPromise<GetBackgroundsAggregateType<T>>

    /**
     * Group by Backgrounds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackgroundsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BackgroundsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BackgroundsGroupByArgs['orderBy'] }
        : { orderBy?: BackgroundsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BackgroundsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBackgroundsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for backgrounds.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__backgroundsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * backgrounds base type for findUnique actions
   */
  export type backgroundsFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the backgrounds
     */
    select?: backgroundsSelect<ExtArgs> | null
    /**
     * Filter, which backgrounds to fetch.
     */
    where: backgroundsWhereUniqueInput
  }

  /**
   * backgrounds findUnique
   */
  export interface backgroundsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends backgroundsFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * backgrounds findUniqueOrThrow
   */
  export type backgroundsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the backgrounds
     */
    select?: backgroundsSelect<ExtArgs> | null
    /**
     * Filter, which backgrounds to fetch.
     */
    where: backgroundsWhereUniqueInput
  }


  /**
   * backgrounds base type for findFirst actions
   */
  export type backgroundsFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the backgrounds
     */
    select?: backgroundsSelect<ExtArgs> | null
    /**
     * Filter, which backgrounds to fetch.
     */
    where?: backgroundsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of backgrounds to fetch.
     */
    orderBy?: Enumerable<backgroundsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for backgrounds.
     */
    cursor?: backgroundsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` backgrounds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` backgrounds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of backgrounds.
     */
    distinct?: Enumerable<BackgroundsScalarFieldEnum>
  }

  /**
   * backgrounds findFirst
   */
  export interface backgroundsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends backgroundsFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * backgrounds findFirstOrThrow
   */
  export type backgroundsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the backgrounds
     */
    select?: backgroundsSelect<ExtArgs> | null
    /**
     * Filter, which backgrounds to fetch.
     */
    where?: backgroundsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of backgrounds to fetch.
     */
    orderBy?: Enumerable<backgroundsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for backgrounds.
     */
    cursor?: backgroundsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` backgrounds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` backgrounds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of backgrounds.
     */
    distinct?: Enumerable<BackgroundsScalarFieldEnum>
  }


  /**
   * backgrounds findMany
   */
  export type backgroundsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the backgrounds
     */
    select?: backgroundsSelect<ExtArgs> | null
    /**
     * Filter, which backgrounds to fetch.
     */
    where?: backgroundsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of backgrounds to fetch.
     */
    orderBy?: Enumerable<backgroundsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing backgrounds.
     */
    cursor?: backgroundsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` backgrounds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` backgrounds.
     */
    skip?: number
    distinct?: Enumerable<BackgroundsScalarFieldEnum>
  }


  /**
   * backgrounds create
   */
  export type backgroundsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the backgrounds
     */
    select?: backgroundsSelect<ExtArgs> | null
    /**
     * The data needed to create a backgrounds.
     */
    data?: XOR<backgroundsCreateInput, backgroundsUncheckedCreateInput>
  }


  /**
   * backgrounds createMany
   */
  export type backgroundsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many backgrounds.
     */
    data: Enumerable<backgroundsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * backgrounds update
   */
  export type backgroundsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the backgrounds
     */
    select?: backgroundsSelect<ExtArgs> | null
    /**
     * The data needed to update a backgrounds.
     */
    data: XOR<backgroundsUpdateInput, backgroundsUncheckedUpdateInput>
    /**
     * Choose, which backgrounds to update.
     */
    where: backgroundsWhereUniqueInput
  }


  /**
   * backgrounds updateMany
   */
  export type backgroundsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update backgrounds.
     */
    data: XOR<backgroundsUpdateManyMutationInput, backgroundsUncheckedUpdateManyInput>
    /**
     * Filter which backgrounds to update
     */
    where?: backgroundsWhereInput
  }


  /**
   * backgrounds upsert
   */
  export type backgroundsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the backgrounds
     */
    select?: backgroundsSelect<ExtArgs> | null
    /**
     * The filter to search for the backgrounds to update in case it exists.
     */
    where: backgroundsWhereUniqueInput
    /**
     * In case the backgrounds found by the `where` argument doesn't exist, create a new backgrounds with this data.
     */
    create: XOR<backgroundsCreateInput, backgroundsUncheckedCreateInput>
    /**
     * In case the backgrounds was found with the provided `where` argument, update it with this data.
     */
    update: XOR<backgroundsUpdateInput, backgroundsUncheckedUpdateInput>
  }


  /**
   * backgrounds delete
   */
  export type backgroundsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the backgrounds
     */
    select?: backgroundsSelect<ExtArgs> | null
    /**
     * Filter which backgrounds to delete.
     */
    where: backgroundsWhereUniqueInput
  }


  /**
   * backgrounds deleteMany
   */
  export type backgroundsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which backgrounds to delete
     */
    where?: backgroundsWhereInput
  }


  /**
   * backgrounds without action
   */
  export type backgroundsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the backgrounds
     */
    select?: backgroundsSelect<ExtArgs> | null
  }



  /**
   * Model biblesegments
   */


  export type AggregateBiblesegments = {
    _count: BiblesegmentsCountAggregateOutputType | null
    _avg: BiblesegmentsAvgAggregateOutputType | null
    _sum: BiblesegmentsSumAggregateOutputType | null
    _min: BiblesegmentsMinAggregateOutputType | null
    _max: BiblesegmentsMaxAggregateOutputType | null
  }

  export type BiblesegmentsAvgAggregateOutputType = {
    id: number | null
    start_chap: number | null
    start_verse: number | null
    end_chap: number | null
    end_verse: number | null
  }

  export type BiblesegmentsSumAggregateOutputType = {
    id: number | null
    start_chap: number | null
    start_verse: number | null
    end_chap: number | null
    end_verse: number | null
  }

  export type BiblesegmentsMinAggregateOutputType = {
    id: number | null
    start_book: string | null
    start_chap: number | null
    start_verse: number | null
    end_book: string | null
    end_chap: number | null
    end_verse: number | null
  }

  export type BiblesegmentsMaxAggregateOutputType = {
    id: number | null
    start_book: string | null
    start_chap: number | null
    start_verse: number | null
    end_book: string | null
    end_chap: number | null
    end_verse: number | null
  }

  export type BiblesegmentsCountAggregateOutputType = {
    id: number
    start_book: number
    start_chap: number
    start_verse: number
    end_book: number
    end_chap: number
    end_verse: number
    _all: number
  }


  export type BiblesegmentsAvgAggregateInputType = {
    id?: true
    start_chap?: true
    start_verse?: true
    end_chap?: true
    end_verse?: true
  }

  export type BiblesegmentsSumAggregateInputType = {
    id?: true
    start_chap?: true
    start_verse?: true
    end_chap?: true
    end_verse?: true
  }

  export type BiblesegmentsMinAggregateInputType = {
    id?: true
    start_book?: true
    start_chap?: true
    start_verse?: true
    end_book?: true
    end_chap?: true
    end_verse?: true
  }

  export type BiblesegmentsMaxAggregateInputType = {
    id?: true
    start_book?: true
    start_chap?: true
    start_verse?: true
    end_book?: true
    end_chap?: true
    end_verse?: true
  }

  export type BiblesegmentsCountAggregateInputType = {
    id?: true
    start_book?: true
    start_chap?: true
    start_verse?: true
    end_book?: true
    end_chap?: true
    end_verse?: true
    _all?: true
  }

  export type BiblesegmentsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which biblesegments to aggregate.
     */
    where?: biblesegmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of biblesegments to fetch.
     */
    orderBy?: Enumerable<biblesegmentsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: biblesegmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` biblesegments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` biblesegments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned biblesegments
    **/
    _count?: true | BiblesegmentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BiblesegmentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BiblesegmentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BiblesegmentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BiblesegmentsMaxAggregateInputType
  }

  export type GetBiblesegmentsAggregateType<T extends BiblesegmentsAggregateArgs> = {
        [P in keyof T & keyof AggregateBiblesegments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBiblesegments[P]>
      : GetScalarType<T[P], AggregateBiblesegments[P]>
  }




  export type BiblesegmentsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: biblesegmentsWhereInput
    orderBy?: Enumerable<biblesegmentsOrderByWithAggregationInput>
    by: BiblesegmentsScalarFieldEnum[]
    having?: biblesegmentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BiblesegmentsCountAggregateInputType | true
    _avg?: BiblesegmentsAvgAggregateInputType
    _sum?: BiblesegmentsSumAggregateInputType
    _min?: BiblesegmentsMinAggregateInputType
    _max?: BiblesegmentsMaxAggregateInputType
  }


  export type BiblesegmentsGroupByOutputType = {
    id: number
    start_book: string | null
    start_chap: number | null
    start_verse: number | null
    end_book: string | null
    end_chap: number | null
    end_verse: number | null
    _count: BiblesegmentsCountAggregateOutputType | null
    _avg: BiblesegmentsAvgAggregateOutputType | null
    _sum: BiblesegmentsSumAggregateOutputType | null
    _min: BiblesegmentsMinAggregateOutputType | null
    _max: BiblesegmentsMaxAggregateOutputType | null
  }

  type GetBiblesegmentsGroupByPayload<T extends BiblesegmentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<BiblesegmentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BiblesegmentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BiblesegmentsGroupByOutputType[P]>
            : GetScalarType<T[P], BiblesegmentsGroupByOutputType[P]>
        }
      >
    >


  export type biblesegmentsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    start_book?: boolean
    start_chap?: boolean
    start_verse?: boolean
    end_book?: boolean
    end_chap?: boolean
    end_verse?: boolean
  }, ExtArgs["result"]["biblesegments"]>

  export type biblesegmentsSelectScalar = {
    id?: boolean
    start_book?: boolean
    start_chap?: boolean
    start_verse?: boolean
    end_book?: boolean
    end_chap?: boolean
    end_verse?: boolean
  }


  type biblesegmentsGetPayload<S extends boolean | null | undefined | biblesegmentsArgs> = $Types.GetResult<biblesegmentsPayload, S>

  type biblesegmentsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<biblesegmentsFindManyArgs, 'select' | 'include'> & {
      select?: BiblesegmentsCountAggregateInputType | true
    }

  export interface biblesegmentsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['biblesegments'], meta: { name: 'biblesegments' } }
    /**
     * Find zero or one Biblesegments that matches the filter.
     * @param {biblesegmentsFindUniqueArgs} args - Arguments to find a Biblesegments
     * @example
     * // Get one Biblesegments
     * const biblesegments = await prisma.biblesegments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends biblesegmentsFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, biblesegmentsFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'biblesegments'> extends True ? Prisma__biblesegmentsClient<$Types.GetResult<biblesegmentsPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__biblesegmentsClient<$Types.GetResult<biblesegmentsPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Biblesegments that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {biblesegmentsFindUniqueOrThrowArgs} args - Arguments to find a Biblesegments
     * @example
     * // Get one Biblesegments
     * const biblesegments = await prisma.biblesegments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends biblesegmentsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, biblesegmentsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__biblesegmentsClient<$Types.GetResult<biblesegmentsPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Biblesegments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {biblesegmentsFindFirstArgs} args - Arguments to find a Biblesegments
     * @example
     * // Get one Biblesegments
     * const biblesegments = await prisma.biblesegments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends biblesegmentsFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, biblesegmentsFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'biblesegments'> extends True ? Prisma__biblesegmentsClient<$Types.GetResult<biblesegmentsPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__biblesegmentsClient<$Types.GetResult<biblesegmentsPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Biblesegments that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {biblesegmentsFindFirstOrThrowArgs} args - Arguments to find a Biblesegments
     * @example
     * // Get one Biblesegments
     * const biblesegments = await prisma.biblesegments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends biblesegmentsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, biblesegmentsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__biblesegmentsClient<$Types.GetResult<biblesegmentsPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Biblesegments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {biblesegmentsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Biblesegments
     * const biblesegments = await prisma.biblesegments.findMany()
     * 
     * // Get first 10 Biblesegments
     * const biblesegments = await prisma.biblesegments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const biblesegmentsWithIdOnly = await prisma.biblesegments.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends biblesegmentsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, biblesegmentsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<biblesegmentsPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Biblesegments.
     * @param {biblesegmentsCreateArgs} args - Arguments to create a Biblesegments.
     * @example
     * // Create one Biblesegments
     * const Biblesegments = await prisma.biblesegments.create({
     *   data: {
     *     // ... data to create a Biblesegments
     *   }
     * })
     * 
    **/
    create<T extends biblesegmentsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, biblesegmentsCreateArgs<ExtArgs>>
    ): Prisma__biblesegmentsClient<$Types.GetResult<biblesegmentsPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Biblesegments.
     *     @param {biblesegmentsCreateManyArgs} args - Arguments to create many Biblesegments.
     *     @example
     *     // Create many Biblesegments
     *     const biblesegments = await prisma.biblesegments.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends biblesegmentsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, biblesegmentsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Biblesegments.
     * @param {biblesegmentsDeleteArgs} args - Arguments to delete one Biblesegments.
     * @example
     * // Delete one Biblesegments
     * const Biblesegments = await prisma.biblesegments.delete({
     *   where: {
     *     // ... filter to delete one Biblesegments
     *   }
     * })
     * 
    **/
    delete<T extends biblesegmentsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, biblesegmentsDeleteArgs<ExtArgs>>
    ): Prisma__biblesegmentsClient<$Types.GetResult<biblesegmentsPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Biblesegments.
     * @param {biblesegmentsUpdateArgs} args - Arguments to update one Biblesegments.
     * @example
     * // Update one Biblesegments
     * const biblesegments = await prisma.biblesegments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends biblesegmentsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, biblesegmentsUpdateArgs<ExtArgs>>
    ): Prisma__biblesegmentsClient<$Types.GetResult<biblesegmentsPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Biblesegments.
     * @param {biblesegmentsDeleteManyArgs} args - Arguments to filter Biblesegments to delete.
     * @example
     * // Delete a few Biblesegments
     * const { count } = await prisma.biblesegments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends biblesegmentsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, biblesegmentsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Biblesegments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {biblesegmentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Biblesegments
     * const biblesegments = await prisma.biblesegments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends biblesegmentsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, biblesegmentsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Biblesegments.
     * @param {biblesegmentsUpsertArgs} args - Arguments to update or create a Biblesegments.
     * @example
     * // Update or create a Biblesegments
     * const biblesegments = await prisma.biblesegments.upsert({
     *   create: {
     *     // ... data to create a Biblesegments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Biblesegments we want to update
     *   }
     * })
    **/
    upsert<T extends biblesegmentsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, biblesegmentsUpsertArgs<ExtArgs>>
    ): Prisma__biblesegmentsClient<$Types.GetResult<biblesegmentsPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Biblesegments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {biblesegmentsCountArgs} args - Arguments to filter Biblesegments to count.
     * @example
     * // Count the number of Biblesegments
     * const count = await prisma.biblesegments.count({
     *   where: {
     *     // ... the filter for the Biblesegments we want to count
     *   }
     * })
    **/
    count<T extends biblesegmentsCountArgs>(
      args?: Subset<T, biblesegmentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BiblesegmentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Biblesegments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiblesegmentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BiblesegmentsAggregateArgs>(args: Subset<T, BiblesegmentsAggregateArgs>): Prisma.PrismaPromise<GetBiblesegmentsAggregateType<T>>

    /**
     * Group by Biblesegments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiblesegmentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BiblesegmentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BiblesegmentsGroupByArgs['orderBy'] }
        : { orderBy?: BiblesegmentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BiblesegmentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBiblesegmentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for biblesegments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__biblesegmentsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * biblesegments base type for findUnique actions
   */
  export type biblesegmentsFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the biblesegments
     */
    select?: biblesegmentsSelect<ExtArgs> | null
    /**
     * Filter, which biblesegments to fetch.
     */
    where: biblesegmentsWhereUniqueInput
  }

  /**
   * biblesegments findUnique
   */
  export interface biblesegmentsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends biblesegmentsFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * biblesegments findUniqueOrThrow
   */
  export type biblesegmentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the biblesegments
     */
    select?: biblesegmentsSelect<ExtArgs> | null
    /**
     * Filter, which biblesegments to fetch.
     */
    where: biblesegmentsWhereUniqueInput
  }


  /**
   * biblesegments base type for findFirst actions
   */
  export type biblesegmentsFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the biblesegments
     */
    select?: biblesegmentsSelect<ExtArgs> | null
    /**
     * Filter, which biblesegments to fetch.
     */
    where?: biblesegmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of biblesegments to fetch.
     */
    orderBy?: Enumerable<biblesegmentsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for biblesegments.
     */
    cursor?: biblesegmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` biblesegments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` biblesegments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of biblesegments.
     */
    distinct?: Enumerable<BiblesegmentsScalarFieldEnum>
  }

  /**
   * biblesegments findFirst
   */
  export interface biblesegmentsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends biblesegmentsFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * biblesegments findFirstOrThrow
   */
  export type biblesegmentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the biblesegments
     */
    select?: biblesegmentsSelect<ExtArgs> | null
    /**
     * Filter, which biblesegments to fetch.
     */
    where?: biblesegmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of biblesegments to fetch.
     */
    orderBy?: Enumerable<biblesegmentsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for biblesegments.
     */
    cursor?: biblesegmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` biblesegments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` biblesegments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of biblesegments.
     */
    distinct?: Enumerable<BiblesegmentsScalarFieldEnum>
  }


  /**
   * biblesegments findMany
   */
  export type biblesegmentsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the biblesegments
     */
    select?: biblesegmentsSelect<ExtArgs> | null
    /**
     * Filter, which biblesegments to fetch.
     */
    where?: biblesegmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of biblesegments to fetch.
     */
    orderBy?: Enumerable<biblesegmentsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing biblesegments.
     */
    cursor?: biblesegmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` biblesegments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` biblesegments.
     */
    skip?: number
    distinct?: Enumerable<BiblesegmentsScalarFieldEnum>
  }


  /**
   * biblesegments create
   */
  export type biblesegmentsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the biblesegments
     */
    select?: biblesegmentsSelect<ExtArgs> | null
    /**
     * The data needed to create a biblesegments.
     */
    data?: XOR<biblesegmentsCreateInput, biblesegmentsUncheckedCreateInput>
  }


  /**
   * biblesegments createMany
   */
  export type biblesegmentsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many biblesegments.
     */
    data: Enumerable<biblesegmentsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * biblesegments update
   */
  export type biblesegmentsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the biblesegments
     */
    select?: biblesegmentsSelect<ExtArgs> | null
    /**
     * The data needed to update a biblesegments.
     */
    data: XOR<biblesegmentsUpdateInput, biblesegmentsUncheckedUpdateInput>
    /**
     * Choose, which biblesegments to update.
     */
    where: biblesegmentsWhereUniqueInput
  }


  /**
   * biblesegments updateMany
   */
  export type biblesegmentsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update biblesegments.
     */
    data: XOR<biblesegmentsUpdateManyMutationInput, biblesegmentsUncheckedUpdateManyInput>
    /**
     * Filter which biblesegments to update
     */
    where?: biblesegmentsWhereInput
  }


  /**
   * biblesegments upsert
   */
  export type biblesegmentsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the biblesegments
     */
    select?: biblesegmentsSelect<ExtArgs> | null
    /**
     * The filter to search for the biblesegments to update in case it exists.
     */
    where: biblesegmentsWhereUniqueInput
    /**
     * In case the biblesegments found by the `where` argument doesn't exist, create a new biblesegments with this data.
     */
    create: XOR<biblesegmentsCreateInput, biblesegmentsUncheckedCreateInput>
    /**
     * In case the biblesegments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<biblesegmentsUpdateInput, biblesegmentsUncheckedUpdateInput>
  }


  /**
   * biblesegments delete
   */
  export type biblesegmentsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the biblesegments
     */
    select?: biblesegmentsSelect<ExtArgs> | null
    /**
     * Filter which biblesegments to delete.
     */
    where: biblesegmentsWhereUniqueInput
  }


  /**
   * biblesegments deleteMany
   */
  export type biblesegmentsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which biblesegments to delete
     */
    where?: biblesegmentsWhereInput
  }


  /**
   * biblesegments without action
   */
  export type biblesegmentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the biblesegments
     */
    select?: biblesegmentsSelect<ExtArgs> | null
  }



  /**
   * Model collected_offerings
   */


  export type AggregateCollected_offerings = {
    _count: Collected_offeringsCountAggregateOutputType | null
    _avg: Collected_offeringsAvgAggregateOutputType | null
    _sum: Collected_offeringsSumAggregateOutputType | null
    _min: Collected_offeringsMinAggregateOutputType | null
    _max: Collected_offeringsMaxAggregateOutputType | null
  }

  export type Collected_offeringsAvgAggregateOutputType = {
    id: number | null
    target_id: number | null
    service_id: number | null
    amount: Decimal | null
  }

  export type Collected_offeringsSumAggregateOutputType = {
    id: number | null
    target_id: number | null
    service_id: number | null
    amount: Decimal | null
  }

  export type Collected_offeringsMinAggregateOutputType = {
    id: number | null
    target_id: number | null
    service_id: number | null
    amount: Decimal | null
  }

  export type Collected_offeringsMaxAggregateOutputType = {
    id: number | null
    target_id: number | null
    service_id: number | null
    amount: Decimal | null
  }

  export type Collected_offeringsCountAggregateOutputType = {
    id: number
    target_id: number
    service_id: number
    amount: number
    _all: number
  }


  export type Collected_offeringsAvgAggregateInputType = {
    id?: true
    target_id?: true
    service_id?: true
    amount?: true
  }

  export type Collected_offeringsSumAggregateInputType = {
    id?: true
    target_id?: true
    service_id?: true
    amount?: true
  }

  export type Collected_offeringsMinAggregateInputType = {
    id?: true
    target_id?: true
    service_id?: true
    amount?: true
  }

  export type Collected_offeringsMaxAggregateInputType = {
    id?: true
    target_id?: true
    service_id?: true
    amount?: true
  }

  export type Collected_offeringsCountAggregateInputType = {
    id?: true
    target_id?: true
    service_id?: true
    amount?: true
    _all?: true
  }

  export type Collected_offeringsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which collected_offerings to aggregate.
     */
    where?: collected_offeringsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collected_offerings to fetch.
     */
    orderBy?: Enumerable<collected_offeringsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: collected_offeringsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collected_offerings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collected_offerings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned collected_offerings
    **/
    _count?: true | Collected_offeringsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Collected_offeringsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Collected_offeringsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Collected_offeringsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Collected_offeringsMaxAggregateInputType
  }

  export type GetCollected_offeringsAggregateType<T extends Collected_offeringsAggregateArgs> = {
        [P in keyof T & keyof AggregateCollected_offerings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCollected_offerings[P]>
      : GetScalarType<T[P], AggregateCollected_offerings[P]>
  }




  export type Collected_offeringsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: collected_offeringsWhereInput
    orderBy?: Enumerable<collected_offeringsOrderByWithAggregationInput>
    by: Collected_offeringsScalarFieldEnum[]
    having?: collected_offeringsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Collected_offeringsCountAggregateInputType | true
    _avg?: Collected_offeringsAvgAggregateInputType
    _sum?: Collected_offeringsSumAggregateInputType
    _min?: Collected_offeringsMinAggregateInputType
    _max?: Collected_offeringsMaxAggregateInputType
  }


  export type Collected_offeringsGroupByOutputType = {
    id: number
    target_id: number
    service_id: number
    amount: Decimal | null
    _count: Collected_offeringsCountAggregateOutputType | null
    _avg: Collected_offeringsAvgAggregateOutputType | null
    _sum: Collected_offeringsSumAggregateOutputType | null
    _min: Collected_offeringsMinAggregateOutputType | null
    _max: Collected_offeringsMaxAggregateOutputType | null
  }

  type GetCollected_offeringsGroupByPayload<T extends Collected_offeringsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Collected_offeringsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Collected_offeringsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Collected_offeringsGroupByOutputType[P]>
            : GetScalarType<T[P], Collected_offeringsGroupByOutputType[P]>
        }
      >
    >


  export type collected_offeringsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    target_id?: boolean
    service_id?: boolean
    amount?: boolean
    offering_goals?: boolean | offering_goalsArgs<ExtArgs>
    services?: boolean | servicesArgs<ExtArgs>
  }, ExtArgs["result"]["collected_offerings"]>

  export type collected_offeringsSelectScalar = {
    id?: boolean
    target_id?: boolean
    service_id?: boolean
    amount?: boolean
  }

  export type collected_offeringsInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    offering_goals?: boolean | offering_goalsArgs<ExtArgs>
    services?: boolean | servicesArgs<ExtArgs>
  }


  type collected_offeringsGetPayload<S extends boolean | null | undefined | collected_offeringsArgs> = $Types.GetResult<collected_offeringsPayload, S>

  type collected_offeringsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<collected_offeringsFindManyArgs, 'select' | 'include'> & {
      select?: Collected_offeringsCountAggregateInputType | true
    }

  export interface collected_offeringsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['collected_offerings'], meta: { name: 'collected_offerings' } }
    /**
     * Find zero or one Collected_offerings that matches the filter.
     * @param {collected_offeringsFindUniqueArgs} args - Arguments to find a Collected_offerings
     * @example
     * // Get one Collected_offerings
     * const collected_offerings = await prisma.collected_offerings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends collected_offeringsFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, collected_offeringsFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'collected_offerings'> extends True ? Prisma__collected_offeringsClient<$Types.GetResult<collected_offeringsPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__collected_offeringsClient<$Types.GetResult<collected_offeringsPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Collected_offerings that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {collected_offeringsFindUniqueOrThrowArgs} args - Arguments to find a Collected_offerings
     * @example
     * // Get one Collected_offerings
     * const collected_offerings = await prisma.collected_offerings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends collected_offeringsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, collected_offeringsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__collected_offeringsClient<$Types.GetResult<collected_offeringsPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Collected_offerings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collected_offeringsFindFirstArgs} args - Arguments to find a Collected_offerings
     * @example
     * // Get one Collected_offerings
     * const collected_offerings = await prisma.collected_offerings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends collected_offeringsFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, collected_offeringsFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'collected_offerings'> extends True ? Prisma__collected_offeringsClient<$Types.GetResult<collected_offeringsPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__collected_offeringsClient<$Types.GetResult<collected_offeringsPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Collected_offerings that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collected_offeringsFindFirstOrThrowArgs} args - Arguments to find a Collected_offerings
     * @example
     * // Get one Collected_offerings
     * const collected_offerings = await prisma.collected_offerings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends collected_offeringsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, collected_offeringsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__collected_offeringsClient<$Types.GetResult<collected_offeringsPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Collected_offerings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collected_offeringsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Collected_offerings
     * const collected_offerings = await prisma.collected_offerings.findMany()
     * 
     * // Get first 10 Collected_offerings
     * const collected_offerings = await prisma.collected_offerings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const collected_offeringsWithIdOnly = await prisma.collected_offerings.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends collected_offeringsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, collected_offeringsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<collected_offeringsPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Collected_offerings.
     * @param {collected_offeringsCreateArgs} args - Arguments to create a Collected_offerings.
     * @example
     * // Create one Collected_offerings
     * const Collected_offerings = await prisma.collected_offerings.create({
     *   data: {
     *     // ... data to create a Collected_offerings
     *   }
     * })
     * 
    **/
    create<T extends collected_offeringsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, collected_offeringsCreateArgs<ExtArgs>>
    ): Prisma__collected_offeringsClient<$Types.GetResult<collected_offeringsPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Collected_offerings.
     *     @param {collected_offeringsCreateManyArgs} args - Arguments to create many Collected_offerings.
     *     @example
     *     // Create many Collected_offerings
     *     const collected_offerings = await prisma.collected_offerings.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends collected_offeringsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, collected_offeringsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Collected_offerings.
     * @param {collected_offeringsDeleteArgs} args - Arguments to delete one Collected_offerings.
     * @example
     * // Delete one Collected_offerings
     * const Collected_offerings = await prisma.collected_offerings.delete({
     *   where: {
     *     // ... filter to delete one Collected_offerings
     *   }
     * })
     * 
    **/
    delete<T extends collected_offeringsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, collected_offeringsDeleteArgs<ExtArgs>>
    ): Prisma__collected_offeringsClient<$Types.GetResult<collected_offeringsPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Collected_offerings.
     * @param {collected_offeringsUpdateArgs} args - Arguments to update one Collected_offerings.
     * @example
     * // Update one Collected_offerings
     * const collected_offerings = await prisma.collected_offerings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends collected_offeringsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, collected_offeringsUpdateArgs<ExtArgs>>
    ): Prisma__collected_offeringsClient<$Types.GetResult<collected_offeringsPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Collected_offerings.
     * @param {collected_offeringsDeleteManyArgs} args - Arguments to filter Collected_offerings to delete.
     * @example
     * // Delete a few Collected_offerings
     * const { count } = await prisma.collected_offerings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends collected_offeringsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, collected_offeringsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Collected_offerings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collected_offeringsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Collected_offerings
     * const collected_offerings = await prisma.collected_offerings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends collected_offeringsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, collected_offeringsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Collected_offerings.
     * @param {collected_offeringsUpsertArgs} args - Arguments to update or create a Collected_offerings.
     * @example
     * // Update or create a Collected_offerings
     * const collected_offerings = await prisma.collected_offerings.upsert({
     *   create: {
     *     // ... data to create a Collected_offerings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Collected_offerings we want to update
     *   }
     * })
    **/
    upsert<T extends collected_offeringsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, collected_offeringsUpsertArgs<ExtArgs>>
    ): Prisma__collected_offeringsClient<$Types.GetResult<collected_offeringsPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Collected_offerings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collected_offeringsCountArgs} args - Arguments to filter Collected_offerings to count.
     * @example
     * // Count the number of Collected_offerings
     * const count = await prisma.collected_offerings.count({
     *   where: {
     *     // ... the filter for the Collected_offerings we want to count
     *   }
     * })
    **/
    count<T extends collected_offeringsCountArgs>(
      args?: Subset<T, collected_offeringsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Collected_offeringsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Collected_offerings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Collected_offeringsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Collected_offeringsAggregateArgs>(args: Subset<T, Collected_offeringsAggregateArgs>): Prisma.PrismaPromise<GetCollected_offeringsAggregateType<T>>

    /**
     * Group by Collected_offerings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Collected_offeringsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Collected_offeringsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Collected_offeringsGroupByArgs['orderBy'] }
        : { orderBy?: Collected_offeringsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Collected_offeringsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCollected_offeringsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for collected_offerings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__collected_offeringsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    offering_goals<T extends offering_goalsArgs<ExtArgs> = {}>(args?: Subset<T, offering_goalsArgs<ExtArgs>>): Prisma__offering_goalsClient<$Types.GetResult<offering_goalsPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    services<T extends servicesArgs<ExtArgs> = {}>(args?: Subset<T, servicesArgs<ExtArgs>>): Prisma__servicesClient<$Types.GetResult<servicesPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * collected_offerings base type for findUnique actions
   */
  export type collected_offeringsFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collected_offerings
     */
    select?: collected_offeringsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: collected_offeringsInclude<ExtArgs> | null
    /**
     * Filter, which collected_offerings to fetch.
     */
    where: collected_offeringsWhereUniqueInput
  }

  /**
   * collected_offerings findUnique
   */
  export interface collected_offeringsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends collected_offeringsFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * collected_offerings findUniqueOrThrow
   */
  export type collected_offeringsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collected_offerings
     */
    select?: collected_offeringsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: collected_offeringsInclude<ExtArgs> | null
    /**
     * Filter, which collected_offerings to fetch.
     */
    where: collected_offeringsWhereUniqueInput
  }


  /**
   * collected_offerings base type for findFirst actions
   */
  export type collected_offeringsFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collected_offerings
     */
    select?: collected_offeringsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: collected_offeringsInclude<ExtArgs> | null
    /**
     * Filter, which collected_offerings to fetch.
     */
    where?: collected_offeringsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collected_offerings to fetch.
     */
    orderBy?: Enumerable<collected_offeringsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for collected_offerings.
     */
    cursor?: collected_offeringsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collected_offerings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collected_offerings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of collected_offerings.
     */
    distinct?: Enumerable<Collected_offeringsScalarFieldEnum>
  }

  /**
   * collected_offerings findFirst
   */
  export interface collected_offeringsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends collected_offeringsFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * collected_offerings findFirstOrThrow
   */
  export type collected_offeringsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collected_offerings
     */
    select?: collected_offeringsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: collected_offeringsInclude<ExtArgs> | null
    /**
     * Filter, which collected_offerings to fetch.
     */
    where?: collected_offeringsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collected_offerings to fetch.
     */
    orderBy?: Enumerable<collected_offeringsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for collected_offerings.
     */
    cursor?: collected_offeringsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collected_offerings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collected_offerings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of collected_offerings.
     */
    distinct?: Enumerable<Collected_offeringsScalarFieldEnum>
  }


  /**
   * collected_offerings findMany
   */
  export type collected_offeringsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collected_offerings
     */
    select?: collected_offeringsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: collected_offeringsInclude<ExtArgs> | null
    /**
     * Filter, which collected_offerings to fetch.
     */
    where?: collected_offeringsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collected_offerings to fetch.
     */
    orderBy?: Enumerable<collected_offeringsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing collected_offerings.
     */
    cursor?: collected_offeringsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collected_offerings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collected_offerings.
     */
    skip?: number
    distinct?: Enumerable<Collected_offeringsScalarFieldEnum>
  }


  /**
   * collected_offerings create
   */
  export type collected_offeringsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collected_offerings
     */
    select?: collected_offeringsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: collected_offeringsInclude<ExtArgs> | null
    /**
     * The data needed to create a collected_offerings.
     */
    data: XOR<collected_offeringsCreateInput, collected_offeringsUncheckedCreateInput>
  }


  /**
   * collected_offerings createMany
   */
  export type collected_offeringsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many collected_offerings.
     */
    data: Enumerable<collected_offeringsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * collected_offerings update
   */
  export type collected_offeringsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collected_offerings
     */
    select?: collected_offeringsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: collected_offeringsInclude<ExtArgs> | null
    /**
     * The data needed to update a collected_offerings.
     */
    data: XOR<collected_offeringsUpdateInput, collected_offeringsUncheckedUpdateInput>
    /**
     * Choose, which collected_offerings to update.
     */
    where: collected_offeringsWhereUniqueInput
  }


  /**
   * collected_offerings updateMany
   */
  export type collected_offeringsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update collected_offerings.
     */
    data: XOR<collected_offeringsUpdateManyMutationInput, collected_offeringsUncheckedUpdateManyInput>
    /**
     * Filter which collected_offerings to update
     */
    where?: collected_offeringsWhereInput
  }


  /**
   * collected_offerings upsert
   */
  export type collected_offeringsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collected_offerings
     */
    select?: collected_offeringsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: collected_offeringsInclude<ExtArgs> | null
    /**
     * The filter to search for the collected_offerings to update in case it exists.
     */
    where: collected_offeringsWhereUniqueInput
    /**
     * In case the collected_offerings found by the `where` argument doesn't exist, create a new collected_offerings with this data.
     */
    create: XOR<collected_offeringsCreateInput, collected_offeringsUncheckedCreateInput>
    /**
     * In case the collected_offerings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<collected_offeringsUpdateInput, collected_offeringsUncheckedUpdateInput>
  }


  /**
   * collected_offerings delete
   */
  export type collected_offeringsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collected_offerings
     */
    select?: collected_offeringsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: collected_offeringsInclude<ExtArgs> | null
    /**
     * Filter which collected_offerings to delete.
     */
    where: collected_offeringsWhereUniqueInput
  }


  /**
   * collected_offerings deleteMany
   */
  export type collected_offeringsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which collected_offerings to delete
     */
    where?: collected_offeringsWhereInput
  }


  /**
   * collected_offerings without action
   */
  export type collected_offeringsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collected_offerings
     */
    select?: collected_offeringsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: collected_offeringsInclude<ExtArgs> | null
  }



  /**
   * Model comments
   */


  export type AggregateComments = {
    _count: CommentsCountAggregateOutputType | null
    _avg: CommentsAvgAggregateOutputType | null
    _sum: CommentsSumAggregateOutputType | null
    _min: CommentsMinAggregateOutputType | null
    _max: CommentsMaxAggregateOutputType | null
  }

  export type CommentsAvgAggregateOutputType = {
    id: number | null
    service_id: number | null
    reply_to: number | null
  }

  export type CommentsSumAggregateOutputType = {
    id: number | null
    service_id: number | null
    reply_to: number | null
  }

  export type CommentsMinAggregateOutputType = {
    id: number | null
    service_id: number | null
    reply_to: number | null
    content: string | null
    commentator: string | null
    theme: string | null
    comment_time: Date | null
  }

  export type CommentsMaxAggregateOutputType = {
    id: number | null
    service_id: number | null
    reply_to: number | null
    content: string | null
    commentator: string | null
    theme: string | null
    comment_time: Date | null
  }

  export type CommentsCountAggregateOutputType = {
    id: number
    service_id: number
    reply_to: number
    content: number
    commentator: number
    theme: number
    comment_time: number
    _all: number
  }


  export type CommentsAvgAggregateInputType = {
    id?: true
    service_id?: true
    reply_to?: true
  }

  export type CommentsSumAggregateInputType = {
    id?: true
    service_id?: true
    reply_to?: true
  }

  export type CommentsMinAggregateInputType = {
    id?: true
    service_id?: true
    reply_to?: true
    content?: true
    commentator?: true
    theme?: true
    comment_time?: true
  }

  export type CommentsMaxAggregateInputType = {
    id?: true
    service_id?: true
    reply_to?: true
    content?: true
    commentator?: true
    theme?: true
    comment_time?: true
  }

  export type CommentsCountAggregateInputType = {
    id?: true
    service_id?: true
    reply_to?: true
    content?: true
    commentator?: true
    theme?: true
    comment_time?: true
    _all?: true
  }

  export type CommentsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which comments to aggregate.
     */
    where?: commentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comments to fetch.
     */
    orderBy?: Enumerable<commentsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: commentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned comments
    **/
    _count?: true | CommentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentsMaxAggregateInputType
  }

  export type GetCommentsAggregateType<T extends CommentsAggregateArgs> = {
        [P in keyof T & keyof AggregateComments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComments[P]>
      : GetScalarType<T[P], AggregateComments[P]>
  }




  export type CommentsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: commentsWhereInput
    orderBy?: Enumerable<commentsOrderByWithAggregationInput>
    by: CommentsScalarFieldEnum[]
    having?: commentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentsCountAggregateInputType | true
    _avg?: CommentsAvgAggregateInputType
    _sum?: CommentsSumAggregateInputType
    _min?: CommentsMinAggregateInputType
    _max?: CommentsMaxAggregateInputType
  }


  export type CommentsGroupByOutputType = {
    id: number
    service_id: number
    reply_to: number | null
    content: string | null
    commentator: string | null
    theme: string | null
    comment_time: Date | null
    _count: CommentsCountAggregateOutputType | null
    _avg: CommentsAvgAggregateOutputType | null
    _sum: CommentsSumAggregateOutputType | null
    _min: CommentsMinAggregateOutputType | null
    _max: CommentsMaxAggregateOutputType | null
  }

  type GetCommentsGroupByPayload<T extends CommentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CommentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentsGroupByOutputType[P]>
            : GetScalarType<T[P], CommentsGroupByOutputType[P]>
        }
      >
    >


  export type commentsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    service_id?: boolean
    reply_to?: boolean
    content?: boolean
    commentator?: boolean
    theme?: boolean
    comment_time?: boolean
    services?: boolean | servicesArgs<ExtArgs>
  }, ExtArgs["result"]["comments"]>

  export type commentsSelectScalar = {
    id?: boolean
    service_id?: boolean
    reply_to?: boolean
    content?: boolean
    commentator?: boolean
    theme?: boolean
    comment_time?: boolean
  }

  export type commentsInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    services?: boolean | servicesArgs<ExtArgs>
  }


  type commentsGetPayload<S extends boolean | null | undefined | commentsArgs> = $Types.GetResult<commentsPayload, S>

  type commentsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<commentsFindManyArgs, 'select' | 'include'> & {
      select?: CommentsCountAggregateInputType | true
    }

  export interface commentsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['comments'], meta: { name: 'comments' } }
    /**
     * Find zero or one Comments that matches the filter.
     * @param {commentsFindUniqueArgs} args - Arguments to find a Comments
     * @example
     * // Get one Comments
     * const comments = await prisma.comments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends commentsFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, commentsFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'comments'> extends True ? Prisma__commentsClient<$Types.GetResult<commentsPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__commentsClient<$Types.GetResult<commentsPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Comments that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {commentsFindUniqueOrThrowArgs} args - Arguments to find a Comments
     * @example
     * // Get one Comments
     * const comments = await prisma.comments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends commentsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, commentsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__commentsClient<$Types.GetResult<commentsPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commentsFindFirstArgs} args - Arguments to find a Comments
     * @example
     * // Get one Comments
     * const comments = await prisma.comments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends commentsFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, commentsFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'comments'> extends True ? Prisma__commentsClient<$Types.GetResult<commentsPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__commentsClient<$Types.GetResult<commentsPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Comments that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commentsFindFirstOrThrowArgs} args - Arguments to find a Comments
     * @example
     * // Get one Comments
     * const comments = await prisma.comments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends commentsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, commentsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__commentsClient<$Types.GetResult<commentsPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commentsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comments.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentsWithIdOnly = await prisma.comments.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends commentsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, commentsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<commentsPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Comments.
     * @param {commentsCreateArgs} args - Arguments to create a Comments.
     * @example
     * // Create one Comments
     * const Comments = await prisma.comments.create({
     *   data: {
     *     // ... data to create a Comments
     *   }
     * })
     * 
    **/
    create<T extends commentsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, commentsCreateArgs<ExtArgs>>
    ): Prisma__commentsClient<$Types.GetResult<commentsPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Comments.
     *     @param {commentsCreateManyArgs} args - Arguments to create many Comments.
     *     @example
     *     // Create many Comments
     *     const comments = await prisma.comments.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends commentsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, commentsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Comments.
     * @param {commentsDeleteArgs} args - Arguments to delete one Comments.
     * @example
     * // Delete one Comments
     * const Comments = await prisma.comments.delete({
     *   where: {
     *     // ... filter to delete one Comments
     *   }
     * })
     * 
    **/
    delete<T extends commentsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, commentsDeleteArgs<ExtArgs>>
    ): Prisma__commentsClient<$Types.GetResult<commentsPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Comments.
     * @param {commentsUpdateArgs} args - Arguments to update one Comments.
     * @example
     * // Update one Comments
     * const comments = await prisma.comments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends commentsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, commentsUpdateArgs<ExtArgs>>
    ): Prisma__commentsClient<$Types.GetResult<commentsPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Comments.
     * @param {commentsDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends commentsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, commentsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comments = await prisma.comments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends commentsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, commentsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Comments.
     * @param {commentsUpsertArgs} args - Arguments to update or create a Comments.
     * @example
     * // Update or create a Comments
     * const comments = await prisma.comments.upsert({
     *   create: {
     *     // ... data to create a Comments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comments we want to update
     *   }
     * })
    **/
    upsert<T extends commentsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, commentsUpsertArgs<ExtArgs>>
    ): Prisma__commentsClient<$Types.GetResult<commentsPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commentsCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comments.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends commentsCountArgs>(
      args?: Subset<T, commentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentsAggregateArgs>(args: Subset<T, CommentsAggregateArgs>): Prisma.PrismaPromise<GetCommentsAggregateType<T>>

    /**
     * Group by Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentsGroupByArgs['orderBy'] }
        : { orderBy?: CommentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for comments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__commentsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    services<T extends servicesArgs<ExtArgs> = {}>(args?: Subset<T, servicesArgs<ExtArgs>>): Prisma__servicesClient<$Types.GetResult<servicesPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * comments base type for findUnique actions
   */
  export type commentsFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: commentsInclude<ExtArgs> | null
    /**
     * Filter, which comments to fetch.
     */
    where: commentsWhereUniqueInput
  }

  /**
   * comments findUnique
   */
  export interface commentsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends commentsFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * comments findUniqueOrThrow
   */
  export type commentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: commentsInclude<ExtArgs> | null
    /**
     * Filter, which comments to fetch.
     */
    where: commentsWhereUniqueInput
  }


  /**
   * comments base type for findFirst actions
   */
  export type commentsFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: commentsInclude<ExtArgs> | null
    /**
     * Filter, which comments to fetch.
     */
    where?: commentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comments to fetch.
     */
    orderBy?: Enumerable<commentsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for comments.
     */
    cursor?: commentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of comments.
     */
    distinct?: Enumerable<CommentsScalarFieldEnum>
  }

  /**
   * comments findFirst
   */
  export interface commentsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends commentsFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * comments findFirstOrThrow
   */
  export type commentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: commentsInclude<ExtArgs> | null
    /**
     * Filter, which comments to fetch.
     */
    where?: commentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comments to fetch.
     */
    orderBy?: Enumerable<commentsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for comments.
     */
    cursor?: commentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of comments.
     */
    distinct?: Enumerable<CommentsScalarFieldEnum>
  }


  /**
   * comments findMany
   */
  export type commentsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: commentsInclude<ExtArgs> | null
    /**
     * Filter, which comments to fetch.
     */
    where?: commentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comments to fetch.
     */
    orderBy?: Enumerable<commentsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing comments.
     */
    cursor?: commentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comments.
     */
    skip?: number
    distinct?: Enumerable<CommentsScalarFieldEnum>
  }


  /**
   * comments create
   */
  export type commentsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: commentsInclude<ExtArgs> | null
    /**
     * The data needed to create a comments.
     */
    data: XOR<commentsCreateInput, commentsUncheckedCreateInput>
  }


  /**
   * comments createMany
   */
  export type commentsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many comments.
     */
    data: Enumerable<commentsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * comments update
   */
  export type commentsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: commentsInclude<ExtArgs> | null
    /**
     * The data needed to update a comments.
     */
    data: XOR<commentsUpdateInput, commentsUncheckedUpdateInput>
    /**
     * Choose, which comments to update.
     */
    where: commentsWhereUniqueInput
  }


  /**
   * comments updateMany
   */
  export type commentsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update comments.
     */
    data: XOR<commentsUpdateManyMutationInput, commentsUncheckedUpdateManyInput>
    /**
     * Filter which comments to update
     */
    where?: commentsWhereInput
  }


  /**
   * comments upsert
   */
  export type commentsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: commentsInclude<ExtArgs> | null
    /**
     * The filter to search for the comments to update in case it exists.
     */
    where: commentsWhereUniqueInput
    /**
     * In case the comments found by the `where` argument doesn't exist, create a new comments with this data.
     */
    create: XOR<commentsCreateInput, commentsUncheckedCreateInput>
    /**
     * In case the comments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<commentsUpdateInput, commentsUncheckedUpdateInput>
  }


  /**
   * comments delete
   */
  export type commentsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: commentsInclude<ExtArgs> | null
    /**
     * Filter which comments to delete.
     */
    where: commentsWhereUniqueInput
  }


  /**
   * comments deleteMany
   */
  export type commentsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which comments to delete
     */
    where?: commentsWhereInput
  }


  /**
   * comments without action
   */
  export type commentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: commentsInclude<ExtArgs> | null
  }



  /**
   * Model events
   */


  export type AggregateEvents = {
    _count: EventsCountAggregateOutputType | null
    _avg: EventsAvgAggregateOutputType | null
    _sum: EventsSumAggregateOutputType | null
    _min: EventsMinAggregateOutputType | null
    _max: EventsMaxAggregateOutputType | null
  }

  export type EventsAvgAggregateOutputType = {
    id: number | null
  }

  export type EventsSumAggregateOutputType = {
    id: number | null
  }

  export type EventsMinAggregateOutputType = {
    id: number | null
    name: string | null
    place_and_time: string | null
    description: string | null
    event_date: Date | null
    has_songs: boolean | null
  }

  export type EventsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    place_and_time: string | null
    description: string | null
    event_date: Date | null
    has_songs: boolean | null
  }

  export type EventsCountAggregateOutputType = {
    id: number
    name: number
    place_and_time: number
    description: number
    event_date: number
    has_songs: number
    _all: number
  }


  export type EventsAvgAggregateInputType = {
    id?: true
  }

  export type EventsSumAggregateInputType = {
    id?: true
  }

  export type EventsMinAggregateInputType = {
    id?: true
    name?: true
    place_and_time?: true
    description?: true
    event_date?: true
    has_songs?: true
  }

  export type EventsMaxAggregateInputType = {
    id?: true
    name?: true
    place_and_time?: true
    description?: true
    event_date?: true
    has_songs?: true
  }

  export type EventsCountAggregateInputType = {
    id?: true
    name?: true
    place_and_time?: true
    description?: true
    event_date?: true
    has_songs?: true
    _all?: true
  }

  export type EventsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which events to aggregate.
     */
    where?: eventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of events to fetch.
     */
    orderBy?: Enumerable<eventsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: eventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned events
    **/
    _count?: true | EventsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EventsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EventsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventsMaxAggregateInputType
  }

  export type GetEventsAggregateType<T extends EventsAggregateArgs> = {
        [P in keyof T & keyof AggregateEvents]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvents[P]>
      : GetScalarType<T[P], AggregateEvents[P]>
  }




  export type EventsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: eventsWhereInput
    orderBy?: Enumerable<eventsOrderByWithAggregationInput>
    by: EventsScalarFieldEnum[]
    having?: eventsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventsCountAggregateInputType | true
    _avg?: EventsAvgAggregateInputType
    _sum?: EventsSumAggregateInputType
    _min?: EventsMinAggregateInputType
    _max?: EventsMaxAggregateInputType
  }


  export type EventsGroupByOutputType = {
    id: number
    name: string | null
    place_and_time: string | null
    description: string | null
    event_date: Date | null
    has_songs: boolean | null
    _count: EventsCountAggregateOutputType | null
    _avg: EventsAvgAggregateOutputType | null
    _sum: EventsSumAggregateOutputType | null
    _min: EventsMinAggregateOutputType | null
    _max: EventsMaxAggregateOutputType | null
  }

  type GetEventsGroupByPayload<T extends EventsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<EventsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventsGroupByOutputType[P]>
            : GetScalarType<T[P], EventsGroupByOutputType[P]>
        }
      >
    >


  export type eventsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    place_and_time?: boolean
    description?: boolean
    event_date?: boolean
    has_songs?: boolean
  }, ExtArgs["result"]["events"]>

  export type eventsSelectScalar = {
    id?: boolean
    name?: boolean
    place_and_time?: boolean
    description?: boolean
    event_date?: boolean
    has_songs?: boolean
  }


  type eventsGetPayload<S extends boolean | null | undefined | eventsArgs> = $Types.GetResult<eventsPayload, S>

  type eventsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<eventsFindManyArgs, 'select' | 'include'> & {
      select?: EventsCountAggregateInputType | true
    }

  export interface eventsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['events'], meta: { name: 'events' } }
    /**
     * Find zero or one Events that matches the filter.
     * @param {eventsFindUniqueArgs} args - Arguments to find a Events
     * @example
     * // Get one Events
     * const events = await prisma.events.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends eventsFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, eventsFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'events'> extends True ? Prisma__eventsClient<$Types.GetResult<eventsPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__eventsClient<$Types.GetResult<eventsPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Events that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {eventsFindUniqueOrThrowArgs} args - Arguments to find a Events
     * @example
     * // Get one Events
     * const events = await prisma.events.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends eventsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, eventsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__eventsClient<$Types.GetResult<eventsPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventsFindFirstArgs} args - Arguments to find a Events
     * @example
     * // Get one Events
     * const events = await prisma.events.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends eventsFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, eventsFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'events'> extends True ? Prisma__eventsClient<$Types.GetResult<eventsPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__eventsClient<$Types.GetResult<eventsPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Events that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventsFindFirstOrThrowArgs} args - Arguments to find a Events
     * @example
     * // Get one Events
     * const events = await prisma.events.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends eventsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, eventsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__eventsClient<$Types.GetResult<eventsPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Events
     * const events = await prisma.events.findMany()
     * 
     * // Get first 10 Events
     * const events = await prisma.events.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventsWithIdOnly = await prisma.events.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends eventsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, eventsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<eventsPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Events.
     * @param {eventsCreateArgs} args - Arguments to create a Events.
     * @example
     * // Create one Events
     * const Events = await prisma.events.create({
     *   data: {
     *     // ... data to create a Events
     *   }
     * })
     * 
    **/
    create<T extends eventsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, eventsCreateArgs<ExtArgs>>
    ): Prisma__eventsClient<$Types.GetResult<eventsPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Events.
     *     @param {eventsCreateManyArgs} args - Arguments to create many Events.
     *     @example
     *     // Create many Events
     *     const events = await prisma.events.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends eventsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, eventsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Events.
     * @param {eventsDeleteArgs} args - Arguments to delete one Events.
     * @example
     * // Delete one Events
     * const Events = await prisma.events.delete({
     *   where: {
     *     // ... filter to delete one Events
     *   }
     * })
     * 
    **/
    delete<T extends eventsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, eventsDeleteArgs<ExtArgs>>
    ): Prisma__eventsClient<$Types.GetResult<eventsPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Events.
     * @param {eventsUpdateArgs} args - Arguments to update one Events.
     * @example
     * // Update one Events
     * const events = await prisma.events.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends eventsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, eventsUpdateArgs<ExtArgs>>
    ): Prisma__eventsClient<$Types.GetResult<eventsPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Events.
     * @param {eventsDeleteManyArgs} args - Arguments to filter Events to delete.
     * @example
     * // Delete a few Events
     * const { count } = await prisma.events.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends eventsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, eventsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Events
     * const events = await prisma.events.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends eventsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, eventsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Events.
     * @param {eventsUpsertArgs} args - Arguments to update or create a Events.
     * @example
     * // Update or create a Events
     * const events = await prisma.events.upsert({
     *   create: {
     *     // ... data to create a Events
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Events we want to update
     *   }
     * })
    **/
    upsert<T extends eventsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, eventsUpsertArgs<ExtArgs>>
    ): Prisma__eventsClient<$Types.GetResult<eventsPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventsCountArgs} args - Arguments to filter Events to count.
     * @example
     * // Count the number of Events
     * const count = await prisma.events.count({
     *   where: {
     *     // ... the filter for the Events we want to count
     *   }
     * })
    **/
    count<T extends eventsCountArgs>(
      args?: Subset<T, eventsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventsAggregateArgs>(args: Subset<T, EventsAggregateArgs>): Prisma.PrismaPromise<GetEventsAggregateType<T>>

    /**
     * Group by Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventsGroupByArgs['orderBy'] }
        : { orderBy?: EventsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for events.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__eventsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * events base type for findUnique actions
   */
  export type eventsFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the events
     */
    select?: eventsSelect<ExtArgs> | null
    /**
     * Filter, which events to fetch.
     */
    where: eventsWhereUniqueInput
  }

  /**
   * events findUnique
   */
  export interface eventsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends eventsFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * events findUniqueOrThrow
   */
  export type eventsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the events
     */
    select?: eventsSelect<ExtArgs> | null
    /**
     * Filter, which events to fetch.
     */
    where: eventsWhereUniqueInput
  }


  /**
   * events base type for findFirst actions
   */
  export type eventsFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the events
     */
    select?: eventsSelect<ExtArgs> | null
    /**
     * Filter, which events to fetch.
     */
    where?: eventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of events to fetch.
     */
    orderBy?: Enumerable<eventsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for events.
     */
    cursor?: eventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of events.
     */
    distinct?: Enumerable<EventsScalarFieldEnum>
  }

  /**
   * events findFirst
   */
  export interface eventsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends eventsFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * events findFirstOrThrow
   */
  export type eventsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the events
     */
    select?: eventsSelect<ExtArgs> | null
    /**
     * Filter, which events to fetch.
     */
    where?: eventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of events to fetch.
     */
    orderBy?: Enumerable<eventsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for events.
     */
    cursor?: eventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of events.
     */
    distinct?: Enumerable<EventsScalarFieldEnum>
  }


  /**
   * events findMany
   */
  export type eventsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the events
     */
    select?: eventsSelect<ExtArgs> | null
    /**
     * Filter, which events to fetch.
     */
    where?: eventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of events to fetch.
     */
    orderBy?: Enumerable<eventsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing events.
     */
    cursor?: eventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` events.
     */
    skip?: number
    distinct?: Enumerable<EventsScalarFieldEnum>
  }


  /**
   * events create
   */
  export type eventsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the events
     */
    select?: eventsSelect<ExtArgs> | null
    /**
     * The data needed to create a events.
     */
    data?: XOR<eventsCreateInput, eventsUncheckedCreateInput>
  }


  /**
   * events createMany
   */
  export type eventsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many events.
     */
    data: Enumerable<eventsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * events update
   */
  export type eventsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the events
     */
    select?: eventsSelect<ExtArgs> | null
    /**
     * The data needed to update a events.
     */
    data: XOR<eventsUpdateInput, eventsUncheckedUpdateInput>
    /**
     * Choose, which events to update.
     */
    where: eventsWhereUniqueInput
  }


  /**
   * events updateMany
   */
  export type eventsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update events.
     */
    data: XOR<eventsUpdateManyMutationInput, eventsUncheckedUpdateManyInput>
    /**
     * Filter which events to update
     */
    where?: eventsWhereInput
  }


  /**
   * events upsert
   */
  export type eventsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the events
     */
    select?: eventsSelect<ExtArgs> | null
    /**
     * The filter to search for the events to update in case it exists.
     */
    where: eventsWhereUniqueInput
    /**
     * In case the events found by the `where` argument doesn't exist, create a new events with this data.
     */
    create: XOR<eventsCreateInput, eventsUncheckedCreateInput>
    /**
     * In case the events was found with the provided `where` argument, update it with this data.
     */
    update: XOR<eventsUpdateInput, eventsUncheckedUpdateInput>
  }


  /**
   * events delete
   */
  export type eventsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the events
     */
    select?: eventsSelect<ExtArgs> | null
    /**
     * Filter which events to delete.
     */
    where: eventsWhereUniqueInput
  }


  /**
   * events deleteMany
   */
  export type eventsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which events to delete
     */
    where?: eventsWhereInput
  }


  /**
   * events without action
   */
  export type eventsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the events
     */
    select?: eventsSelect<ExtArgs> | null
  }



  /**
   * Model headers
   */


  export type AggregateHeaders = {
    _count: HeadersCountAggregateOutputType | null
    _avg: HeadersAvgAggregateOutputType | null
    _sum: HeadersSumAggregateOutputType | null
    _min: HeadersMinAggregateOutputType | null
    _max: HeadersMaxAggregateOutputType | null
  }

  export type HeadersAvgAggregateOutputType = {
    id: number | null
  }

  export type HeadersSumAggregateOutputType = {
    id: number | null
  }

  export type HeadersMinAggregateOutputType = {
    id: number | null
    template_name: string | null
    maintext: string | null
    imgname: string | null
    imgposition: string | null
    is_aside: boolean | null
  }

  export type HeadersMaxAggregateOutputType = {
    id: number | null
    template_name: string | null
    maintext: string | null
    imgname: string | null
    imgposition: string | null
    is_aside: boolean | null
  }

  export type HeadersCountAggregateOutputType = {
    id: number
    template_name: number
    maintext: number
    imgname: number
    imgposition: number
    is_aside: number
    _all: number
  }


  export type HeadersAvgAggregateInputType = {
    id?: true
  }

  export type HeadersSumAggregateInputType = {
    id?: true
  }

  export type HeadersMinAggregateInputType = {
    id?: true
    template_name?: true
    maintext?: true
    imgname?: true
    imgposition?: true
    is_aside?: true
  }

  export type HeadersMaxAggregateInputType = {
    id?: true
    template_name?: true
    maintext?: true
    imgname?: true
    imgposition?: true
    is_aside?: true
  }

  export type HeadersCountAggregateInputType = {
    id?: true
    template_name?: true
    maintext?: true
    imgname?: true
    imgposition?: true
    is_aside?: true
    _all?: true
  }

  export type HeadersAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which headers to aggregate.
     */
    where?: headersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of headers to fetch.
     */
    orderBy?: Enumerable<headersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: headersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` headers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` headers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned headers
    **/
    _count?: true | HeadersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HeadersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HeadersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HeadersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HeadersMaxAggregateInputType
  }

  export type GetHeadersAggregateType<T extends HeadersAggregateArgs> = {
        [P in keyof T & keyof AggregateHeaders]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHeaders[P]>
      : GetScalarType<T[P], AggregateHeaders[P]>
  }




  export type HeadersGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: headersWhereInput
    orderBy?: Enumerable<headersOrderByWithAggregationInput>
    by: HeadersScalarFieldEnum[]
    having?: headersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HeadersCountAggregateInputType | true
    _avg?: HeadersAvgAggregateInputType
    _sum?: HeadersSumAggregateInputType
    _min?: HeadersMinAggregateInputType
    _max?: HeadersMaxAggregateInputType
  }


  export type HeadersGroupByOutputType = {
    id: number
    template_name: string | null
    maintext: string | null
    imgname: string | null
    imgposition: string | null
    is_aside: boolean | null
    _count: HeadersCountAggregateOutputType | null
    _avg: HeadersAvgAggregateOutputType | null
    _sum: HeadersSumAggregateOutputType | null
    _min: HeadersMinAggregateOutputType | null
    _max: HeadersMaxAggregateOutputType | null
  }

  type GetHeadersGroupByPayload<T extends HeadersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<HeadersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HeadersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HeadersGroupByOutputType[P]>
            : GetScalarType<T[P], HeadersGroupByOutputType[P]>
        }
      >
    >


  export type headersSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    template_name?: boolean
    maintext?: boolean
    imgname?: boolean
    imgposition?: boolean
    is_aside?: boolean
  }, ExtArgs["result"]["headers"]>

  export type headersSelectScalar = {
    id?: boolean
    template_name?: boolean
    maintext?: boolean
    imgname?: boolean
    imgposition?: boolean
    is_aside?: boolean
  }


  type headersGetPayload<S extends boolean | null | undefined | headersArgs> = $Types.GetResult<headersPayload, S>

  type headersCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<headersFindManyArgs, 'select' | 'include'> & {
      select?: HeadersCountAggregateInputType | true
    }

  export interface headersDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['headers'], meta: { name: 'headers' } }
    /**
     * Find zero or one Headers that matches the filter.
     * @param {headersFindUniqueArgs} args - Arguments to find a Headers
     * @example
     * // Get one Headers
     * const headers = await prisma.headers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends headersFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, headersFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'headers'> extends True ? Prisma__headersClient<$Types.GetResult<headersPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__headersClient<$Types.GetResult<headersPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Headers that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {headersFindUniqueOrThrowArgs} args - Arguments to find a Headers
     * @example
     * // Get one Headers
     * const headers = await prisma.headers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends headersFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, headersFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__headersClient<$Types.GetResult<headersPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Headers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {headersFindFirstArgs} args - Arguments to find a Headers
     * @example
     * // Get one Headers
     * const headers = await prisma.headers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends headersFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, headersFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'headers'> extends True ? Prisma__headersClient<$Types.GetResult<headersPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__headersClient<$Types.GetResult<headersPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Headers that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {headersFindFirstOrThrowArgs} args - Arguments to find a Headers
     * @example
     * // Get one Headers
     * const headers = await prisma.headers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends headersFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, headersFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__headersClient<$Types.GetResult<headersPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Headers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {headersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Headers
     * const headers = await prisma.headers.findMany()
     * 
     * // Get first 10 Headers
     * const headers = await prisma.headers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const headersWithIdOnly = await prisma.headers.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends headersFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, headersFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<headersPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Headers.
     * @param {headersCreateArgs} args - Arguments to create a Headers.
     * @example
     * // Create one Headers
     * const Headers = await prisma.headers.create({
     *   data: {
     *     // ... data to create a Headers
     *   }
     * })
     * 
    **/
    create<T extends headersCreateArgs<ExtArgs>>(
      args: SelectSubset<T, headersCreateArgs<ExtArgs>>
    ): Prisma__headersClient<$Types.GetResult<headersPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Headers.
     *     @param {headersCreateManyArgs} args - Arguments to create many Headers.
     *     @example
     *     // Create many Headers
     *     const headers = await prisma.headers.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends headersCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, headersCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Headers.
     * @param {headersDeleteArgs} args - Arguments to delete one Headers.
     * @example
     * // Delete one Headers
     * const Headers = await prisma.headers.delete({
     *   where: {
     *     // ... filter to delete one Headers
     *   }
     * })
     * 
    **/
    delete<T extends headersDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, headersDeleteArgs<ExtArgs>>
    ): Prisma__headersClient<$Types.GetResult<headersPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Headers.
     * @param {headersUpdateArgs} args - Arguments to update one Headers.
     * @example
     * // Update one Headers
     * const headers = await prisma.headers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends headersUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, headersUpdateArgs<ExtArgs>>
    ): Prisma__headersClient<$Types.GetResult<headersPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Headers.
     * @param {headersDeleteManyArgs} args - Arguments to filter Headers to delete.
     * @example
     * // Delete a few Headers
     * const { count } = await prisma.headers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends headersDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, headersDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Headers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {headersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Headers
     * const headers = await prisma.headers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends headersUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, headersUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Headers.
     * @param {headersUpsertArgs} args - Arguments to update or create a Headers.
     * @example
     * // Update or create a Headers
     * const headers = await prisma.headers.upsert({
     *   create: {
     *     // ... data to create a Headers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Headers we want to update
     *   }
     * })
    **/
    upsert<T extends headersUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, headersUpsertArgs<ExtArgs>>
    ): Prisma__headersClient<$Types.GetResult<headersPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Headers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {headersCountArgs} args - Arguments to filter Headers to count.
     * @example
     * // Count the number of Headers
     * const count = await prisma.headers.count({
     *   where: {
     *     // ... the filter for the Headers we want to count
     *   }
     * })
    **/
    count<T extends headersCountArgs>(
      args?: Subset<T, headersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HeadersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Headers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeadersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HeadersAggregateArgs>(args: Subset<T, HeadersAggregateArgs>): Prisma.PrismaPromise<GetHeadersAggregateType<T>>

    /**
     * Group by Headers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeadersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HeadersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HeadersGroupByArgs['orderBy'] }
        : { orderBy?: HeadersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HeadersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHeadersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for headers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__headersClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * headers base type for findUnique actions
   */
  export type headersFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the headers
     */
    select?: headersSelect<ExtArgs> | null
    /**
     * Filter, which headers to fetch.
     */
    where: headersWhereUniqueInput
  }

  /**
   * headers findUnique
   */
  export interface headersFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends headersFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * headers findUniqueOrThrow
   */
  export type headersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the headers
     */
    select?: headersSelect<ExtArgs> | null
    /**
     * Filter, which headers to fetch.
     */
    where: headersWhereUniqueInput
  }


  /**
   * headers base type for findFirst actions
   */
  export type headersFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the headers
     */
    select?: headersSelect<ExtArgs> | null
    /**
     * Filter, which headers to fetch.
     */
    where?: headersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of headers to fetch.
     */
    orderBy?: Enumerable<headersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for headers.
     */
    cursor?: headersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` headers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` headers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of headers.
     */
    distinct?: Enumerable<HeadersScalarFieldEnum>
  }

  /**
   * headers findFirst
   */
  export interface headersFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends headersFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * headers findFirstOrThrow
   */
  export type headersFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the headers
     */
    select?: headersSelect<ExtArgs> | null
    /**
     * Filter, which headers to fetch.
     */
    where?: headersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of headers to fetch.
     */
    orderBy?: Enumerable<headersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for headers.
     */
    cursor?: headersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` headers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` headers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of headers.
     */
    distinct?: Enumerable<HeadersScalarFieldEnum>
  }


  /**
   * headers findMany
   */
  export type headersFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the headers
     */
    select?: headersSelect<ExtArgs> | null
    /**
     * Filter, which headers to fetch.
     */
    where?: headersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of headers to fetch.
     */
    orderBy?: Enumerable<headersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing headers.
     */
    cursor?: headersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` headers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` headers.
     */
    skip?: number
    distinct?: Enumerable<HeadersScalarFieldEnum>
  }


  /**
   * headers create
   */
  export type headersCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the headers
     */
    select?: headersSelect<ExtArgs> | null
    /**
     * The data needed to create a headers.
     */
    data?: XOR<headersCreateInput, headersUncheckedCreateInput>
  }


  /**
   * headers createMany
   */
  export type headersCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many headers.
     */
    data: Enumerable<headersCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * headers update
   */
  export type headersUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the headers
     */
    select?: headersSelect<ExtArgs> | null
    /**
     * The data needed to update a headers.
     */
    data: XOR<headersUpdateInput, headersUncheckedUpdateInput>
    /**
     * Choose, which headers to update.
     */
    where: headersWhereUniqueInput
  }


  /**
   * headers updateMany
   */
  export type headersUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update headers.
     */
    data: XOR<headersUpdateManyMutationInput, headersUncheckedUpdateManyInput>
    /**
     * Filter which headers to update
     */
    where?: headersWhereInput
  }


  /**
   * headers upsert
   */
  export type headersUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the headers
     */
    select?: headersSelect<ExtArgs> | null
    /**
     * The filter to search for the headers to update in case it exists.
     */
    where: headersWhereUniqueInput
    /**
     * In case the headers found by the `where` argument doesn't exist, create a new headers with this data.
     */
    create: XOR<headersCreateInput, headersUncheckedCreateInput>
    /**
     * In case the headers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<headersUpdateInput, headersUncheckedUpdateInput>
  }


  /**
   * headers delete
   */
  export type headersDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the headers
     */
    select?: headersSelect<ExtArgs> | null
    /**
     * Filter which headers to delete.
     */
    where: headersWhereUniqueInput
  }


  /**
   * headers deleteMany
   */
  export type headersDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which headers to delete
     */
    where?: headersWhereInput
  }


  /**
   * headers without action
   */
  export type headersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the headers
     */
    select?: headersSelect<ExtArgs> | null
  }



  /**
   * Model infos
   */


  export type AggregateInfos = {
    _count: InfosCountAggregateOutputType | null
    _avg: InfosAvgAggregateOutputType | null
    _sum: InfosSumAggregateOutputType | null
    _min: InfosMinAggregateOutputType | null
    _max: InfosMaxAggregateOutputType | null
  }

  export type InfosAvgAggregateOutputType = {
    id: number | null
    service_id: number | null
    content_id: number | null
    header_id: number | null
  }

  export type InfosSumAggregateOutputType = {
    id: number | null
    service_id: number | null
    content_id: number | null
    header_id: number | null
  }

  export type InfosMinAggregateOutputType = {
    id: number | null
    service_id: number | null
    slot_name: string | null
    content_id: number | null
    addedclass: string | null
    header_id: number | null
  }

  export type InfosMaxAggregateOutputType = {
    id: number | null
    service_id: number | null
    slot_name: string | null
    content_id: number | null
    addedclass: string | null
    header_id: number | null
  }

  export type InfosCountAggregateOutputType = {
    id: number
    service_id: number
    slot_name: number
    content_id: number
    addedclass: number
    header_id: number
    _all: number
  }


  export type InfosAvgAggregateInputType = {
    id?: true
    service_id?: true
    content_id?: true
    header_id?: true
  }

  export type InfosSumAggregateInputType = {
    id?: true
    service_id?: true
    content_id?: true
    header_id?: true
  }

  export type InfosMinAggregateInputType = {
    id?: true
    service_id?: true
    slot_name?: true
    content_id?: true
    addedclass?: true
    header_id?: true
  }

  export type InfosMaxAggregateInputType = {
    id?: true
    service_id?: true
    slot_name?: true
    content_id?: true
    addedclass?: true
    header_id?: true
  }

  export type InfosCountAggregateInputType = {
    id?: true
    service_id?: true
    slot_name?: true
    content_id?: true
    addedclass?: true
    header_id?: true
    _all?: true
  }

  export type InfosAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which infos to aggregate.
     */
    where?: infosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of infos to fetch.
     */
    orderBy?: Enumerable<infosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: infosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` infos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` infos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned infos
    **/
    _count?: true | InfosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InfosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InfosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InfosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InfosMaxAggregateInputType
  }

  export type GetInfosAggregateType<T extends InfosAggregateArgs> = {
        [P in keyof T & keyof AggregateInfos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInfos[P]>
      : GetScalarType<T[P], AggregateInfos[P]>
  }




  export type InfosGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: infosWhereInput
    orderBy?: Enumerable<infosOrderByWithAggregationInput>
    by: InfosScalarFieldEnum[]
    having?: infosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InfosCountAggregateInputType | true
    _avg?: InfosAvgAggregateInputType
    _sum?: InfosSumAggregateInputType
    _min?: InfosMinAggregateInputType
    _max?: InfosMaxAggregateInputType
  }


  export type InfosGroupByOutputType = {
    id: number
    service_id: number
    slot_name: string | null
    content_id: number
    addedclass: string | null
    header_id: number | null
    _count: InfosCountAggregateOutputType | null
    _avg: InfosAvgAggregateOutputType | null
    _sum: InfosSumAggregateOutputType | null
    _min: InfosMinAggregateOutputType | null
    _max: InfosMaxAggregateOutputType | null
  }

  type GetInfosGroupByPayload<T extends InfosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<InfosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InfosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InfosGroupByOutputType[P]>
            : GetScalarType<T[P], InfosGroupByOutputType[P]>
        }
      >
    >


  export type infosSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    service_id?: boolean
    slot_name?: boolean
    content_id?: boolean
    addedclass?: boolean
    header_id?: boolean
  }, ExtArgs["result"]["infos"]>

  export type infosSelectScalar = {
    id?: boolean
    service_id?: boolean
    slot_name?: boolean
    content_id?: boolean
    addedclass?: boolean
    header_id?: boolean
  }


  type infosGetPayload<S extends boolean | null | undefined | infosArgs> = $Types.GetResult<infosPayload, S>

  type infosCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<infosFindManyArgs, 'select' | 'include'> & {
      select?: InfosCountAggregateInputType | true
    }

  export interface infosDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['infos'], meta: { name: 'infos' } }
    /**
     * Find zero or one Infos that matches the filter.
     * @param {infosFindUniqueArgs} args - Arguments to find a Infos
     * @example
     * // Get one Infos
     * const infos = await prisma.infos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends infosFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, infosFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'infos'> extends True ? Prisma__infosClient<$Types.GetResult<infosPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__infosClient<$Types.GetResult<infosPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Infos that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {infosFindUniqueOrThrowArgs} args - Arguments to find a Infos
     * @example
     * // Get one Infos
     * const infos = await prisma.infos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends infosFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, infosFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__infosClient<$Types.GetResult<infosPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Infos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {infosFindFirstArgs} args - Arguments to find a Infos
     * @example
     * // Get one Infos
     * const infos = await prisma.infos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends infosFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, infosFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'infos'> extends True ? Prisma__infosClient<$Types.GetResult<infosPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__infosClient<$Types.GetResult<infosPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Infos that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {infosFindFirstOrThrowArgs} args - Arguments to find a Infos
     * @example
     * // Get one Infos
     * const infos = await prisma.infos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends infosFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, infosFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__infosClient<$Types.GetResult<infosPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Infos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {infosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Infos
     * const infos = await prisma.infos.findMany()
     * 
     * // Get first 10 Infos
     * const infos = await prisma.infos.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const infosWithIdOnly = await prisma.infos.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends infosFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, infosFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<infosPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Infos.
     * @param {infosCreateArgs} args - Arguments to create a Infos.
     * @example
     * // Create one Infos
     * const Infos = await prisma.infos.create({
     *   data: {
     *     // ... data to create a Infos
     *   }
     * })
     * 
    **/
    create<T extends infosCreateArgs<ExtArgs>>(
      args: SelectSubset<T, infosCreateArgs<ExtArgs>>
    ): Prisma__infosClient<$Types.GetResult<infosPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Infos.
     *     @param {infosCreateManyArgs} args - Arguments to create many Infos.
     *     @example
     *     // Create many Infos
     *     const infos = await prisma.infos.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends infosCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, infosCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Infos.
     * @param {infosDeleteArgs} args - Arguments to delete one Infos.
     * @example
     * // Delete one Infos
     * const Infos = await prisma.infos.delete({
     *   where: {
     *     // ... filter to delete one Infos
     *   }
     * })
     * 
    **/
    delete<T extends infosDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, infosDeleteArgs<ExtArgs>>
    ): Prisma__infosClient<$Types.GetResult<infosPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Infos.
     * @param {infosUpdateArgs} args - Arguments to update one Infos.
     * @example
     * // Update one Infos
     * const infos = await prisma.infos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends infosUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, infosUpdateArgs<ExtArgs>>
    ): Prisma__infosClient<$Types.GetResult<infosPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Infos.
     * @param {infosDeleteManyArgs} args - Arguments to filter Infos to delete.
     * @example
     * // Delete a few Infos
     * const { count } = await prisma.infos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends infosDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, infosDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Infos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {infosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Infos
     * const infos = await prisma.infos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends infosUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, infosUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Infos.
     * @param {infosUpsertArgs} args - Arguments to update or create a Infos.
     * @example
     * // Update or create a Infos
     * const infos = await prisma.infos.upsert({
     *   create: {
     *     // ... data to create a Infos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Infos we want to update
     *   }
     * })
    **/
    upsert<T extends infosUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, infosUpsertArgs<ExtArgs>>
    ): Prisma__infosClient<$Types.GetResult<infosPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Infos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {infosCountArgs} args - Arguments to filter Infos to count.
     * @example
     * // Count the number of Infos
     * const count = await prisma.infos.count({
     *   where: {
     *     // ... the filter for the Infos we want to count
     *   }
     * })
    **/
    count<T extends infosCountArgs>(
      args?: Subset<T, infosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InfosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Infos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InfosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InfosAggregateArgs>(args: Subset<T, InfosAggregateArgs>): Prisma.PrismaPromise<GetInfosAggregateType<T>>

    /**
     * Group by Infos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InfosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InfosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InfosGroupByArgs['orderBy'] }
        : { orderBy?: InfosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InfosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInfosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for infos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__infosClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * infos base type for findUnique actions
   */
  export type infosFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the infos
     */
    select?: infosSelect<ExtArgs> | null
    /**
     * Filter, which infos to fetch.
     */
    where: infosWhereUniqueInput
  }

  /**
   * infos findUnique
   */
  export interface infosFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends infosFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * infos findUniqueOrThrow
   */
  export type infosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the infos
     */
    select?: infosSelect<ExtArgs> | null
    /**
     * Filter, which infos to fetch.
     */
    where: infosWhereUniqueInput
  }


  /**
   * infos base type for findFirst actions
   */
  export type infosFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the infos
     */
    select?: infosSelect<ExtArgs> | null
    /**
     * Filter, which infos to fetch.
     */
    where?: infosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of infos to fetch.
     */
    orderBy?: Enumerable<infosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for infos.
     */
    cursor?: infosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` infos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` infos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of infos.
     */
    distinct?: Enumerable<InfosScalarFieldEnum>
  }

  /**
   * infos findFirst
   */
  export interface infosFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends infosFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * infos findFirstOrThrow
   */
  export type infosFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the infos
     */
    select?: infosSelect<ExtArgs> | null
    /**
     * Filter, which infos to fetch.
     */
    where?: infosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of infos to fetch.
     */
    orderBy?: Enumerable<infosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for infos.
     */
    cursor?: infosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` infos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` infos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of infos.
     */
    distinct?: Enumerable<InfosScalarFieldEnum>
  }


  /**
   * infos findMany
   */
  export type infosFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the infos
     */
    select?: infosSelect<ExtArgs> | null
    /**
     * Filter, which infos to fetch.
     */
    where?: infosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of infos to fetch.
     */
    orderBy?: Enumerable<infosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing infos.
     */
    cursor?: infosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` infos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` infos.
     */
    skip?: number
    distinct?: Enumerable<InfosScalarFieldEnum>
  }


  /**
   * infos create
   */
  export type infosCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the infos
     */
    select?: infosSelect<ExtArgs> | null
    /**
     * The data needed to create a infos.
     */
    data: XOR<infosCreateInput, infosUncheckedCreateInput>
  }


  /**
   * infos createMany
   */
  export type infosCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many infos.
     */
    data: Enumerable<infosCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * infos update
   */
  export type infosUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the infos
     */
    select?: infosSelect<ExtArgs> | null
    /**
     * The data needed to update a infos.
     */
    data: XOR<infosUpdateInput, infosUncheckedUpdateInput>
    /**
     * Choose, which infos to update.
     */
    where: infosWhereUniqueInput
  }


  /**
   * infos updateMany
   */
  export type infosUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update infos.
     */
    data: XOR<infosUpdateManyMutationInput, infosUncheckedUpdateManyInput>
    /**
     * Filter which infos to update
     */
    where?: infosWhereInput
  }


  /**
   * infos upsert
   */
  export type infosUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the infos
     */
    select?: infosSelect<ExtArgs> | null
    /**
     * The filter to search for the infos to update in case it exists.
     */
    where: infosWhereUniqueInput
    /**
     * In case the infos found by the `where` argument doesn't exist, create a new infos with this data.
     */
    create: XOR<infosCreateInput, infosUncheckedCreateInput>
    /**
     * In case the infos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<infosUpdateInput, infosUncheckedUpdateInput>
  }


  /**
   * infos delete
   */
  export type infosDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the infos
     */
    select?: infosSelect<ExtArgs> | null
    /**
     * Filter which infos to delete.
     */
    where: infosWhereUniqueInput
  }


  /**
   * infos deleteMany
   */
  export type infosDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which infos to delete
     */
    where?: infosWhereInput
  }


  /**
   * infos without action
   */
  export type infosArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the infos
     */
    select?: infosSelect<ExtArgs> | null
  }



  /**
   * Model infosegments
   */


  export type AggregateInfosegments = {
    _count: InfosegmentsCountAggregateOutputType | null
    _avg: InfosegmentsAvgAggregateOutputType | null
    _sum: InfosegmentsSumAggregateOutputType | null
    _min: InfosegmentsMinAggregateOutputType | null
    _max: InfosegmentsMaxAggregateOutputType | null
  }

  export type InfosegmentsAvgAggregateOutputType = {
    id: number | null
  }

  export type InfosegmentsSumAggregateOutputType = {
    id: number | null
  }

  export type InfosegmentsMinAggregateOutputType = {
    id: number | null
    maintext: string | null
    header: string | null
    genheader: string | null
    subgenheader: string | null
    imgname: string | null
    imgposition: string | null
  }

  export type InfosegmentsMaxAggregateOutputType = {
    id: number | null
    maintext: string | null
    header: string | null
    genheader: string | null
    subgenheader: string | null
    imgname: string | null
    imgposition: string | null
  }

  export type InfosegmentsCountAggregateOutputType = {
    id: number
    maintext: number
    header: number
    genheader: number
    subgenheader: number
    imgname: number
    imgposition: number
    _all: number
  }


  export type InfosegmentsAvgAggregateInputType = {
    id?: true
  }

  export type InfosegmentsSumAggregateInputType = {
    id?: true
  }

  export type InfosegmentsMinAggregateInputType = {
    id?: true
    maintext?: true
    header?: true
    genheader?: true
    subgenheader?: true
    imgname?: true
    imgposition?: true
  }

  export type InfosegmentsMaxAggregateInputType = {
    id?: true
    maintext?: true
    header?: true
    genheader?: true
    subgenheader?: true
    imgname?: true
    imgposition?: true
  }

  export type InfosegmentsCountAggregateInputType = {
    id?: true
    maintext?: true
    header?: true
    genheader?: true
    subgenheader?: true
    imgname?: true
    imgposition?: true
    _all?: true
  }

  export type InfosegmentsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which infosegments to aggregate.
     */
    where?: infosegmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of infosegments to fetch.
     */
    orderBy?: Enumerable<infosegmentsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: infosegmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` infosegments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` infosegments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned infosegments
    **/
    _count?: true | InfosegmentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InfosegmentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InfosegmentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InfosegmentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InfosegmentsMaxAggregateInputType
  }

  export type GetInfosegmentsAggregateType<T extends InfosegmentsAggregateArgs> = {
        [P in keyof T & keyof AggregateInfosegments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInfosegments[P]>
      : GetScalarType<T[P], AggregateInfosegments[P]>
  }




  export type InfosegmentsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: infosegmentsWhereInput
    orderBy?: Enumerable<infosegmentsOrderByWithAggregationInput>
    by: InfosegmentsScalarFieldEnum[]
    having?: infosegmentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InfosegmentsCountAggregateInputType | true
    _avg?: InfosegmentsAvgAggregateInputType
    _sum?: InfosegmentsSumAggregateInputType
    _min?: InfosegmentsMinAggregateInputType
    _max?: InfosegmentsMaxAggregateInputType
  }


  export type InfosegmentsGroupByOutputType = {
    id: number
    maintext: string | null
    header: string | null
    genheader: string | null
    subgenheader: string | null
    imgname: string | null
    imgposition: string | null
    _count: InfosegmentsCountAggregateOutputType | null
    _avg: InfosegmentsAvgAggregateOutputType | null
    _sum: InfosegmentsSumAggregateOutputType | null
    _min: InfosegmentsMinAggregateOutputType | null
    _max: InfosegmentsMaxAggregateOutputType | null
  }

  type GetInfosegmentsGroupByPayload<T extends InfosegmentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<InfosegmentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InfosegmentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InfosegmentsGroupByOutputType[P]>
            : GetScalarType<T[P], InfosegmentsGroupByOutputType[P]>
        }
      >
    >


  export type infosegmentsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    maintext?: boolean
    header?: boolean
    genheader?: boolean
    subgenheader?: boolean
    imgname?: boolean
    imgposition?: boolean
  }, ExtArgs["result"]["infosegments"]>

  export type infosegmentsSelectScalar = {
    id?: boolean
    maintext?: boolean
    header?: boolean
    genheader?: boolean
    subgenheader?: boolean
    imgname?: boolean
    imgposition?: boolean
  }


  type infosegmentsGetPayload<S extends boolean | null | undefined | infosegmentsArgs> = $Types.GetResult<infosegmentsPayload, S>

  type infosegmentsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<infosegmentsFindManyArgs, 'select' | 'include'> & {
      select?: InfosegmentsCountAggregateInputType | true
    }

  export interface infosegmentsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['infosegments'], meta: { name: 'infosegments' } }
    /**
     * Find zero or one Infosegments that matches the filter.
     * @param {infosegmentsFindUniqueArgs} args - Arguments to find a Infosegments
     * @example
     * // Get one Infosegments
     * const infosegments = await prisma.infosegments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends infosegmentsFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, infosegmentsFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'infosegments'> extends True ? Prisma__infosegmentsClient<$Types.GetResult<infosegmentsPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__infosegmentsClient<$Types.GetResult<infosegmentsPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Infosegments that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {infosegmentsFindUniqueOrThrowArgs} args - Arguments to find a Infosegments
     * @example
     * // Get one Infosegments
     * const infosegments = await prisma.infosegments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends infosegmentsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, infosegmentsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__infosegmentsClient<$Types.GetResult<infosegmentsPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Infosegments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {infosegmentsFindFirstArgs} args - Arguments to find a Infosegments
     * @example
     * // Get one Infosegments
     * const infosegments = await prisma.infosegments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends infosegmentsFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, infosegmentsFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'infosegments'> extends True ? Prisma__infosegmentsClient<$Types.GetResult<infosegmentsPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__infosegmentsClient<$Types.GetResult<infosegmentsPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Infosegments that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {infosegmentsFindFirstOrThrowArgs} args - Arguments to find a Infosegments
     * @example
     * // Get one Infosegments
     * const infosegments = await prisma.infosegments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends infosegmentsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, infosegmentsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__infosegmentsClient<$Types.GetResult<infosegmentsPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Infosegments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {infosegmentsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Infosegments
     * const infosegments = await prisma.infosegments.findMany()
     * 
     * // Get first 10 Infosegments
     * const infosegments = await prisma.infosegments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const infosegmentsWithIdOnly = await prisma.infosegments.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends infosegmentsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, infosegmentsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<infosegmentsPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Infosegments.
     * @param {infosegmentsCreateArgs} args - Arguments to create a Infosegments.
     * @example
     * // Create one Infosegments
     * const Infosegments = await prisma.infosegments.create({
     *   data: {
     *     // ... data to create a Infosegments
     *   }
     * })
     * 
    **/
    create<T extends infosegmentsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, infosegmentsCreateArgs<ExtArgs>>
    ): Prisma__infosegmentsClient<$Types.GetResult<infosegmentsPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Infosegments.
     *     @param {infosegmentsCreateManyArgs} args - Arguments to create many Infosegments.
     *     @example
     *     // Create many Infosegments
     *     const infosegments = await prisma.infosegments.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends infosegmentsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, infosegmentsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Infosegments.
     * @param {infosegmentsDeleteArgs} args - Arguments to delete one Infosegments.
     * @example
     * // Delete one Infosegments
     * const Infosegments = await prisma.infosegments.delete({
     *   where: {
     *     // ... filter to delete one Infosegments
     *   }
     * })
     * 
    **/
    delete<T extends infosegmentsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, infosegmentsDeleteArgs<ExtArgs>>
    ): Prisma__infosegmentsClient<$Types.GetResult<infosegmentsPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Infosegments.
     * @param {infosegmentsUpdateArgs} args - Arguments to update one Infosegments.
     * @example
     * // Update one Infosegments
     * const infosegments = await prisma.infosegments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends infosegmentsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, infosegmentsUpdateArgs<ExtArgs>>
    ): Prisma__infosegmentsClient<$Types.GetResult<infosegmentsPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Infosegments.
     * @param {infosegmentsDeleteManyArgs} args - Arguments to filter Infosegments to delete.
     * @example
     * // Delete a few Infosegments
     * const { count } = await prisma.infosegments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends infosegmentsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, infosegmentsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Infosegments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {infosegmentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Infosegments
     * const infosegments = await prisma.infosegments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends infosegmentsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, infosegmentsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Infosegments.
     * @param {infosegmentsUpsertArgs} args - Arguments to update or create a Infosegments.
     * @example
     * // Update or create a Infosegments
     * const infosegments = await prisma.infosegments.upsert({
     *   create: {
     *     // ... data to create a Infosegments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Infosegments we want to update
     *   }
     * })
    **/
    upsert<T extends infosegmentsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, infosegmentsUpsertArgs<ExtArgs>>
    ): Prisma__infosegmentsClient<$Types.GetResult<infosegmentsPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Infosegments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {infosegmentsCountArgs} args - Arguments to filter Infosegments to count.
     * @example
     * // Count the number of Infosegments
     * const count = await prisma.infosegments.count({
     *   where: {
     *     // ... the filter for the Infosegments we want to count
     *   }
     * })
    **/
    count<T extends infosegmentsCountArgs>(
      args?: Subset<T, infosegmentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InfosegmentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Infosegments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InfosegmentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InfosegmentsAggregateArgs>(args: Subset<T, InfosegmentsAggregateArgs>): Prisma.PrismaPromise<GetInfosegmentsAggregateType<T>>

    /**
     * Group by Infosegments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InfosegmentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InfosegmentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InfosegmentsGroupByArgs['orderBy'] }
        : { orderBy?: InfosegmentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InfosegmentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInfosegmentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for infosegments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__infosegmentsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * infosegments base type for findUnique actions
   */
  export type infosegmentsFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the infosegments
     */
    select?: infosegmentsSelect<ExtArgs> | null
    /**
     * Filter, which infosegments to fetch.
     */
    where: infosegmentsWhereUniqueInput
  }

  /**
   * infosegments findUnique
   */
  export interface infosegmentsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends infosegmentsFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * infosegments findUniqueOrThrow
   */
  export type infosegmentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the infosegments
     */
    select?: infosegmentsSelect<ExtArgs> | null
    /**
     * Filter, which infosegments to fetch.
     */
    where: infosegmentsWhereUniqueInput
  }


  /**
   * infosegments base type for findFirst actions
   */
  export type infosegmentsFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the infosegments
     */
    select?: infosegmentsSelect<ExtArgs> | null
    /**
     * Filter, which infosegments to fetch.
     */
    where?: infosegmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of infosegments to fetch.
     */
    orderBy?: Enumerable<infosegmentsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for infosegments.
     */
    cursor?: infosegmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` infosegments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` infosegments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of infosegments.
     */
    distinct?: Enumerable<InfosegmentsScalarFieldEnum>
  }

  /**
   * infosegments findFirst
   */
  export interface infosegmentsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends infosegmentsFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * infosegments findFirstOrThrow
   */
  export type infosegmentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the infosegments
     */
    select?: infosegmentsSelect<ExtArgs> | null
    /**
     * Filter, which infosegments to fetch.
     */
    where?: infosegmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of infosegments to fetch.
     */
    orderBy?: Enumerable<infosegmentsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for infosegments.
     */
    cursor?: infosegmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` infosegments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` infosegments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of infosegments.
     */
    distinct?: Enumerable<InfosegmentsScalarFieldEnum>
  }


  /**
   * infosegments findMany
   */
  export type infosegmentsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the infosegments
     */
    select?: infosegmentsSelect<ExtArgs> | null
    /**
     * Filter, which infosegments to fetch.
     */
    where?: infosegmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of infosegments to fetch.
     */
    orderBy?: Enumerable<infosegmentsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing infosegments.
     */
    cursor?: infosegmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` infosegments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` infosegments.
     */
    skip?: number
    distinct?: Enumerable<InfosegmentsScalarFieldEnum>
  }


  /**
   * infosegments create
   */
  export type infosegmentsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the infosegments
     */
    select?: infosegmentsSelect<ExtArgs> | null
    /**
     * The data needed to create a infosegments.
     */
    data?: XOR<infosegmentsCreateInput, infosegmentsUncheckedCreateInput>
  }


  /**
   * infosegments createMany
   */
  export type infosegmentsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many infosegments.
     */
    data: Enumerable<infosegmentsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * infosegments update
   */
  export type infosegmentsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the infosegments
     */
    select?: infosegmentsSelect<ExtArgs> | null
    /**
     * The data needed to update a infosegments.
     */
    data: XOR<infosegmentsUpdateInput, infosegmentsUncheckedUpdateInput>
    /**
     * Choose, which infosegments to update.
     */
    where: infosegmentsWhereUniqueInput
  }


  /**
   * infosegments updateMany
   */
  export type infosegmentsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update infosegments.
     */
    data: XOR<infosegmentsUpdateManyMutationInput, infosegmentsUncheckedUpdateManyInput>
    /**
     * Filter which infosegments to update
     */
    where?: infosegmentsWhereInput
  }


  /**
   * infosegments upsert
   */
  export type infosegmentsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the infosegments
     */
    select?: infosegmentsSelect<ExtArgs> | null
    /**
     * The filter to search for the infosegments to update in case it exists.
     */
    where: infosegmentsWhereUniqueInput
    /**
     * In case the infosegments found by the `where` argument doesn't exist, create a new infosegments with this data.
     */
    create: XOR<infosegmentsCreateInput, infosegmentsUncheckedCreateInput>
    /**
     * In case the infosegments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<infosegmentsUpdateInput, infosegmentsUncheckedUpdateInput>
  }


  /**
   * infosegments delete
   */
  export type infosegmentsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the infosegments
     */
    select?: infosegmentsSelect<ExtArgs> | null
    /**
     * Filter which infosegments to delete.
     */
    where: infosegmentsWhereUniqueInput
  }


  /**
   * infosegments deleteMany
   */
  export type infosegmentsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which infosegments to delete
     */
    where?: infosegmentsWhereInput
  }


  /**
   * infosegments without action
   */
  export type infosegmentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the infosegments
     */
    select?: infosegmentsSelect<ExtArgs> | null
  }



  /**
   * Model liturgicalsegments
   */


  export type AggregateLiturgicalsegments = {
    _count: LiturgicalsegmentsCountAggregateOutputType | null
    _avg: LiturgicalsegmentsAvgAggregateOutputType | null
    _sum: LiturgicalsegmentsSumAggregateOutputType | null
    _min: LiturgicalsegmentsMinAggregateOutputType | null
    _max: LiturgicalsegmentsMaxAggregateOutputType | null
  }

  export type LiturgicalsegmentsAvgAggregateOutputType = {
    id: number | null
  }

  export type LiturgicalsegmentsSumAggregateOutputType = {
    id: number | null
  }

  export type LiturgicalsegmentsMinAggregateOutputType = {
    id: number | null
    text_title: string | null
    use_as_header: boolean | null
  }

  export type LiturgicalsegmentsMaxAggregateOutputType = {
    id: number | null
    text_title: string | null
    use_as_header: boolean | null
  }

  export type LiturgicalsegmentsCountAggregateOutputType = {
    id: number
    text_title: number
    use_as_header: number
    _all: number
  }


  export type LiturgicalsegmentsAvgAggregateInputType = {
    id?: true
  }

  export type LiturgicalsegmentsSumAggregateInputType = {
    id?: true
  }

  export type LiturgicalsegmentsMinAggregateInputType = {
    id?: true
    text_title?: true
    use_as_header?: true
  }

  export type LiturgicalsegmentsMaxAggregateInputType = {
    id?: true
    text_title?: true
    use_as_header?: true
  }

  export type LiturgicalsegmentsCountAggregateInputType = {
    id?: true
    text_title?: true
    use_as_header?: true
    _all?: true
  }

  export type LiturgicalsegmentsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which liturgicalsegments to aggregate.
     */
    where?: liturgicalsegmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of liturgicalsegments to fetch.
     */
    orderBy?: Enumerable<liturgicalsegmentsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: liturgicalsegmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` liturgicalsegments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` liturgicalsegments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned liturgicalsegments
    **/
    _count?: true | LiturgicalsegmentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LiturgicalsegmentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LiturgicalsegmentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LiturgicalsegmentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LiturgicalsegmentsMaxAggregateInputType
  }

  export type GetLiturgicalsegmentsAggregateType<T extends LiturgicalsegmentsAggregateArgs> = {
        [P in keyof T & keyof AggregateLiturgicalsegments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLiturgicalsegments[P]>
      : GetScalarType<T[P], AggregateLiturgicalsegments[P]>
  }




  export type LiturgicalsegmentsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: liturgicalsegmentsWhereInput
    orderBy?: Enumerable<liturgicalsegmentsOrderByWithAggregationInput>
    by: LiturgicalsegmentsScalarFieldEnum[]
    having?: liturgicalsegmentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LiturgicalsegmentsCountAggregateInputType | true
    _avg?: LiturgicalsegmentsAvgAggregateInputType
    _sum?: LiturgicalsegmentsSumAggregateInputType
    _min?: LiturgicalsegmentsMinAggregateInputType
    _max?: LiturgicalsegmentsMaxAggregateInputType
  }


  export type LiturgicalsegmentsGroupByOutputType = {
    id: number
    text_title: string | null
    use_as_header: boolean | null
    _count: LiturgicalsegmentsCountAggregateOutputType | null
    _avg: LiturgicalsegmentsAvgAggregateOutputType | null
    _sum: LiturgicalsegmentsSumAggregateOutputType | null
    _min: LiturgicalsegmentsMinAggregateOutputType | null
    _max: LiturgicalsegmentsMaxAggregateOutputType | null
  }

  type GetLiturgicalsegmentsGroupByPayload<T extends LiturgicalsegmentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<LiturgicalsegmentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LiturgicalsegmentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LiturgicalsegmentsGroupByOutputType[P]>
            : GetScalarType<T[P], LiturgicalsegmentsGroupByOutputType[P]>
        }
      >
    >


  export type liturgicalsegmentsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    text_title?: boolean
    use_as_header?: boolean
  }, ExtArgs["result"]["liturgicalsegments"]>

  export type liturgicalsegmentsSelectScalar = {
    id?: boolean
    text_title?: boolean
    use_as_header?: boolean
  }


  type liturgicalsegmentsGetPayload<S extends boolean | null | undefined | liturgicalsegmentsArgs> = $Types.GetResult<liturgicalsegmentsPayload, S>

  type liturgicalsegmentsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<liturgicalsegmentsFindManyArgs, 'select' | 'include'> & {
      select?: LiturgicalsegmentsCountAggregateInputType | true
    }

  export interface liturgicalsegmentsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['liturgicalsegments'], meta: { name: 'liturgicalsegments' } }
    /**
     * Find zero or one Liturgicalsegments that matches the filter.
     * @param {liturgicalsegmentsFindUniqueArgs} args - Arguments to find a Liturgicalsegments
     * @example
     * // Get one Liturgicalsegments
     * const liturgicalsegments = await prisma.liturgicalsegments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends liturgicalsegmentsFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, liturgicalsegmentsFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'liturgicalsegments'> extends True ? Prisma__liturgicalsegmentsClient<$Types.GetResult<liturgicalsegmentsPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__liturgicalsegmentsClient<$Types.GetResult<liturgicalsegmentsPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Liturgicalsegments that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {liturgicalsegmentsFindUniqueOrThrowArgs} args - Arguments to find a Liturgicalsegments
     * @example
     * // Get one Liturgicalsegments
     * const liturgicalsegments = await prisma.liturgicalsegments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends liturgicalsegmentsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, liturgicalsegmentsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__liturgicalsegmentsClient<$Types.GetResult<liturgicalsegmentsPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Liturgicalsegments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {liturgicalsegmentsFindFirstArgs} args - Arguments to find a Liturgicalsegments
     * @example
     * // Get one Liturgicalsegments
     * const liturgicalsegments = await prisma.liturgicalsegments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends liturgicalsegmentsFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, liturgicalsegmentsFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'liturgicalsegments'> extends True ? Prisma__liturgicalsegmentsClient<$Types.GetResult<liturgicalsegmentsPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__liturgicalsegmentsClient<$Types.GetResult<liturgicalsegmentsPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Liturgicalsegments that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {liturgicalsegmentsFindFirstOrThrowArgs} args - Arguments to find a Liturgicalsegments
     * @example
     * // Get one Liturgicalsegments
     * const liturgicalsegments = await prisma.liturgicalsegments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends liturgicalsegmentsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, liturgicalsegmentsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__liturgicalsegmentsClient<$Types.GetResult<liturgicalsegmentsPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Liturgicalsegments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {liturgicalsegmentsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Liturgicalsegments
     * const liturgicalsegments = await prisma.liturgicalsegments.findMany()
     * 
     * // Get first 10 Liturgicalsegments
     * const liturgicalsegments = await prisma.liturgicalsegments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const liturgicalsegmentsWithIdOnly = await prisma.liturgicalsegments.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends liturgicalsegmentsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, liturgicalsegmentsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<liturgicalsegmentsPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Liturgicalsegments.
     * @param {liturgicalsegmentsCreateArgs} args - Arguments to create a Liturgicalsegments.
     * @example
     * // Create one Liturgicalsegments
     * const Liturgicalsegments = await prisma.liturgicalsegments.create({
     *   data: {
     *     // ... data to create a Liturgicalsegments
     *   }
     * })
     * 
    **/
    create<T extends liturgicalsegmentsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, liturgicalsegmentsCreateArgs<ExtArgs>>
    ): Prisma__liturgicalsegmentsClient<$Types.GetResult<liturgicalsegmentsPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Liturgicalsegments.
     *     @param {liturgicalsegmentsCreateManyArgs} args - Arguments to create many Liturgicalsegments.
     *     @example
     *     // Create many Liturgicalsegments
     *     const liturgicalsegments = await prisma.liturgicalsegments.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends liturgicalsegmentsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, liturgicalsegmentsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Liturgicalsegments.
     * @param {liturgicalsegmentsDeleteArgs} args - Arguments to delete one Liturgicalsegments.
     * @example
     * // Delete one Liturgicalsegments
     * const Liturgicalsegments = await prisma.liturgicalsegments.delete({
     *   where: {
     *     // ... filter to delete one Liturgicalsegments
     *   }
     * })
     * 
    **/
    delete<T extends liturgicalsegmentsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, liturgicalsegmentsDeleteArgs<ExtArgs>>
    ): Prisma__liturgicalsegmentsClient<$Types.GetResult<liturgicalsegmentsPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Liturgicalsegments.
     * @param {liturgicalsegmentsUpdateArgs} args - Arguments to update one Liturgicalsegments.
     * @example
     * // Update one Liturgicalsegments
     * const liturgicalsegments = await prisma.liturgicalsegments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends liturgicalsegmentsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, liturgicalsegmentsUpdateArgs<ExtArgs>>
    ): Prisma__liturgicalsegmentsClient<$Types.GetResult<liturgicalsegmentsPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Liturgicalsegments.
     * @param {liturgicalsegmentsDeleteManyArgs} args - Arguments to filter Liturgicalsegments to delete.
     * @example
     * // Delete a few Liturgicalsegments
     * const { count } = await prisma.liturgicalsegments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends liturgicalsegmentsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, liturgicalsegmentsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Liturgicalsegments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {liturgicalsegmentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Liturgicalsegments
     * const liturgicalsegments = await prisma.liturgicalsegments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends liturgicalsegmentsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, liturgicalsegmentsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Liturgicalsegments.
     * @param {liturgicalsegmentsUpsertArgs} args - Arguments to update or create a Liturgicalsegments.
     * @example
     * // Update or create a Liturgicalsegments
     * const liturgicalsegments = await prisma.liturgicalsegments.upsert({
     *   create: {
     *     // ... data to create a Liturgicalsegments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Liturgicalsegments we want to update
     *   }
     * })
    **/
    upsert<T extends liturgicalsegmentsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, liturgicalsegmentsUpsertArgs<ExtArgs>>
    ): Prisma__liturgicalsegmentsClient<$Types.GetResult<liturgicalsegmentsPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Liturgicalsegments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {liturgicalsegmentsCountArgs} args - Arguments to filter Liturgicalsegments to count.
     * @example
     * // Count the number of Liturgicalsegments
     * const count = await prisma.liturgicalsegments.count({
     *   where: {
     *     // ... the filter for the Liturgicalsegments we want to count
     *   }
     * })
    **/
    count<T extends liturgicalsegmentsCountArgs>(
      args?: Subset<T, liturgicalsegmentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LiturgicalsegmentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Liturgicalsegments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiturgicalsegmentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LiturgicalsegmentsAggregateArgs>(args: Subset<T, LiturgicalsegmentsAggregateArgs>): Prisma.PrismaPromise<GetLiturgicalsegmentsAggregateType<T>>

    /**
     * Group by Liturgicalsegments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiturgicalsegmentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LiturgicalsegmentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LiturgicalsegmentsGroupByArgs['orderBy'] }
        : { orderBy?: LiturgicalsegmentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LiturgicalsegmentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLiturgicalsegmentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for liturgicalsegments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__liturgicalsegmentsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * liturgicalsegments base type for findUnique actions
   */
  export type liturgicalsegmentsFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the liturgicalsegments
     */
    select?: liturgicalsegmentsSelect<ExtArgs> | null
    /**
     * Filter, which liturgicalsegments to fetch.
     */
    where: liturgicalsegmentsWhereUniqueInput
  }

  /**
   * liturgicalsegments findUnique
   */
  export interface liturgicalsegmentsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends liturgicalsegmentsFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * liturgicalsegments findUniqueOrThrow
   */
  export type liturgicalsegmentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the liturgicalsegments
     */
    select?: liturgicalsegmentsSelect<ExtArgs> | null
    /**
     * Filter, which liturgicalsegments to fetch.
     */
    where: liturgicalsegmentsWhereUniqueInput
  }


  /**
   * liturgicalsegments base type for findFirst actions
   */
  export type liturgicalsegmentsFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the liturgicalsegments
     */
    select?: liturgicalsegmentsSelect<ExtArgs> | null
    /**
     * Filter, which liturgicalsegments to fetch.
     */
    where?: liturgicalsegmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of liturgicalsegments to fetch.
     */
    orderBy?: Enumerable<liturgicalsegmentsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for liturgicalsegments.
     */
    cursor?: liturgicalsegmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` liturgicalsegments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` liturgicalsegments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of liturgicalsegments.
     */
    distinct?: Enumerable<LiturgicalsegmentsScalarFieldEnum>
  }

  /**
   * liturgicalsegments findFirst
   */
  export interface liturgicalsegmentsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends liturgicalsegmentsFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * liturgicalsegments findFirstOrThrow
   */
  export type liturgicalsegmentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the liturgicalsegments
     */
    select?: liturgicalsegmentsSelect<ExtArgs> | null
    /**
     * Filter, which liturgicalsegments to fetch.
     */
    where?: liturgicalsegmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of liturgicalsegments to fetch.
     */
    orderBy?: Enumerable<liturgicalsegmentsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for liturgicalsegments.
     */
    cursor?: liturgicalsegmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` liturgicalsegments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` liturgicalsegments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of liturgicalsegments.
     */
    distinct?: Enumerable<LiturgicalsegmentsScalarFieldEnum>
  }


  /**
   * liturgicalsegments findMany
   */
  export type liturgicalsegmentsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the liturgicalsegments
     */
    select?: liturgicalsegmentsSelect<ExtArgs> | null
    /**
     * Filter, which liturgicalsegments to fetch.
     */
    where?: liturgicalsegmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of liturgicalsegments to fetch.
     */
    orderBy?: Enumerable<liturgicalsegmentsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing liturgicalsegments.
     */
    cursor?: liturgicalsegmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` liturgicalsegments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` liturgicalsegments.
     */
    skip?: number
    distinct?: Enumerable<LiturgicalsegmentsScalarFieldEnum>
  }


  /**
   * liturgicalsegments create
   */
  export type liturgicalsegmentsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the liturgicalsegments
     */
    select?: liturgicalsegmentsSelect<ExtArgs> | null
    /**
     * The data needed to create a liturgicalsegments.
     */
    data?: XOR<liturgicalsegmentsCreateInput, liturgicalsegmentsUncheckedCreateInput>
  }


  /**
   * liturgicalsegments createMany
   */
  export type liturgicalsegmentsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many liturgicalsegments.
     */
    data: Enumerable<liturgicalsegmentsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * liturgicalsegments update
   */
  export type liturgicalsegmentsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the liturgicalsegments
     */
    select?: liturgicalsegmentsSelect<ExtArgs> | null
    /**
     * The data needed to update a liturgicalsegments.
     */
    data: XOR<liturgicalsegmentsUpdateInput, liturgicalsegmentsUncheckedUpdateInput>
    /**
     * Choose, which liturgicalsegments to update.
     */
    where: liturgicalsegmentsWhereUniqueInput
  }


  /**
   * liturgicalsegments updateMany
   */
  export type liturgicalsegmentsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update liturgicalsegments.
     */
    data: XOR<liturgicalsegmentsUpdateManyMutationInput, liturgicalsegmentsUncheckedUpdateManyInput>
    /**
     * Filter which liturgicalsegments to update
     */
    where?: liturgicalsegmentsWhereInput
  }


  /**
   * liturgicalsegments upsert
   */
  export type liturgicalsegmentsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the liturgicalsegments
     */
    select?: liturgicalsegmentsSelect<ExtArgs> | null
    /**
     * The filter to search for the liturgicalsegments to update in case it exists.
     */
    where: liturgicalsegmentsWhereUniqueInput
    /**
     * In case the liturgicalsegments found by the `where` argument doesn't exist, create a new liturgicalsegments with this data.
     */
    create: XOR<liturgicalsegmentsCreateInput, liturgicalsegmentsUncheckedCreateInput>
    /**
     * In case the liturgicalsegments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<liturgicalsegmentsUpdateInput, liturgicalsegmentsUncheckedUpdateInput>
  }


  /**
   * liturgicalsegments delete
   */
  export type liturgicalsegmentsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the liturgicalsegments
     */
    select?: liturgicalsegmentsSelect<ExtArgs> | null
    /**
     * Filter which liturgicalsegments to delete.
     */
    where: liturgicalsegmentsWhereUniqueInput
  }


  /**
   * liturgicalsegments deleteMany
   */
  export type liturgicalsegmentsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which liturgicalsegments to delete
     */
    where?: liturgicalsegmentsWhereInput
  }


  /**
   * liturgicalsegments without action
   */
  export type liturgicalsegmentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the liturgicalsegments
     */
    select?: liturgicalsegmentsSelect<ExtArgs> | null
  }



  /**
   * Model ltextdata
   */


  export type AggregateLtextdata = {
    _count: LtextdataCountAggregateOutputType | null
    _avg: LtextdataAvgAggregateOutputType | null
    _sum: LtextdataSumAggregateOutputType | null
    _min: LtextdataMinAggregateOutputType | null
    _max: LtextdataMaxAggregateOutputType | null
  }

  export type LtextdataAvgAggregateOutputType = {
    id: number | null
  }

  export type LtextdataSumAggregateOutputType = {
    id: number | null
  }

  export type LtextdataMinAggregateOutputType = {
    id: number | null
    title: string | null
  }

  export type LtextdataMaxAggregateOutputType = {
    id: number | null
    title: string | null
  }

  export type LtextdataCountAggregateOutputType = {
    id: number
    title: number
    _all: number
  }


  export type LtextdataAvgAggregateInputType = {
    id?: true
  }

  export type LtextdataSumAggregateInputType = {
    id?: true
  }

  export type LtextdataMinAggregateInputType = {
    id?: true
    title?: true
  }

  export type LtextdataMaxAggregateInputType = {
    id?: true
    title?: true
  }

  export type LtextdataCountAggregateInputType = {
    id?: true
    title?: true
    _all?: true
  }

  export type LtextdataAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ltextdata to aggregate.
     */
    where?: ltextdataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ltextdata to fetch.
     */
    orderBy?: Enumerable<ltextdataOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ltextdataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ltextdata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ltextdata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ltextdata
    **/
    _count?: true | LtextdataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LtextdataAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LtextdataSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LtextdataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LtextdataMaxAggregateInputType
  }

  export type GetLtextdataAggregateType<T extends LtextdataAggregateArgs> = {
        [P in keyof T & keyof AggregateLtextdata]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLtextdata[P]>
      : GetScalarType<T[P], AggregateLtextdata[P]>
  }




  export type LtextdataGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ltextdataWhereInput
    orderBy?: Enumerable<ltextdataOrderByWithAggregationInput>
    by: LtextdataScalarFieldEnum[]
    having?: ltextdataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LtextdataCountAggregateInputType | true
    _avg?: LtextdataAvgAggregateInputType
    _sum?: LtextdataSumAggregateInputType
    _min?: LtextdataMinAggregateInputType
    _max?: LtextdataMaxAggregateInputType
  }


  export type LtextdataGroupByOutputType = {
    id: number
    title: string | null
    _count: LtextdataCountAggregateOutputType | null
    _avg: LtextdataAvgAggregateOutputType | null
    _sum: LtextdataSumAggregateOutputType | null
    _min: LtextdataMinAggregateOutputType | null
    _max: LtextdataMaxAggregateOutputType | null
  }

  type GetLtextdataGroupByPayload<T extends LtextdataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<LtextdataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LtextdataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LtextdataGroupByOutputType[P]>
            : GetScalarType<T[P], LtextdataGroupByOutputType[P]>
        }
      >
    >


  export type ltextdataSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    ltextversedata?: boolean | ltextdata$ltextversedataArgs<ExtArgs>
    _count?: boolean | LtextdataCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["ltextdata"]>

  export type ltextdataSelectScalar = {
    id?: boolean
    title?: boolean
  }

  export type ltextdataInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    ltextversedata?: boolean | ltextdata$ltextversedataArgs<ExtArgs>
    _count?: boolean | LtextdataCountOutputTypeArgs<ExtArgs>
  }


  type ltextdataGetPayload<S extends boolean | null | undefined | ltextdataArgs> = $Types.GetResult<ltextdataPayload, S>

  type ltextdataCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ltextdataFindManyArgs, 'select' | 'include'> & {
      select?: LtextdataCountAggregateInputType | true
    }

  export interface ltextdataDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ltextdata'], meta: { name: 'ltextdata' } }
    /**
     * Find zero or one Ltextdata that matches the filter.
     * @param {ltextdataFindUniqueArgs} args - Arguments to find a Ltextdata
     * @example
     * // Get one Ltextdata
     * const ltextdata = await prisma.ltextdata.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ltextdataFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ltextdataFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ltextdata'> extends True ? Prisma__ltextdataClient<$Types.GetResult<ltextdataPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ltextdataClient<$Types.GetResult<ltextdataPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Ltextdata that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ltextdataFindUniqueOrThrowArgs} args - Arguments to find a Ltextdata
     * @example
     * // Get one Ltextdata
     * const ltextdata = await prisma.ltextdata.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ltextdataFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ltextdataFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ltextdataClient<$Types.GetResult<ltextdataPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Ltextdata that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ltextdataFindFirstArgs} args - Arguments to find a Ltextdata
     * @example
     * // Get one Ltextdata
     * const ltextdata = await prisma.ltextdata.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ltextdataFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ltextdataFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ltextdata'> extends True ? Prisma__ltextdataClient<$Types.GetResult<ltextdataPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ltextdataClient<$Types.GetResult<ltextdataPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Ltextdata that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ltextdataFindFirstOrThrowArgs} args - Arguments to find a Ltextdata
     * @example
     * // Get one Ltextdata
     * const ltextdata = await prisma.ltextdata.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ltextdataFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ltextdataFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ltextdataClient<$Types.GetResult<ltextdataPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Ltextdata that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ltextdataFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ltextdata
     * const ltextdata = await prisma.ltextdata.findMany()
     * 
     * // Get first 10 Ltextdata
     * const ltextdata = await prisma.ltextdata.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ltextdataWithIdOnly = await prisma.ltextdata.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ltextdataFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ltextdataFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ltextdataPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Ltextdata.
     * @param {ltextdataCreateArgs} args - Arguments to create a Ltextdata.
     * @example
     * // Create one Ltextdata
     * const Ltextdata = await prisma.ltextdata.create({
     *   data: {
     *     // ... data to create a Ltextdata
     *   }
     * })
     * 
    **/
    create<T extends ltextdataCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ltextdataCreateArgs<ExtArgs>>
    ): Prisma__ltextdataClient<$Types.GetResult<ltextdataPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Ltextdata.
     *     @param {ltextdataCreateManyArgs} args - Arguments to create many Ltextdata.
     *     @example
     *     // Create many Ltextdata
     *     const ltextdata = await prisma.ltextdata.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ltextdataCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ltextdataCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Ltextdata.
     * @param {ltextdataDeleteArgs} args - Arguments to delete one Ltextdata.
     * @example
     * // Delete one Ltextdata
     * const Ltextdata = await prisma.ltextdata.delete({
     *   where: {
     *     // ... filter to delete one Ltextdata
     *   }
     * })
     * 
    **/
    delete<T extends ltextdataDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ltextdataDeleteArgs<ExtArgs>>
    ): Prisma__ltextdataClient<$Types.GetResult<ltextdataPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Ltextdata.
     * @param {ltextdataUpdateArgs} args - Arguments to update one Ltextdata.
     * @example
     * // Update one Ltextdata
     * const ltextdata = await prisma.ltextdata.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ltextdataUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ltextdataUpdateArgs<ExtArgs>>
    ): Prisma__ltextdataClient<$Types.GetResult<ltextdataPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Ltextdata.
     * @param {ltextdataDeleteManyArgs} args - Arguments to filter Ltextdata to delete.
     * @example
     * // Delete a few Ltextdata
     * const { count } = await prisma.ltextdata.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ltextdataDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ltextdataDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ltextdata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ltextdataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ltextdata
     * const ltextdata = await prisma.ltextdata.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ltextdataUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ltextdataUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ltextdata.
     * @param {ltextdataUpsertArgs} args - Arguments to update or create a Ltextdata.
     * @example
     * // Update or create a Ltextdata
     * const ltextdata = await prisma.ltextdata.upsert({
     *   create: {
     *     // ... data to create a Ltextdata
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ltextdata we want to update
     *   }
     * })
    **/
    upsert<T extends ltextdataUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ltextdataUpsertArgs<ExtArgs>>
    ): Prisma__ltextdataClient<$Types.GetResult<ltextdataPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Ltextdata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ltextdataCountArgs} args - Arguments to filter Ltextdata to count.
     * @example
     * // Count the number of Ltextdata
     * const count = await prisma.ltextdata.count({
     *   where: {
     *     // ... the filter for the Ltextdata we want to count
     *   }
     * })
    **/
    count<T extends ltextdataCountArgs>(
      args?: Subset<T, ltextdataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LtextdataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ltextdata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LtextdataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LtextdataAggregateArgs>(args: Subset<T, LtextdataAggregateArgs>): Prisma.PrismaPromise<GetLtextdataAggregateType<T>>

    /**
     * Group by Ltextdata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LtextdataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LtextdataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LtextdataGroupByArgs['orderBy'] }
        : { orderBy?: LtextdataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LtextdataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLtextdataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ltextdata.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ltextdataClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    ltextversedata<T extends ltextdata$ltextversedataArgs<ExtArgs> = {}>(args?: Subset<T, ltextdata$ltextversedataArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ltextversedataPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ltextdata base type for findUnique actions
   */
  export type ltextdataFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ltextdata
     */
    select?: ltextdataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ltextdataInclude<ExtArgs> | null
    /**
     * Filter, which ltextdata to fetch.
     */
    where: ltextdataWhereUniqueInput
  }

  /**
   * ltextdata findUnique
   */
  export interface ltextdataFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ltextdataFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ltextdata findUniqueOrThrow
   */
  export type ltextdataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ltextdata
     */
    select?: ltextdataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ltextdataInclude<ExtArgs> | null
    /**
     * Filter, which ltextdata to fetch.
     */
    where: ltextdataWhereUniqueInput
  }


  /**
   * ltextdata base type for findFirst actions
   */
  export type ltextdataFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ltextdata
     */
    select?: ltextdataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ltextdataInclude<ExtArgs> | null
    /**
     * Filter, which ltextdata to fetch.
     */
    where?: ltextdataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ltextdata to fetch.
     */
    orderBy?: Enumerable<ltextdataOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ltextdata.
     */
    cursor?: ltextdataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ltextdata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ltextdata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ltextdata.
     */
    distinct?: Enumerable<LtextdataScalarFieldEnum>
  }

  /**
   * ltextdata findFirst
   */
  export interface ltextdataFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ltextdataFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ltextdata findFirstOrThrow
   */
  export type ltextdataFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ltextdata
     */
    select?: ltextdataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ltextdataInclude<ExtArgs> | null
    /**
     * Filter, which ltextdata to fetch.
     */
    where?: ltextdataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ltextdata to fetch.
     */
    orderBy?: Enumerable<ltextdataOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ltextdata.
     */
    cursor?: ltextdataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ltextdata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ltextdata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ltextdata.
     */
    distinct?: Enumerable<LtextdataScalarFieldEnum>
  }


  /**
   * ltextdata findMany
   */
  export type ltextdataFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ltextdata
     */
    select?: ltextdataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ltextdataInclude<ExtArgs> | null
    /**
     * Filter, which ltextdata to fetch.
     */
    where?: ltextdataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ltextdata to fetch.
     */
    orderBy?: Enumerable<ltextdataOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ltextdata.
     */
    cursor?: ltextdataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ltextdata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ltextdata.
     */
    skip?: number
    distinct?: Enumerable<LtextdataScalarFieldEnum>
  }


  /**
   * ltextdata create
   */
  export type ltextdataCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ltextdata
     */
    select?: ltextdataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ltextdataInclude<ExtArgs> | null
    /**
     * The data needed to create a ltextdata.
     */
    data?: XOR<ltextdataCreateInput, ltextdataUncheckedCreateInput>
  }


  /**
   * ltextdata createMany
   */
  export type ltextdataCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ltextdata.
     */
    data: Enumerable<ltextdataCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ltextdata update
   */
  export type ltextdataUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ltextdata
     */
    select?: ltextdataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ltextdataInclude<ExtArgs> | null
    /**
     * The data needed to update a ltextdata.
     */
    data: XOR<ltextdataUpdateInput, ltextdataUncheckedUpdateInput>
    /**
     * Choose, which ltextdata to update.
     */
    where: ltextdataWhereUniqueInput
  }


  /**
   * ltextdata updateMany
   */
  export type ltextdataUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ltextdata.
     */
    data: XOR<ltextdataUpdateManyMutationInput, ltextdataUncheckedUpdateManyInput>
    /**
     * Filter which ltextdata to update
     */
    where?: ltextdataWhereInput
  }


  /**
   * ltextdata upsert
   */
  export type ltextdataUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ltextdata
     */
    select?: ltextdataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ltextdataInclude<ExtArgs> | null
    /**
     * The filter to search for the ltextdata to update in case it exists.
     */
    where: ltextdataWhereUniqueInput
    /**
     * In case the ltextdata found by the `where` argument doesn't exist, create a new ltextdata with this data.
     */
    create: XOR<ltextdataCreateInput, ltextdataUncheckedCreateInput>
    /**
     * In case the ltextdata was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ltextdataUpdateInput, ltextdataUncheckedUpdateInput>
  }


  /**
   * ltextdata delete
   */
  export type ltextdataDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ltextdata
     */
    select?: ltextdataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ltextdataInclude<ExtArgs> | null
    /**
     * Filter which ltextdata to delete.
     */
    where: ltextdataWhereUniqueInput
  }


  /**
   * ltextdata deleteMany
   */
  export type ltextdataDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ltextdata to delete
     */
    where?: ltextdataWhereInput
  }


  /**
   * ltextdata.ltextversedata
   */
  export type ltextdata$ltextversedataArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ltextversedata
     */
    select?: ltextversedataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ltextversedataInclude<ExtArgs> | null
    where?: ltextversedataWhereInput
    orderBy?: Enumerable<ltextversedataOrderByWithRelationInput>
    cursor?: ltextversedataWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<LtextversedataScalarFieldEnum>
  }


  /**
   * ltextdata without action
   */
  export type ltextdataArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ltextdata
     */
    select?: ltextdataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ltextdataInclude<ExtArgs> | null
  }



  /**
   * Model ltextversedata
   */


  export type AggregateLtextversedata = {
    _count: LtextversedataCountAggregateOutputType | null
    _avg: LtextversedataAvgAggregateOutputType | null
    _sum: LtextversedataSumAggregateOutputType | null
    _min: LtextversedataMinAggregateOutputType | null
    _max: LtextversedataMaxAggregateOutputType | null
  }

  export type LtextversedataAvgAggregateOutputType = {
    id: number | null
    ltext_id: number | null
  }

  export type LtextversedataSumAggregateOutputType = {
    id: number | null
    ltext_id: number | null
  }

  export type LtextversedataMinAggregateOutputType = {
    id: number | null
    ltext_id: number | null
    verse: string | null
  }

  export type LtextversedataMaxAggregateOutputType = {
    id: number | null
    ltext_id: number | null
    verse: string | null
  }

  export type LtextversedataCountAggregateOutputType = {
    id: number
    ltext_id: number
    verse: number
    _all: number
  }


  export type LtextversedataAvgAggregateInputType = {
    id?: true
    ltext_id?: true
  }

  export type LtextversedataSumAggregateInputType = {
    id?: true
    ltext_id?: true
  }

  export type LtextversedataMinAggregateInputType = {
    id?: true
    ltext_id?: true
    verse?: true
  }

  export type LtextversedataMaxAggregateInputType = {
    id?: true
    ltext_id?: true
    verse?: true
  }

  export type LtextversedataCountAggregateInputType = {
    id?: true
    ltext_id?: true
    verse?: true
    _all?: true
  }

  export type LtextversedataAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ltextversedata to aggregate.
     */
    where?: ltextversedataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ltextversedata to fetch.
     */
    orderBy?: Enumerable<ltextversedataOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ltextversedataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ltextversedata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ltextversedata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ltextversedata
    **/
    _count?: true | LtextversedataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LtextversedataAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LtextversedataSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LtextversedataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LtextversedataMaxAggregateInputType
  }

  export type GetLtextversedataAggregateType<T extends LtextversedataAggregateArgs> = {
        [P in keyof T & keyof AggregateLtextversedata]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLtextversedata[P]>
      : GetScalarType<T[P], AggregateLtextversedata[P]>
  }




  export type LtextversedataGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ltextversedataWhereInput
    orderBy?: Enumerable<ltextversedataOrderByWithAggregationInput>
    by: LtextversedataScalarFieldEnum[]
    having?: ltextversedataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LtextversedataCountAggregateInputType | true
    _avg?: LtextversedataAvgAggregateInputType
    _sum?: LtextversedataSumAggregateInputType
    _min?: LtextversedataMinAggregateInputType
    _max?: LtextversedataMaxAggregateInputType
  }


  export type LtextversedataGroupByOutputType = {
    id: number
    ltext_id: number
    verse: string | null
    _count: LtextversedataCountAggregateOutputType | null
    _avg: LtextversedataAvgAggregateOutputType | null
    _sum: LtextversedataSumAggregateOutputType | null
    _min: LtextversedataMinAggregateOutputType | null
    _max: LtextversedataMaxAggregateOutputType | null
  }

  type GetLtextversedataGroupByPayload<T extends LtextversedataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<LtextversedataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LtextversedataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LtextversedataGroupByOutputType[P]>
            : GetScalarType<T[P], LtextversedataGroupByOutputType[P]>
        }
      >
    >


  export type ltextversedataSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ltext_id?: boolean
    verse?: boolean
    ltextdata?: boolean | ltextdataArgs<ExtArgs>
  }, ExtArgs["result"]["ltextversedata"]>

  export type ltextversedataSelectScalar = {
    id?: boolean
    ltext_id?: boolean
    verse?: boolean
  }

  export type ltextversedataInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    ltextdata?: boolean | ltextdataArgs<ExtArgs>
  }


  type ltextversedataGetPayload<S extends boolean | null | undefined | ltextversedataArgs> = $Types.GetResult<ltextversedataPayload, S>

  type ltextversedataCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ltextversedataFindManyArgs, 'select' | 'include'> & {
      select?: LtextversedataCountAggregateInputType | true
    }

  export interface ltextversedataDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ltextversedata'], meta: { name: 'ltextversedata' } }
    /**
     * Find zero or one Ltextversedata that matches the filter.
     * @param {ltextversedataFindUniqueArgs} args - Arguments to find a Ltextversedata
     * @example
     * // Get one Ltextversedata
     * const ltextversedata = await prisma.ltextversedata.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ltextversedataFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ltextversedataFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ltextversedata'> extends True ? Prisma__ltextversedataClient<$Types.GetResult<ltextversedataPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ltextversedataClient<$Types.GetResult<ltextversedataPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Ltextversedata that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ltextversedataFindUniqueOrThrowArgs} args - Arguments to find a Ltextversedata
     * @example
     * // Get one Ltextversedata
     * const ltextversedata = await prisma.ltextversedata.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ltextversedataFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ltextversedataFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ltextversedataClient<$Types.GetResult<ltextversedataPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Ltextversedata that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ltextversedataFindFirstArgs} args - Arguments to find a Ltextversedata
     * @example
     * // Get one Ltextversedata
     * const ltextversedata = await prisma.ltextversedata.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ltextversedataFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ltextversedataFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ltextversedata'> extends True ? Prisma__ltextversedataClient<$Types.GetResult<ltextversedataPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ltextversedataClient<$Types.GetResult<ltextversedataPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Ltextversedata that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ltextversedataFindFirstOrThrowArgs} args - Arguments to find a Ltextversedata
     * @example
     * // Get one Ltextversedata
     * const ltextversedata = await prisma.ltextversedata.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ltextversedataFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ltextversedataFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ltextversedataClient<$Types.GetResult<ltextversedataPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Ltextversedata that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ltextversedataFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ltextversedata
     * const ltextversedata = await prisma.ltextversedata.findMany()
     * 
     * // Get first 10 Ltextversedata
     * const ltextversedata = await prisma.ltextversedata.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ltextversedataWithIdOnly = await prisma.ltextversedata.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ltextversedataFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ltextversedataFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ltextversedataPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Ltextversedata.
     * @param {ltextversedataCreateArgs} args - Arguments to create a Ltextversedata.
     * @example
     * // Create one Ltextversedata
     * const Ltextversedata = await prisma.ltextversedata.create({
     *   data: {
     *     // ... data to create a Ltextversedata
     *   }
     * })
     * 
    **/
    create<T extends ltextversedataCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ltextversedataCreateArgs<ExtArgs>>
    ): Prisma__ltextversedataClient<$Types.GetResult<ltextversedataPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Ltextversedata.
     *     @param {ltextversedataCreateManyArgs} args - Arguments to create many Ltextversedata.
     *     @example
     *     // Create many Ltextversedata
     *     const ltextversedata = await prisma.ltextversedata.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ltextversedataCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ltextversedataCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Ltextversedata.
     * @param {ltextversedataDeleteArgs} args - Arguments to delete one Ltextversedata.
     * @example
     * // Delete one Ltextversedata
     * const Ltextversedata = await prisma.ltextversedata.delete({
     *   where: {
     *     // ... filter to delete one Ltextversedata
     *   }
     * })
     * 
    **/
    delete<T extends ltextversedataDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ltextversedataDeleteArgs<ExtArgs>>
    ): Prisma__ltextversedataClient<$Types.GetResult<ltextversedataPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Ltextversedata.
     * @param {ltextversedataUpdateArgs} args - Arguments to update one Ltextversedata.
     * @example
     * // Update one Ltextversedata
     * const ltextversedata = await prisma.ltextversedata.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ltextversedataUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ltextversedataUpdateArgs<ExtArgs>>
    ): Prisma__ltextversedataClient<$Types.GetResult<ltextversedataPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Ltextversedata.
     * @param {ltextversedataDeleteManyArgs} args - Arguments to filter Ltextversedata to delete.
     * @example
     * // Delete a few Ltextversedata
     * const { count } = await prisma.ltextversedata.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ltextversedataDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ltextversedataDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ltextversedata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ltextversedataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ltextversedata
     * const ltextversedata = await prisma.ltextversedata.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ltextversedataUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ltextversedataUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ltextversedata.
     * @param {ltextversedataUpsertArgs} args - Arguments to update or create a Ltextversedata.
     * @example
     * // Update or create a Ltextversedata
     * const ltextversedata = await prisma.ltextversedata.upsert({
     *   create: {
     *     // ... data to create a Ltextversedata
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ltextversedata we want to update
     *   }
     * })
    **/
    upsert<T extends ltextversedataUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ltextversedataUpsertArgs<ExtArgs>>
    ): Prisma__ltextversedataClient<$Types.GetResult<ltextversedataPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Ltextversedata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ltextversedataCountArgs} args - Arguments to filter Ltextversedata to count.
     * @example
     * // Count the number of Ltextversedata
     * const count = await prisma.ltextversedata.count({
     *   where: {
     *     // ... the filter for the Ltextversedata we want to count
     *   }
     * })
    **/
    count<T extends ltextversedataCountArgs>(
      args?: Subset<T, ltextversedataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LtextversedataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ltextversedata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LtextversedataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LtextversedataAggregateArgs>(args: Subset<T, LtextversedataAggregateArgs>): Prisma.PrismaPromise<GetLtextversedataAggregateType<T>>

    /**
     * Group by Ltextversedata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LtextversedataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LtextversedataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LtextversedataGroupByArgs['orderBy'] }
        : { orderBy?: LtextversedataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LtextversedataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLtextversedataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ltextversedata.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ltextversedataClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    ltextdata<T extends ltextdataArgs<ExtArgs> = {}>(args?: Subset<T, ltextdataArgs<ExtArgs>>): Prisma__ltextdataClient<$Types.GetResult<ltextdataPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ltextversedata base type for findUnique actions
   */
  export type ltextversedataFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ltextversedata
     */
    select?: ltextversedataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ltextversedataInclude<ExtArgs> | null
    /**
     * Filter, which ltextversedata to fetch.
     */
    where: ltextversedataWhereUniqueInput
  }

  /**
   * ltextversedata findUnique
   */
  export interface ltextversedataFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ltextversedataFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ltextversedata findUniqueOrThrow
   */
  export type ltextversedataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ltextversedata
     */
    select?: ltextversedataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ltextversedataInclude<ExtArgs> | null
    /**
     * Filter, which ltextversedata to fetch.
     */
    where: ltextversedataWhereUniqueInput
  }


  /**
   * ltextversedata base type for findFirst actions
   */
  export type ltextversedataFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ltextversedata
     */
    select?: ltextversedataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ltextversedataInclude<ExtArgs> | null
    /**
     * Filter, which ltextversedata to fetch.
     */
    where?: ltextversedataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ltextversedata to fetch.
     */
    orderBy?: Enumerable<ltextversedataOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ltextversedata.
     */
    cursor?: ltextversedataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ltextversedata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ltextversedata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ltextversedata.
     */
    distinct?: Enumerable<LtextversedataScalarFieldEnum>
  }

  /**
   * ltextversedata findFirst
   */
  export interface ltextversedataFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ltextversedataFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ltextversedata findFirstOrThrow
   */
  export type ltextversedataFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ltextversedata
     */
    select?: ltextversedataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ltextversedataInclude<ExtArgs> | null
    /**
     * Filter, which ltextversedata to fetch.
     */
    where?: ltextversedataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ltextversedata to fetch.
     */
    orderBy?: Enumerable<ltextversedataOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ltextversedata.
     */
    cursor?: ltextversedataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ltextversedata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ltextversedata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ltextversedata.
     */
    distinct?: Enumerable<LtextversedataScalarFieldEnum>
  }


  /**
   * ltextversedata findMany
   */
  export type ltextversedataFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ltextversedata
     */
    select?: ltextversedataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ltextversedataInclude<ExtArgs> | null
    /**
     * Filter, which ltextversedata to fetch.
     */
    where?: ltextversedataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ltextversedata to fetch.
     */
    orderBy?: Enumerable<ltextversedataOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ltextversedata.
     */
    cursor?: ltextversedataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ltextversedata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ltextversedata.
     */
    skip?: number
    distinct?: Enumerable<LtextversedataScalarFieldEnum>
  }


  /**
   * ltextversedata create
   */
  export type ltextversedataCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ltextversedata
     */
    select?: ltextversedataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ltextversedataInclude<ExtArgs> | null
    /**
     * The data needed to create a ltextversedata.
     */
    data: XOR<ltextversedataCreateInput, ltextversedataUncheckedCreateInput>
  }


  /**
   * ltextversedata createMany
   */
  export type ltextversedataCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ltextversedata.
     */
    data: Enumerable<ltextversedataCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ltextversedata update
   */
  export type ltextversedataUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ltextversedata
     */
    select?: ltextversedataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ltextversedataInclude<ExtArgs> | null
    /**
     * The data needed to update a ltextversedata.
     */
    data: XOR<ltextversedataUpdateInput, ltextversedataUncheckedUpdateInput>
    /**
     * Choose, which ltextversedata to update.
     */
    where: ltextversedataWhereUniqueInput
  }


  /**
   * ltextversedata updateMany
   */
  export type ltextversedataUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ltextversedata.
     */
    data: XOR<ltextversedataUpdateManyMutationInput, ltextversedataUncheckedUpdateManyInput>
    /**
     * Filter which ltextversedata to update
     */
    where?: ltextversedataWhereInput
  }


  /**
   * ltextversedata upsert
   */
  export type ltextversedataUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ltextversedata
     */
    select?: ltextversedataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ltextversedataInclude<ExtArgs> | null
    /**
     * The filter to search for the ltextversedata to update in case it exists.
     */
    where: ltextversedataWhereUniqueInput
    /**
     * In case the ltextversedata found by the `where` argument doesn't exist, create a new ltextversedata with this data.
     */
    create: XOR<ltextversedataCreateInput, ltextversedataUncheckedCreateInput>
    /**
     * In case the ltextversedata was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ltextversedataUpdateInput, ltextversedataUncheckedUpdateInput>
  }


  /**
   * ltextversedata delete
   */
  export type ltextversedataDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ltextversedata
     */
    select?: ltextversedataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ltextversedataInclude<ExtArgs> | null
    /**
     * Filter which ltextversedata to delete.
     */
    where: ltextversedataWhereUniqueInput
  }


  /**
   * ltextversedata deleteMany
   */
  export type ltextversedataDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ltextversedata to delete
     */
    where?: ltextversedataWhereInput
  }


  /**
   * ltextversedata without action
   */
  export type ltextversedataArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ltextversedata
     */
    select?: ltextversedataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ltextversedataInclude<ExtArgs> | null
  }



  /**
   * Model offering_goals
   */


  export type AggregateOffering_goals = {
    _count: Offering_goalsCountAggregateOutputType | null
    _avg: Offering_goalsAvgAggregateOutputType | null
    _sum: Offering_goalsSumAggregateOutputType | null
    _min: Offering_goalsMinAggregateOutputType | null
    _max: Offering_goalsMaxAggregateOutputType | null
  }

  export type Offering_goalsAvgAggregateOutputType = {
    id: number | null
    target_id: number | null
    amount: Decimal | null
  }

  export type Offering_goalsSumAggregateOutputType = {
    id: number | null
    target_id: number | null
    amount: Decimal | null
  }

  export type Offering_goalsMinAggregateOutputType = {
    id: number | null
    target_id: number | null
    name: string | null
    description: string | null
    amount: Decimal | null
    is_default: boolean | null
  }

  export type Offering_goalsMaxAggregateOutputType = {
    id: number | null
    target_id: number | null
    name: string | null
    description: string | null
    amount: Decimal | null
    is_default: boolean | null
  }

  export type Offering_goalsCountAggregateOutputType = {
    id: number
    target_id: number
    name: number
    description: number
    amount: number
    is_default: number
    _all: number
  }


  export type Offering_goalsAvgAggregateInputType = {
    id?: true
    target_id?: true
    amount?: true
  }

  export type Offering_goalsSumAggregateInputType = {
    id?: true
    target_id?: true
    amount?: true
  }

  export type Offering_goalsMinAggregateInputType = {
    id?: true
    target_id?: true
    name?: true
    description?: true
    amount?: true
    is_default?: true
  }

  export type Offering_goalsMaxAggregateInputType = {
    id?: true
    target_id?: true
    name?: true
    description?: true
    amount?: true
    is_default?: true
  }

  export type Offering_goalsCountAggregateInputType = {
    id?: true
    target_id?: true
    name?: true
    description?: true
    amount?: true
    is_default?: true
    _all?: true
  }

  export type Offering_goalsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which offering_goals to aggregate.
     */
    where?: offering_goalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of offering_goals to fetch.
     */
    orderBy?: Enumerable<offering_goalsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: offering_goalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` offering_goals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` offering_goals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned offering_goals
    **/
    _count?: true | Offering_goalsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Offering_goalsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Offering_goalsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Offering_goalsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Offering_goalsMaxAggregateInputType
  }

  export type GetOffering_goalsAggregateType<T extends Offering_goalsAggregateArgs> = {
        [P in keyof T & keyof AggregateOffering_goals]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOffering_goals[P]>
      : GetScalarType<T[P], AggregateOffering_goals[P]>
  }




  export type Offering_goalsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: offering_goalsWhereInput
    orderBy?: Enumerable<offering_goalsOrderByWithAggregationInput>
    by: Offering_goalsScalarFieldEnum[]
    having?: offering_goalsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Offering_goalsCountAggregateInputType | true
    _avg?: Offering_goalsAvgAggregateInputType
    _sum?: Offering_goalsSumAggregateInputType
    _min?: Offering_goalsMinAggregateInputType
    _max?: Offering_goalsMaxAggregateInputType
  }


  export type Offering_goalsGroupByOutputType = {
    id: number
    target_id: number
    name: string | null
    description: string | null
    amount: Decimal | null
    is_default: boolean | null
    _count: Offering_goalsCountAggregateOutputType | null
    _avg: Offering_goalsAvgAggregateOutputType | null
    _sum: Offering_goalsSumAggregateOutputType | null
    _min: Offering_goalsMinAggregateOutputType | null
    _max: Offering_goalsMaxAggregateOutputType | null
  }

  type GetOffering_goalsGroupByPayload<T extends Offering_goalsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Offering_goalsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Offering_goalsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Offering_goalsGroupByOutputType[P]>
            : GetScalarType<T[P], Offering_goalsGroupByOutputType[P]>
        }
      >
    >


  export type offering_goalsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    target_id?: boolean
    name?: boolean
    description?: boolean
    amount?: boolean
    is_default?: boolean
    collected_offerings?: boolean | offering_goals$collected_offeringsArgs<ExtArgs>
    offering_targets?: boolean | offering_targetsArgs<ExtArgs>
    _count?: boolean | Offering_goalsCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["offering_goals"]>

  export type offering_goalsSelectScalar = {
    id?: boolean
    target_id?: boolean
    name?: boolean
    description?: boolean
    amount?: boolean
    is_default?: boolean
  }

  export type offering_goalsInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    collected_offerings?: boolean | offering_goals$collected_offeringsArgs<ExtArgs>
    offering_targets?: boolean | offering_targetsArgs<ExtArgs>
    _count?: boolean | Offering_goalsCountOutputTypeArgs<ExtArgs>
  }


  type offering_goalsGetPayload<S extends boolean | null | undefined | offering_goalsArgs> = $Types.GetResult<offering_goalsPayload, S>

  type offering_goalsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<offering_goalsFindManyArgs, 'select' | 'include'> & {
      select?: Offering_goalsCountAggregateInputType | true
    }

  export interface offering_goalsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['offering_goals'], meta: { name: 'offering_goals' } }
    /**
     * Find zero or one Offering_goals that matches the filter.
     * @param {offering_goalsFindUniqueArgs} args - Arguments to find a Offering_goals
     * @example
     * // Get one Offering_goals
     * const offering_goals = await prisma.offering_goals.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends offering_goalsFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, offering_goalsFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'offering_goals'> extends True ? Prisma__offering_goalsClient<$Types.GetResult<offering_goalsPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__offering_goalsClient<$Types.GetResult<offering_goalsPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Offering_goals that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {offering_goalsFindUniqueOrThrowArgs} args - Arguments to find a Offering_goals
     * @example
     * // Get one Offering_goals
     * const offering_goals = await prisma.offering_goals.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends offering_goalsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, offering_goalsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__offering_goalsClient<$Types.GetResult<offering_goalsPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Offering_goals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {offering_goalsFindFirstArgs} args - Arguments to find a Offering_goals
     * @example
     * // Get one Offering_goals
     * const offering_goals = await prisma.offering_goals.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends offering_goalsFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, offering_goalsFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'offering_goals'> extends True ? Prisma__offering_goalsClient<$Types.GetResult<offering_goalsPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__offering_goalsClient<$Types.GetResult<offering_goalsPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Offering_goals that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {offering_goalsFindFirstOrThrowArgs} args - Arguments to find a Offering_goals
     * @example
     * // Get one Offering_goals
     * const offering_goals = await prisma.offering_goals.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends offering_goalsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, offering_goalsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__offering_goalsClient<$Types.GetResult<offering_goalsPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Offering_goals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {offering_goalsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Offering_goals
     * const offering_goals = await prisma.offering_goals.findMany()
     * 
     * // Get first 10 Offering_goals
     * const offering_goals = await prisma.offering_goals.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const offering_goalsWithIdOnly = await prisma.offering_goals.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends offering_goalsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, offering_goalsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<offering_goalsPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Offering_goals.
     * @param {offering_goalsCreateArgs} args - Arguments to create a Offering_goals.
     * @example
     * // Create one Offering_goals
     * const Offering_goals = await prisma.offering_goals.create({
     *   data: {
     *     // ... data to create a Offering_goals
     *   }
     * })
     * 
    **/
    create<T extends offering_goalsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, offering_goalsCreateArgs<ExtArgs>>
    ): Prisma__offering_goalsClient<$Types.GetResult<offering_goalsPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Offering_goals.
     *     @param {offering_goalsCreateManyArgs} args - Arguments to create many Offering_goals.
     *     @example
     *     // Create many Offering_goals
     *     const offering_goals = await prisma.offering_goals.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends offering_goalsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, offering_goalsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Offering_goals.
     * @param {offering_goalsDeleteArgs} args - Arguments to delete one Offering_goals.
     * @example
     * // Delete one Offering_goals
     * const Offering_goals = await prisma.offering_goals.delete({
     *   where: {
     *     // ... filter to delete one Offering_goals
     *   }
     * })
     * 
    **/
    delete<T extends offering_goalsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, offering_goalsDeleteArgs<ExtArgs>>
    ): Prisma__offering_goalsClient<$Types.GetResult<offering_goalsPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Offering_goals.
     * @param {offering_goalsUpdateArgs} args - Arguments to update one Offering_goals.
     * @example
     * // Update one Offering_goals
     * const offering_goals = await prisma.offering_goals.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends offering_goalsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, offering_goalsUpdateArgs<ExtArgs>>
    ): Prisma__offering_goalsClient<$Types.GetResult<offering_goalsPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Offering_goals.
     * @param {offering_goalsDeleteManyArgs} args - Arguments to filter Offering_goals to delete.
     * @example
     * // Delete a few Offering_goals
     * const { count } = await prisma.offering_goals.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends offering_goalsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, offering_goalsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Offering_goals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {offering_goalsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Offering_goals
     * const offering_goals = await prisma.offering_goals.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends offering_goalsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, offering_goalsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Offering_goals.
     * @param {offering_goalsUpsertArgs} args - Arguments to update or create a Offering_goals.
     * @example
     * // Update or create a Offering_goals
     * const offering_goals = await prisma.offering_goals.upsert({
     *   create: {
     *     // ... data to create a Offering_goals
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Offering_goals we want to update
     *   }
     * })
    **/
    upsert<T extends offering_goalsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, offering_goalsUpsertArgs<ExtArgs>>
    ): Prisma__offering_goalsClient<$Types.GetResult<offering_goalsPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Offering_goals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {offering_goalsCountArgs} args - Arguments to filter Offering_goals to count.
     * @example
     * // Count the number of Offering_goals
     * const count = await prisma.offering_goals.count({
     *   where: {
     *     // ... the filter for the Offering_goals we want to count
     *   }
     * })
    **/
    count<T extends offering_goalsCountArgs>(
      args?: Subset<T, offering_goalsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Offering_goalsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Offering_goals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Offering_goalsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Offering_goalsAggregateArgs>(args: Subset<T, Offering_goalsAggregateArgs>): Prisma.PrismaPromise<GetOffering_goalsAggregateType<T>>

    /**
     * Group by Offering_goals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Offering_goalsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Offering_goalsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Offering_goalsGroupByArgs['orderBy'] }
        : { orderBy?: Offering_goalsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Offering_goalsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOffering_goalsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for offering_goals.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__offering_goalsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    collected_offerings<T extends offering_goals$collected_offeringsArgs<ExtArgs> = {}>(args?: Subset<T, offering_goals$collected_offeringsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<collected_offeringsPayload<ExtArgs>, T, 'findMany', never>| Null>;

    offering_targets<T extends offering_targetsArgs<ExtArgs> = {}>(args?: Subset<T, offering_targetsArgs<ExtArgs>>): Prisma__offering_targetsClient<$Types.GetResult<offering_targetsPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * offering_goals base type for findUnique actions
   */
  export type offering_goalsFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the offering_goals
     */
    select?: offering_goalsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: offering_goalsInclude<ExtArgs> | null
    /**
     * Filter, which offering_goals to fetch.
     */
    where: offering_goalsWhereUniqueInput
  }

  /**
   * offering_goals findUnique
   */
  export interface offering_goalsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends offering_goalsFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * offering_goals findUniqueOrThrow
   */
  export type offering_goalsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the offering_goals
     */
    select?: offering_goalsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: offering_goalsInclude<ExtArgs> | null
    /**
     * Filter, which offering_goals to fetch.
     */
    where: offering_goalsWhereUniqueInput
  }


  /**
   * offering_goals base type for findFirst actions
   */
  export type offering_goalsFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the offering_goals
     */
    select?: offering_goalsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: offering_goalsInclude<ExtArgs> | null
    /**
     * Filter, which offering_goals to fetch.
     */
    where?: offering_goalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of offering_goals to fetch.
     */
    orderBy?: Enumerable<offering_goalsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for offering_goals.
     */
    cursor?: offering_goalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` offering_goals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` offering_goals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of offering_goals.
     */
    distinct?: Enumerable<Offering_goalsScalarFieldEnum>
  }

  /**
   * offering_goals findFirst
   */
  export interface offering_goalsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends offering_goalsFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * offering_goals findFirstOrThrow
   */
  export type offering_goalsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the offering_goals
     */
    select?: offering_goalsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: offering_goalsInclude<ExtArgs> | null
    /**
     * Filter, which offering_goals to fetch.
     */
    where?: offering_goalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of offering_goals to fetch.
     */
    orderBy?: Enumerable<offering_goalsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for offering_goals.
     */
    cursor?: offering_goalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` offering_goals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` offering_goals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of offering_goals.
     */
    distinct?: Enumerable<Offering_goalsScalarFieldEnum>
  }


  /**
   * offering_goals findMany
   */
  export type offering_goalsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the offering_goals
     */
    select?: offering_goalsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: offering_goalsInclude<ExtArgs> | null
    /**
     * Filter, which offering_goals to fetch.
     */
    where?: offering_goalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of offering_goals to fetch.
     */
    orderBy?: Enumerable<offering_goalsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing offering_goals.
     */
    cursor?: offering_goalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` offering_goals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` offering_goals.
     */
    skip?: number
    distinct?: Enumerable<Offering_goalsScalarFieldEnum>
  }


  /**
   * offering_goals create
   */
  export type offering_goalsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the offering_goals
     */
    select?: offering_goalsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: offering_goalsInclude<ExtArgs> | null
    /**
     * The data needed to create a offering_goals.
     */
    data: XOR<offering_goalsCreateInput, offering_goalsUncheckedCreateInput>
  }


  /**
   * offering_goals createMany
   */
  export type offering_goalsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many offering_goals.
     */
    data: Enumerable<offering_goalsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * offering_goals update
   */
  export type offering_goalsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the offering_goals
     */
    select?: offering_goalsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: offering_goalsInclude<ExtArgs> | null
    /**
     * The data needed to update a offering_goals.
     */
    data: XOR<offering_goalsUpdateInput, offering_goalsUncheckedUpdateInput>
    /**
     * Choose, which offering_goals to update.
     */
    where: offering_goalsWhereUniqueInput
  }


  /**
   * offering_goals updateMany
   */
  export type offering_goalsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update offering_goals.
     */
    data: XOR<offering_goalsUpdateManyMutationInput, offering_goalsUncheckedUpdateManyInput>
    /**
     * Filter which offering_goals to update
     */
    where?: offering_goalsWhereInput
  }


  /**
   * offering_goals upsert
   */
  export type offering_goalsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the offering_goals
     */
    select?: offering_goalsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: offering_goalsInclude<ExtArgs> | null
    /**
     * The filter to search for the offering_goals to update in case it exists.
     */
    where: offering_goalsWhereUniqueInput
    /**
     * In case the offering_goals found by the `where` argument doesn't exist, create a new offering_goals with this data.
     */
    create: XOR<offering_goalsCreateInput, offering_goalsUncheckedCreateInput>
    /**
     * In case the offering_goals was found with the provided `where` argument, update it with this data.
     */
    update: XOR<offering_goalsUpdateInput, offering_goalsUncheckedUpdateInput>
  }


  /**
   * offering_goals delete
   */
  export type offering_goalsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the offering_goals
     */
    select?: offering_goalsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: offering_goalsInclude<ExtArgs> | null
    /**
     * Filter which offering_goals to delete.
     */
    where: offering_goalsWhereUniqueInput
  }


  /**
   * offering_goals deleteMany
   */
  export type offering_goalsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which offering_goals to delete
     */
    where?: offering_goalsWhereInput
  }


  /**
   * offering_goals.collected_offerings
   */
  export type offering_goals$collected_offeringsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collected_offerings
     */
    select?: collected_offeringsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: collected_offeringsInclude<ExtArgs> | null
    where?: collected_offeringsWhereInput
    orderBy?: Enumerable<collected_offeringsOrderByWithRelationInput>
    cursor?: collected_offeringsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Collected_offeringsScalarFieldEnum>
  }


  /**
   * offering_goals without action
   */
  export type offering_goalsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the offering_goals
     */
    select?: offering_goalsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: offering_goalsInclude<ExtArgs> | null
  }



  /**
   * Model offering_targets
   */


  export type AggregateOffering_targets = {
    _count: Offering_targetsCountAggregateOutputType | null
    _avg: Offering_targetsAvgAggregateOutputType | null
    _sum: Offering_targetsSumAggregateOutputType | null
    _min: Offering_targetsMinAggregateOutputType | null
    _max: Offering_targetsMaxAggregateOutputType | null
  }

  export type Offering_targetsAvgAggregateOutputType = {
    id: number | null
  }

  export type Offering_targetsSumAggregateOutputType = {
    id: number | null
  }

  export type Offering_targetsMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
  }

  export type Offering_targetsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
  }

  export type Offering_targetsCountAggregateOutputType = {
    id: number
    name: number
    description: number
    _all: number
  }


  export type Offering_targetsAvgAggregateInputType = {
    id?: true
  }

  export type Offering_targetsSumAggregateInputType = {
    id?: true
  }

  export type Offering_targetsMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type Offering_targetsMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type Offering_targetsCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    _all?: true
  }

  export type Offering_targetsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which offering_targets to aggregate.
     */
    where?: offering_targetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of offering_targets to fetch.
     */
    orderBy?: Enumerable<offering_targetsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: offering_targetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` offering_targets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` offering_targets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned offering_targets
    **/
    _count?: true | Offering_targetsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Offering_targetsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Offering_targetsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Offering_targetsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Offering_targetsMaxAggregateInputType
  }

  export type GetOffering_targetsAggregateType<T extends Offering_targetsAggregateArgs> = {
        [P in keyof T & keyof AggregateOffering_targets]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOffering_targets[P]>
      : GetScalarType<T[P], AggregateOffering_targets[P]>
  }




  export type Offering_targetsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: offering_targetsWhereInput
    orderBy?: Enumerable<offering_targetsOrderByWithAggregationInput>
    by: Offering_targetsScalarFieldEnum[]
    having?: offering_targetsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Offering_targetsCountAggregateInputType | true
    _avg?: Offering_targetsAvgAggregateInputType
    _sum?: Offering_targetsSumAggregateInputType
    _min?: Offering_targetsMinAggregateInputType
    _max?: Offering_targetsMaxAggregateInputType
  }


  export type Offering_targetsGroupByOutputType = {
    id: number
    name: string | null
    description: string | null
    _count: Offering_targetsCountAggregateOutputType | null
    _avg: Offering_targetsAvgAggregateOutputType | null
    _sum: Offering_targetsSumAggregateOutputType | null
    _min: Offering_targetsMinAggregateOutputType | null
    _max: Offering_targetsMaxAggregateOutputType | null
  }

  type GetOffering_targetsGroupByPayload<T extends Offering_targetsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Offering_targetsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Offering_targetsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Offering_targetsGroupByOutputType[P]>
            : GetScalarType<T[P], Offering_targetsGroupByOutputType[P]>
        }
      >
    >


  export type offering_targetsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    offering_goals?: boolean | offering_targets$offering_goalsArgs<ExtArgs>
    _count?: boolean | Offering_targetsCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["offering_targets"]>

  export type offering_targetsSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
  }

  export type offering_targetsInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    offering_goals?: boolean | offering_targets$offering_goalsArgs<ExtArgs>
    _count?: boolean | Offering_targetsCountOutputTypeArgs<ExtArgs>
  }


  type offering_targetsGetPayload<S extends boolean | null | undefined | offering_targetsArgs> = $Types.GetResult<offering_targetsPayload, S>

  type offering_targetsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<offering_targetsFindManyArgs, 'select' | 'include'> & {
      select?: Offering_targetsCountAggregateInputType | true
    }

  export interface offering_targetsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['offering_targets'], meta: { name: 'offering_targets' } }
    /**
     * Find zero or one Offering_targets that matches the filter.
     * @param {offering_targetsFindUniqueArgs} args - Arguments to find a Offering_targets
     * @example
     * // Get one Offering_targets
     * const offering_targets = await prisma.offering_targets.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends offering_targetsFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, offering_targetsFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'offering_targets'> extends True ? Prisma__offering_targetsClient<$Types.GetResult<offering_targetsPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__offering_targetsClient<$Types.GetResult<offering_targetsPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Offering_targets that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {offering_targetsFindUniqueOrThrowArgs} args - Arguments to find a Offering_targets
     * @example
     * // Get one Offering_targets
     * const offering_targets = await prisma.offering_targets.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends offering_targetsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, offering_targetsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__offering_targetsClient<$Types.GetResult<offering_targetsPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Offering_targets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {offering_targetsFindFirstArgs} args - Arguments to find a Offering_targets
     * @example
     * // Get one Offering_targets
     * const offering_targets = await prisma.offering_targets.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends offering_targetsFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, offering_targetsFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'offering_targets'> extends True ? Prisma__offering_targetsClient<$Types.GetResult<offering_targetsPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__offering_targetsClient<$Types.GetResult<offering_targetsPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Offering_targets that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {offering_targetsFindFirstOrThrowArgs} args - Arguments to find a Offering_targets
     * @example
     * // Get one Offering_targets
     * const offering_targets = await prisma.offering_targets.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends offering_targetsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, offering_targetsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__offering_targetsClient<$Types.GetResult<offering_targetsPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Offering_targets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {offering_targetsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Offering_targets
     * const offering_targets = await prisma.offering_targets.findMany()
     * 
     * // Get first 10 Offering_targets
     * const offering_targets = await prisma.offering_targets.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const offering_targetsWithIdOnly = await prisma.offering_targets.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends offering_targetsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, offering_targetsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<offering_targetsPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Offering_targets.
     * @param {offering_targetsCreateArgs} args - Arguments to create a Offering_targets.
     * @example
     * // Create one Offering_targets
     * const Offering_targets = await prisma.offering_targets.create({
     *   data: {
     *     // ... data to create a Offering_targets
     *   }
     * })
     * 
    **/
    create<T extends offering_targetsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, offering_targetsCreateArgs<ExtArgs>>
    ): Prisma__offering_targetsClient<$Types.GetResult<offering_targetsPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Offering_targets.
     *     @param {offering_targetsCreateManyArgs} args - Arguments to create many Offering_targets.
     *     @example
     *     // Create many Offering_targets
     *     const offering_targets = await prisma.offering_targets.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends offering_targetsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, offering_targetsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Offering_targets.
     * @param {offering_targetsDeleteArgs} args - Arguments to delete one Offering_targets.
     * @example
     * // Delete one Offering_targets
     * const Offering_targets = await prisma.offering_targets.delete({
     *   where: {
     *     // ... filter to delete one Offering_targets
     *   }
     * })
     * 
    **/
    delete<T extends offering_targetsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, offering_targetsDeleteArgs<ExtArgs>>
    ): Prisma__offering_targetsClient<$Types.GetResult<offering_targetsPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Offering_targets.
     * @param {offering_targetsUpdateArgs} args - Arguments to update one Offering_targets.
     * @example
     * // Update one Offering_targets
     * const offering_targets = await prisma.offering_targets.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends offering_targetsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, offering_targetsUpdateArgs<ExtArgs>>
    ): Prisma__offering_targetsClient<$Types.GetResult<offering_targetsPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Offering_targets.
     * @param {offering_targetsDeleteManyArgs} args - Arguments to filter Offering_targets to delete.
     * @example
     * // Delete a few Offering_targets
     * const { count } = await prisma.offering_targets.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends offering_targetsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, offering_targetsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Offering_targets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {offering_targetsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Offering_targets
     * const offering_targets = await prisma.offering_targets.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends offering_targetsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, offering_targetsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Offering_targets.
     * @param {offering_targetsUpsertArgs} args - Arguments to update or create a Offering_targets.
     * @example
     * // Update or create a Offering_targets
     * const offering_targets = await prisma.offering_targets.upsert({
     *   create: {
     *     // ... data to create a Offering_targets
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Offering_targets we want to update
     *   }
     * })
    **/
    upsert<T extends offering_targetsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, offering_targetsUpsertArgs<ExtArgs>>
    ): Prisma__offering_targetsClient<$Types.GetResult<offering_targetsPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Offering_targets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {offering_targetsCountArgs} args - Arguments to filter Offering_targets to count.
     * @example
     * // Count the number of Offering_targets
     * const count = await prisma.offering_targets.count({
     *   where: {
     *     // ... the filter for the Offering_targets we want to count
     *   }
     * })
    **/
    count<T extends offering_targetsCountArgs>(
      args?: Subset<T, offering_targetsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Offering_targetsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Offering_targets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Offering_targetsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Offering_targetsAggregateArgs>(args: Subset<T, Offering_targetsAggregateArgs>): Prisma.PrismaPromise<GetOffering_targetsAggregateType<T>>

    /**
     * Group by Offering_targets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Offering_targetsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Offering_targetsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Offering_targetsGroupByArgs['orderBy'] }
        : { orderBy?: Offering_targetsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Offering_targetsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOffering_targetsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for offering_targets.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__offering_targetsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    offering_goals<T extends offering_targets$offering_goalsArgs<ExtArgs> = {}>(args?: Subset<T, offering_targets$offering_goalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<offering_goalsPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * offering_targets base type for findUnique actions
   */
  export type offering_targetsFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the offering_targets
     */
    select?: offering_targetsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: offering_targetsInclude<ExtArgs> | null
    /**
     * Filter, which offering_targets to fetch.
     */
    where: offering_targetsWhereUniqueInput
  }

  /**
   * offering_targets findUnique
   */
  export interface offering_targetsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends offering_targetsFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * offering_targets findUniqueOrThrow
   */
  export type offering_targetsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the offering_targets
     */
    select?: offering_targetsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: offering_targetsInclude<ExtArgs> | null
    /**
     * Filter, which offering_targets to fetch.
     */
    where: offering_targetsWhereUniqueInput
  }


  /**
   * offering_targets base type for findFirst actions
   */
  export type offering_targetsFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the offering_targets
     */
    select?: offering_targetsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: offering_targetsInclude<ExtArgs> | null
    /**
     * Filter, which offering_targets to fetch.
     */
    where?: offering_targetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of offering_targets to fetch.
     */
    orderBy?: Enumerable<offering_targetsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for offering_targets.
     */
    cursor?: offering_targetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` offering_targets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` offering_targets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of offering_targets.
     */
    distinct?: Enumerable<Offering_targetsScalarFieldEnum>
  }

  /**
   * offering_targets findFirst
   */
  export interface offering_targetsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends offering_targetsFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * offering_targets findFirstOrThrow
   */
  export type offering_targetsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the offering_targets
     */
    select?: offering_targetsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: offering_targetsInclude<ExtArgs> | null
    /**
     * Filter, which offering_targets to fetch.
     */
    where?: offering_targetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of offering_targets to fetch.
     */
    orderBy?: Enumerable<offering_targetsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for offering_targets.
     */
    cursor?: offering_targetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` offering_targets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` offering_targets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of offering_targets.
     */
    distinct?: Enumerable<Offering_targetsScalarFieldEnum>
  }


  /**
   * offering_targets findMany
   */
  export type offering_targetsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the offering_targets
     */
    select?: offering_targetsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: offering_targetsInclude<ExtArgs> | null
    /**
     * Filter, which offering_targets to fetch.
     */
    where?: offering_targetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of offering_targets to fetch.
     */
    orderBy?: Enumerable<offering_targetsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing offering_targets.
     */
    cursor?: offering_targetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` offering_targets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` offering_targets.
     */
    skip?: number
    distinct?: Enumerable<Offering_targetsScalarFieldEnum>
  }


  /**
   * offering_targets create
   */
  export type offering_targetsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the offering_targets
     */
    select?: offering_targetsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: offering_targetsInclude<ExtArgs> | null
    /**
     * The data needed to create a offering_targets.
     */
    data?: XOR<offering_targetsCreateInput, offering_targetsUncheckedCreateInput>
  }


  /**
   * offering_targets createMany
   */
  export type offering_targetsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many offering_targets.
     */
    data: Enumerable<offering_targetsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * offering_targets update
   */
  export type offering_targetsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the offering_targets
     */
    select?: offering_targetsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: offering_targetsInclude<ExtArgs> | null
    /**
     * The data needed to update a offering_targets.
     */
    data: XOR<offering_targetsUpdateInput, offering_targetsUncheckedUpdateInput>
    /**
     * Choose, which offering_targets to update.
     */
    where: offering_targetsWhereUniqueInput
  }


  /**
   * offering_targets updateMany
   */
  export type offering_targetsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update offering_targets.
     */
    data: XOR<offering_targetsUpdateManyMutationInput, offering_targetsUncheckedUpdateManyInput>
    /**
     * Filter which offering_targets to update
     */
    where?: offering_targetsWhereInput
  }


  /**
   * offering_targets upsert
   */
  export type offering_targetsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the offering_targets
     */
    select?: offering_targetsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: offering_targetsInclude<ExtArgs> | null
    /**
     * The filter to search for the offering_targets to update in case it exists.
     */
    where: offering_targetsWhereUniqueInput
    /**
     * In case the offering_targets found by the `where` argument doesn't exist, create a new offering_targets with this data.
     */
    create: XOR<offering_targetsCreateInput, offering_targetsUncheckedCreateInput>
    /**
     * In case the offering_targets was found with the provided `where` argument, update it with this data.
     */
    update: XOR<offering_targetsUpdateInput, offering_targetsUncheckedUpdateInput>
  }


  /**
   * offering_targets delete
   */
  export type offering_targetsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the offering_targets
     */
    select?: offering_targetsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: offering_targetsInclude<ExtArgs> | null
    /**
     * Filter which offering_targets to delete.
     */
    where: offering_targetsWhereUniqueInput
  }


  /**
   * offering_targets deleteMany
   */
  export type offering_targetsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which offering_targets to delete
     */
    where?: offering_targetsWhereInput
  }


  /**
   * offering_targets.offering_goals
   */
  export type offering_targets$offering_goalsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the offering_goals
     */
    select?: offering_goalsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: offering_goalsInclude<ExtArgs> | null
    where?: offering_goalsWhereInput
    orderBy?: Enumerable<offering_goalsOrderByWithRelationInput>
    cursor?: offering_goalsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Offering_goalsScalarFieldEnum>
  }


  /**
   * offering_targets without action
   */
  export type offering_targetsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the offering_targets
     */
    select?: offering_targetsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: offering_targetsInclude<ExtArgs> | null
  }



  /**
   * Model presentation_content
   */


  export type AggregatePresentation_content = {
    _count: Presentation_contentCountAggregateOutputType | null
    _avg: Presentation_contentAvgAggregateOutputType | null
    _sum: Presentation_contentSumAggregateOutputType | null
    _min: Presentation_contentMinAggregateOutputType | null
    _max: Presentation_contentMaxAggregateOutputType | null
  }

  export type Presentation_contentAvgAggregateOutputType = {
    id: number | null
    slot_id: number | null
  }

  export type Presentation_contentSumAggregateOutputType = {
    id: number | null
    slot_id: number | null
  }

  export type Presentation_contentMinAggregateOutputType = {
    id: number | null
    slot_id: number | null
    content_type: string | null
    new_slide: string | null
    content: string | null
  }

  export type Presentation_contentMaxAggregateOutputType = {
    id: number | null
    slot_id: number | null
    content_type: string | null
    new_slide: string | null
    content: string | null
  }

  export type Presentation_contentCountAggregateOutputType = {
    id: number
    slot_id: number
    content_type: number
    new_slide: number
    content: number
    _all: number
  }


  export type Presentation_contentAvgAggregateInputType = {
    id?: true
    slot_id?: true
  }

  export type Presentation_contentSumAggregateInputType = {
    id?: true
    slot_id?: true
  }

  export type Presentation_contentMinAggregateInputType = {
    id?: true
    slot_id?: true
    content_type?: true
    new_slide?: true
    content?: true
  }

  export type Presentation_contentMaxAggregateInputType = {
    id?: true
    slot_id?: true
    content_type?: true
    new_slide?: true
    content?: true
  }

  export type Presentation_contentCountAggregateInputType = {
    id?: true
    slot_id?: true
    content_type?: true
    new_slide?: true
    content?: true
    _all?: true
  }

  export type Presentation_contentAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which presentation_content to aggregate.
     */
    where?: presentation_contentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of presentation_contents to fetch.
     */
    orderBy?: Enumerable<presentation_contentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: presentation_contentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` presentation_contents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` presentation_contents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned presentation_contents
    **/
    _count?: true | Presentation_contentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Presentation_contentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Presentation_contentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Presentation_contentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Presentation_contentMaxAggregateInputType
  }

  export type GetPresentation_contentAggregateType<T extends Presentation_contentAggregateArgs> = {
        [P in keyof T & keyof AggregatePresentation_content]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePresentation_content[P]>
      : GetScalarType<T[P], AggregatePresentation_content[P]>
  }




  export type Presentation_contentGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: presentation_contentWhereInput
    orderBy?: Enumerable<presentation_contentOrderByWithAggregationInput>
    by: Presentation_contentScalarFieldEnum[]
    having?: presentation_contentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Presentation_contentCountAggregateInputType | true
    _avg?: Presentation_contentAvgAggregateInputType
    _sum?: Presentation_contentSumAggregateInputType
    _min?: Presentation_contentMinAggregateInputType
    _max?: Presentation_contentMaxAggregateInputType
  }


  export type Presentation_contentGroupByOutputType = {
    id: number
    slot_id: number
    content_type: string | null
    new_slide: string | null
    content: string | null
    _count: Presentation_contentCountAggregateOutputType | null
    _avg: Presentation_contentAvgAggregateOutputType | null
    _sum: Presentation_contentSumAggregateOutputType | null
    _min: Presentation_contentMinAggregateOutputType | null
    _max: Presentation_contentMaxAggregateOutputType | null
  }

  type GetPresentation_contentGroupByPayload<T extends Presentation_contentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Presentation_contentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Presentation_contentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Presentation_contentGroupByOutputType[P]>
            : GetScalarType<T[P], Presentation_contentGroupByOutputType[P]>
        }
      >
    >


  export type presentation_contentSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slot_id?: boolean
    content_type?: boolean
    new_slide?: boolean
    content?: boolean
    presentation_structure?: boolean | presentation_structureArgs<ExtArgs>
  }, ExtArgs["result"]["presentation_content"]>

  export type presentation_contentSelectScalar = {
    id?: boolean
    slot_id?: boolean
    content_type?: boolean
    new_slide?: boolean
    content?: boolean
  }

  export type presentation_contentInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    presentation_structure?: boolean | presentation_structureArgs<ExtArgs>
  }


  type presentation_contentGetPayload<S extends boolean | null | undefined | presentation_contentArgs> = $Types.GetResult<presentation_contentPayload, S>

  type presentation_contentCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<presentation_contentFindManyArgs, 'select' | 'include'> & {
      select?: Presentation_contentCountAggregateInputType | true
    }

  export interface presentation_contentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['presentation_content'], meta: { name: 'presentation_content' } }
    /**
     * Find zero or one Presentation_content that matches the filter.
     * @param {presentation_contentFindUniqueArgs} args - Arguments to find a Presentation_content
     * @example
     * // Get one Presentation_content
     * const presentation_content = await prisma.presentation_content.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends presentation_contentFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, presentation_contentFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'presentation_content'> extends True ? Prisma__presentation_contentClient<$Types.GetResult<presentation_contentPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__presentation_contentClient<$Types.GetResult<presentation_contentPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Presentation_content that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {presentation_contentFindUniqueOrThrowArgs} args - Arguments to find a Presentation_content
     * @example
     * // Get one Presentation_content
     * const presentation_content = await prisma.presentation_content.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends presentation_contentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, presentation_contentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__presentation_contentClient<$Types.GetResult<presentation_contentPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Presentation_content that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {presentation_contentFindFirstArgs} args - Arguments to find a Presentation_content
     * @example
     * // Get one Presentation_content
     * const presentation_content = await prisma.presentation_content.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends presentation_contentFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, presentation_contentFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'presentation_content'> extends True ? Prisma__presentation_contentClient<$Types.GetResult<presentation_contentPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__presentation_contentClient<$Types.GetResult<presentation_contentPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Presentation_content that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {presentation_contentFindFirstOrThrowArgs} args - Arguments to find a Presentation_content
     * @example
     * // Get one Presentation_content
     * const presentation_content = await prisma.presentation_content.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends presentation_contentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, presentation_contentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__presentation_contentClient<$Types.GetResult<presentation_contentPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Presentation_contents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {presentation_contentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Presentation_contents
     * const presentation_contents = await prisma.presentation_content.findMany()
     * 
     * // Get first 10 Presentation_contents
     * const presentation_contents = await prisma.presentation_content.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const presentation_contentWithIdOnly = await prisma.presentation_content.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends presentation_contentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, presentation_contentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<presentation_contentPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Presentation_content.
     * @param {presentation_contentCreateArgs} args - Arguments to create a Presentation_content.
     * @example
     * // Create one Presentation_content
     * const Presentation_content = await prisma.presentation_content.create({
     *   data: {
     *     // ... data to create a Presentation_content
     *   }
     * })
     * 
    **/
    create<T extends presentation_contentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, presentation_contentCreateArgs<ExtArgs>>
    ): Prisma__presentation_contentClient<$Types.GetResult<presentation_contentPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Presentation_contents.
     *     @param {presentation_contentCreateManyArgs} args - Arguments to create many Presentation_contents.
     *     @example
     *     // Create many Presentation_contents
     *     const presentation_content = await prisma.presentation_content.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends presentation_contentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, presentation_contentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Presentation_content.
     * @param {presentation_contentDeleteArgs} args - Arguments to delete one Presentation_content.
     * @example
     * // Delete one Presentation_content
     * const Presentation_content = await prisma.presentation_content.delete({
     *   where: {
     *     // ... filter to delete one Presentation_content
     *   }
     * })
     * 
    **/
    delete<T extends presentation_contentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, presentation_contentDeleteArgs<ExtArgs>>
    ): Prisma__presentation_contentClient<$Types.GetResult<presentation_contentPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Presentation_content.
     * @param {presentation_contentUpdateArgs} args - Arguments to update one Presentation_content.
     * @example
     * // Update one Presentation_content
     * const presentation_content = await prisma.presentation_content.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends presentation_contentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, presentation_contentUpdateArgs<ExtArgs>>
    ): Prisma__presentation_contentClient<$Types.GetResult<presentation_contentPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Presentation_contents.
     * @param {presentation_contentDeleteManyArgs} args - Arguments to filter Presentation_contents to delete.
     * @example
     * // Delete a few Presentation_contents
     * const { count } = await prisma.presentation_content.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends presentation_contentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, presentation_contentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Presentation_contents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {presentation_contentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Presentation_contents
     * const presentation_content = await prisma.presentation_content.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends presentation_contentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, presentation_contentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Presentation_content.
     * @param {presentation_contentUpsertArgs} args - Arguments to update or create a Presentation_content.
     * @example
     * // Update or create a Presentation_content
     * const presentation_content = await prisma.presentation_content.upsert({
     *   create: {
     *     // ... data to create a Presentation_content
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Presentation_content we want to update
     *   }
     * })
    **/
    upsert<T extends presentation_contentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, presentation_contentUpsertArgs<ExtArgs>>
    ): Prisma__presentation_contentClient<$Types.GetResult<presentation_contentPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Presentation_contents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {presentation_contentCountArgs} args - Arguments to filter Presentation_contents to count.
     * @example
     * // Count the number of Presentation_contents
     * const count = await prisma.presentation_content.count({
     *   where: {
     *     // ... the filter for the Presentation_contents we want to count
     *   }
     * })
    **/
    count<T extends presentation_contentCountArgs>(
      args?: Subset<T, presentation_contentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Presentation_contentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Presentation_content.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Presentation_contentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Presentation_contentAggregateArgs>(args: Subset<T, Presentation_contentAggregateArgs>): Prisma.PrismaPromise<GetPresentation_contentAggregateType<T>>

    /**
     * Group by Presentation_content.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Presentation_contentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Presentation_contentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Presentation_contentGroupByArgs['orderBy'] }
        : { orderBy?: Presentation_contentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Presentation_contentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPresentation_contentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for presentation_content.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__presentation_contentClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    presentation_structure<T extends presentation_structureArgs<ExtArgs> = {}>(args?: Subset<T, presentation_structureArgs<ExtArgs>>): Prisma__presentation_structureClient<$Types.GetResult<presentation_structurePayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * presentation_content base type for findUnique actions
   */
  export type presentation_contentFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the presentation_content
     */
    select?: presentation_contentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: presentation_contentInclude<ExtArgs> | null
    /**
     * Filter, which presentation_content to fetch.
     */
    where: presentation_contentWhereUniqueInput
  }

  /**
   * presentation_content findUnique
   */
  export interface presentation_contentFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends presentation_contentFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * presentation_content findUniqueOrThrow
   */
  export type presentation_contentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the presentation_content
     */
    select?: presentation_contentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: presentation_contentInclude<ExtArgs> | null
    /**
     * Filter, which presentation_content to fetch.
     */
    where: presentation_contentWhereUniqueInput
  }


  /**
   * presentation_content base type for findFirst actions
   */
  export type presentation_contentFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the presentation_content
     */
    select?: presentation_contentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: presentation_contentInclude<ExtArgs> | null
    /**
     * Filter, which presentation_content to fetch.
     */
    where?: presentation_contentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of presentation_contents to fetch.
     */
    orderBy?: Enumerable<presentation_contentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for presentation_contents.
     */
    cursor?: presentation_contentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` presentation_contents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` presentation_contents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of presentation_contents.
     */
    distinct?: Enumerable<Presentation_contentScalarFieldEnum>
  }

  /**
   * presentation_content findFirst
   */
  export interface presentation_contentFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends presentation_contentFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * presentation_content findFirstOrThrow
   */
  export type presentation_contentFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the presentation_content
     */
    select?: presentation_contentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: presentation_contentInclude<ExtArgs> | null
    /**
     * Filter, which presentation_content to fetch.
     */
    where?: presentation_contentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of presentation_contents to fetch.
     */
    orderBy?: Enumerable<presentation_contentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for presentation_contents.
     */
    cursor?: presentation_contentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` presentation_contents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` presentation_contents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of presentation_contents.
     */
    distinct?: Enumerable<Presentation_contentScalarFieldEnum>
  }


  /**
   * presentation_content findMany
   */
  export type presentation_contentFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the presentation_content
     */
    select?: presentation_contentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: presentation_contentInclude<ExtArgs> | null
    /**
     * Filter, which presentation_contents to fetch.
     */
    where?: presentation_contentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of presentation_contents to fetch.
     */
    orderBy?: Enumerable<presentation_contentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing presentation_contents.
     */
    cursor?: presentation_contentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` presentation_contents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` presentation_contents.
     */
    skip?: number
    distinct?: Enumerable<Presentation_contentScalarFieldEnum>
  }


  /**
   * presentation_content create
   */
  export type presentation_contentCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the presentation_content
     */
    select?: presentation_contentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: presentation_contentInclude<ExtArgs> | null
    /**
     * The data needed to create a presentation_content.
     */
    data: XOR<presentation_contentCreateInput, presentation_contentUncheckedCreateInput>
  }


  /**
   * presentation_content createMany
   */
  export type presentation_contentCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many presentation_contents.
     */
    data: Enumerable<presentation_contentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * presentation_content update
   */
  export type presentation_contentUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the presentation_content
     */
    select?: presentation_contentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: presentation_contentInclude<ExtArgs> | null
    /**
     * The data needed to update a presentation_content.
     */
    data: XOR<presentation_contentUpdateInput, presentation_contentUncheckedUpdateInput>
    /**
     * Choose, which presentation_content to update.
     */
    where: presentation_contentWhereUniqueInput
  }


  /**
   * presentation_content updateMany
   */
  export type presentation_contentUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update presentation_contents.
     */
    data: XOR<presentation_contentUpdateManyMutationInput, presentation_contentUncheckedUpdateManyInput>
    /**
     * Filter which presentation_contents to update
     */
    where?: presentation_contentWhereInput
  }


  /**
   * presentation_content upsert
   */
  export type presentation_contentUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the presentation_content
     */
    select?: presentation_contentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: presentation_contentInclude<ExtArgs> | null
    /**
     * The filter to search for the presentation_content to update in case it exists.
     */
    where: presentation_contentWhereUniqueInput
    /**
     * In case the presentation_content found by the `where` argument doesn't exist, create a new presentation_content with this data.
     */
    create: XOR<presentation_contentCreateInput, presentation_contentUncheckedCreateInput>
    /**
     * In case the presentation_content was found with the provided `where` argument, update it with this data.
     */
    update: XOR<presentation_contentUpdateInput, presentation_contentUncheckedUpdateInput>
  }


  /**
   * presentation_content delete
   */
  export type presentation_contentDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the presentation_content
     */
    select?: presentation_contentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: presentation_contentInclude<ExtArgs> | null
    /**
     * Filter which presentation_content to delete.
     */
    where: presentation_contentWhereUniqueInput
  }


  /**
   * presentation_content deleteMany
   */
  export type presentation_contentDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which presentation_contents to delete
     */
    where?: presentation_contentWhereInput
  }


  /**
   * presentation_content without action
   */
  export type presentation_contentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the presentation_content
     */
    select?: presentation_contentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: presentation_contentInclude<ExtArgs> | null
  }



  /**
   * Model presentation_structure
   */


  export type AggregatePresentation_structure = {
    _count: Presentation_structureCountAggregateOutputType | null
    _avg: Presentation_structureAvgAggregateOutputType | null
    _sum: Presentation_structureSumAggregateOutputType | null
    _min: Presentation_structureMinAggregateOutputType | null
    _max: Presentation_structureMaxAggregateOutputType | null
  }

  export type Presentation_structureAvgAggregateOutputType = {
    id: number | null
    service_id: number | null
    slot_number: number | null
    header_id: number | null
    content_id: number | null
  }

  export type Presentation_structureSumAggregateOutputType = {
    id: number | null
    service_id: number | null
    slot_number: number | null
    header_id: number | null
    content_id: number | null
  }

  export type Presentation_structureMinAggregateOutputType = {
    id: number | null
    service_id: number | null
    slot_name: string | null
    slot_number: number | null
    slot_type: string | null
    id_in_type_table: string | null
    addedclass: string | null
    header_id: number | null
    content_id: number | null
    instruction: string | null
  }

  export type Presentation_structureMaxAggregateOutputType = {
    id: number | null
    service_id: number | null
    slot_name: string | null
    slot_number: number | null
    slot_type: string | null
    id_in_type_table: string | null
    addedclass: string | null
    header_id: number | null
    content_id: number | null
    instruction: string | null
  }

  export type Presentation_structureCountAggregateOutputType = {
    id: number
    service_id: number
    slot_name: number
    slot_number: number
    slot_type: number
    id_in_type_table: number
    addedclass: number
    header_id: number
    content_id: number
    instruction: number
    _all: number
  }


  export type Presentation_structureAvgAggregateInputType = {
    id?: true
    service_id?: true
    slot_number?: true
    header_id?: true
    content_id?: true
  }

  export type Presentation_structureSumAggregateInputType = {
    id?: true
    service_id?: true
    slot_number?: true
    header_id?: true
    content_id?: true
  }

  export type Presentation_structureMinAggregateInputType = {
    id?: true
    service_id?: true
    slot_name?: true
    slot_number?: true
    slot_type?: true
    id_in_type_table?: true
    addedclass?: true
    header_id?: true
    content_id?: true
    instruction?: true
  }

  export type Presentation_structureMaxAggregateInputType = {
    id?: true
    service_id?: true
    slot_name?: true
    slot_number?: true
    slot_type?: true
    id_in_type_table?: true
    addedclass?: true
    header_id?: true
    content_id?: true
    instruction?: true
  }

  export type Presentation_structureCountAggregateInputType = {
    id?: true
    service_id?: true
    slot_name?: true
    slot_number?: true
    slot_type?: true
    id_in_type_table?: true
    addedclass?: true
    header_id?: true
    content_id?: true
    instruction?: true
    _all?: true
  }

  export type Presentation_structureAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which presentation_structure to aggregate.
     */
    where?: presentation_structureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of presentation_structures to fetch.
     */
    orderBy?: Enumerable<presentation_structureOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: presentation_structureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` presentation_structures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` presentation_structures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned presentation_structures
    **/
    _count?: true | Presentation_structureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Presentation_structureAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Presentation_structureSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Presentation_structureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Presentation_structureMaxAggregateInputType
  }

  export type GetPresentation_structureAggregateType<T extends Presentation_structureAggregateArgs> = {
        [P in keyof T & keyof AggregatePresentation_structure]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePresentation_structure[P]>
      : GetScalarType<T[P], AggregatePresentation_structure[P]>
  }




  export type Presentation_structureGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: presentation_structureWhereInput
    orderBy?: Enumerable<presentation_structureOrderByWithAggregationInput>
    by: Presentation_structureScalarFieldEnum[]
    having?: presentation_structureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Presentation_structureCountAggregateInputType | true
    _avg?: Presentation_structureAvgAggregateInputType
    _sum?: Presentation_structureSumAggregateInputType
    _min?: Presentation_structureMinAggregateInputType
    _max?: Presentation_structureMaxAggregateInputType
  }


  export type Presentation_structureGroupByOutputType = {
    id: number
    service_id: number | null
    slot_name: string | null
    slot_number: number | null
    slot_type: string | null
    id_in_type_table: string | null
    addedclass: string | null
    header_id: number | null
    content_id: number
    instruction: string | null
    _count: Presentation_structureCountAggregateOutputType | null
    _avg: Presentation_structureAvgAggregateOutputType | null
    _sum: Presentation_structureSumAggregateOutputType | null
    _min: Presentation_structureMinAggregateOutputType | null
    _max: Presentation_structureMaxAggregateOutputType | null
  }

  type GetPresentation_structureGroupByPayload<T extends Presentation_structureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Presentation_structureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Presentation_structureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Presentation_structureGroupByOutputType[P]>
            : GetScalarType<T[P], Presentation_structureGroupByOutputType[P]>
        }
      >
    >


  export type presentation_structureSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    service_id?: boolean
    slot_name?: boolean
    slot_number?: boolean
    slot_type?: boolean
    id_in_type_table?: boolean
    addedclass?: boolean
    header_id?: boolean
    content_id?: boolean
    instruction?: boolean
    presentation_content?: boolean | presentation_structure$presentation_contentArgs<ExtArgs>
    _count?: boolean | Presentation_structureCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["presentation_structure"]>

  export type presentation_structureSelectScalar = {
    id?: boolean
    service_id?: boolean
    slot_name?: boolean
    slot_number?: boolean
    slot_type?: boolean
    id_in_type_table?: boolean
    addedclass?: boolean
    header_id?: boolean
    content_id?: boolean
    instruction?: boolean
  }

  export type presentation_structureInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    presentation_content?: boolean | presentation_structure$presentation_contentArgs<ExtArgs>
    _count?: boolean | Presentation_structureCountOutputTypeArgs<ExtArgs>
  }


  type presentation_structureGetPayload<S extends boolean | null | undefined | presentation_structureArgs> = $Types.GetResult<presentation_structurePayload, S>

  type presentation_structureCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<presentation_structureFindManyArgs, 'select' | 'include'> & {
      select?: Presentation_structureCountAggregateInputType | true
    }

  export interface presentation_structureDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['presentation_structure'], meta: { name: 'presentation_structure' } }
    /**
     * Find zero or one Presentation_structure that matches the filter.
     * @param {presentation_structureFindUniqueArgs} args - Arguments to find a Presentation_structure
     * @example
     * // Get one Presentation_structure
     * const presentation_structure = await prisma.presentation_structure.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends presentation_structureFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, presentation_structureFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'presentation_structure'> extends True ? Prisma__presentation_structureClient<$Types.GetResult<presentation_structurePayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__presentation_structureClient<$Types.GetResult<presentation_structurePayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Presentation_structure that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {presentation_structureFindUniqueOrThrowArgs} args - Arguments to find a Presentation_structure
     * @example
     * // Get one Presentation_structure
     * const presentation_structure = await prisma.presentation_structure.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends presentation_structureFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, presentation_structureFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__presentation_structureClient<$Types.GetResult<presentation_structurePayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Presentation_structure that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {presentation_structureFindFirstArgs} args - Arguments to find a Presentation_structure
     * @example
     * // Get one Presentation_structure
     * const presentation_structure = await prisma.presentation_structure.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends presentation_structureFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, presentation_structureFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'presentation_structure'> extends True ? Prisma__presentation_structureClient<$Types.GetResult<presentation_structurePayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__presentation_structureClient<$Types.GetResult<presentation_structurePayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Presentation_structure that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {presentation_structureFindFirstOrThrowArgs} args - Arguments to find a Presentation_structure
     * @example
     * // Get one Presentation_structure
     * const presentation_structure = await prisma.presentation_structure.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends presentation_structureFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, presentation_structureFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__presentation_structureClient<$Types.GetResult<presentation_structurePayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Presentation_structures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {presentation_structureFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Presentation_structures
     * const presentation_structures = await prisma.presentation_structure.findMany()
     * 
     * // Get first 10 Presentation_structures
     * const presentation_structures = await prisma.presentation_structure.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const presentation_structureWithIdOnly = await prisma.presentation_structure.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends presentation_structureFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, presentation_structureFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<presentation_structurePayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Presentation_structure.
     * @param {presentation_structureCreateArgs} args - Arguments to create a Presentation_structure.
     * @example
     * // Create one Presentation_structure
     * const Presentation_structure = await prisma.presentation_structure.create({
     *   data: {
     *     // ... data to create a Presentation_structure
     *   }
     * })
     * 
    **/
    create<T extends presentation_structureCreateArgs<ExtArgs>>(
      args: SelectSubset<T, presentation_structureCreateArgs<ExtArgs>>
    ): Prisma__presentation_structureClient<$Types.GetResult<presentation_structurePayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Presentation_structures.
     *     @param {presentation_structureCreateManyArgs} args - Arguments to create many Presentation_structures.
     *     @example
     *     // Create many Presentation_structures
     *     const presentation_structure = await prisma.presentation_structure.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends presentation_structureCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, presentation_structureCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Presentation_structure.
     * @param {presentation_structureDeleteArgs} args - Arguments to delete one Presentation_structure.
     * @example
     * // Delete one Presentation_structure
     * const Presentation_structure = await prisma.presentation_structure.delete({
     *   where: {
     *     // ... filter to delete one Presentation_structure
     *   }
     * })
     * 
    **/
    delete<T extends presentation_structureDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, presentation_structureDeleteArgs<ExtArgs>>
    ): Prisma__presentation_structureClient<$Types.GetResult<presentation_structurePayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Presentation_structure.
     * @param {presentation_structureUpdateArgs} args - Arguments to update one Presentation_structure.
     * @example
     * // Update one Presentation_structure
     * const presentation_structure = await prisma.presentation_structure.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends presentation_structureUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, presentation_structureUpdateArgs<ExtArgs>>
    ): Prisma__presentation_structureClient<$Types.GetResult<presentation_structurePayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Presentation_structures.
     * @param {presentation_structureDeleteManyArgs} args - Arguments to filter Presentation_structures to delete.
     * @example
     * // Delete a few Presentation_structures
     * const { count } = await prisma.presentation_structure.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends presentation_structureDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, presentation_structureDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Presentation_structures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {presentation_structureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Presentation_structures
     * const presentation_structure = await prisma.presentation_structure.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends presentation_structureUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, presentation_structureUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Presentation_structure.
     * @param {presentation_structureUpsertArgs} args - Arguments to update or create a Presentation_structure.
     * @example
     * // Update or create a Presentation_structure
     * const presentation_structure = await prisma.presentation_structure.upsert({
     *   create: {
     *     // ... data to create a Presentation_structure
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Presentation_structure we want to update
     *   }
     * })
    **/
    upsert<T extends presentation_structureUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, presentation_structureUpsertArgs<ExtArgs>>
    ): Prisma__presentation_structureClient<$Types.GetResult<presentation_structurePayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Presentation_structures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {presentation_structureCountArgs} args - Arguments to filter Presentation_structures to count.
     * @example
     * // Count the number of Presentation_structures
     * const count = await prisma.presentation_structure.count({
     *   where: {
     *     // ... the filter for the Presentation_structures we want to count
     *   }
     * })
    **/
    count<T extends presentation_structureCountArgs>(
      args?: Subset<T, presentation_structureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Presentation_structureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Presentation_structure.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Presentation_structureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Presentation_structureAggregateArgs>(args: Subset<T, Presentation_structureAggregateArgs>): Prisma.PrismaPromise<GetPresentation_structureAggregateType<T>>

    /**
     * Group by Presentation_structure.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Presentation_structureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Presentation_structureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Presentation_structureGroupByArgs['orderBy'] }
        : { orderBy?: Presentation_structureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Presentation_structureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPresentation_structureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for presentation_structure.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__presentation_structureClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    presentation_content<T extends presentation_structure$presentation_contentArgs<ExtArgs> = {}>(args?: Subset<T, presentation_structure$presentation_contentArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<presentation_contentPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * presentation_structure base type for findUnique actions
   */
  export type presentation_structureFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the presentation_structure
     */
    select?: presentation_structureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: presentation_structureInclude<ExtArgs> | null
    /**
     * Filter, which presentation_structure to fetch.
     */
    where: presentation_structureWhereUniqueInput
  }

  /**
   * presentation_structure findUnique
   */
  export interface presentation_structureFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends presentation_structureFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * presentation_structure findUniqueOrThrow
   */
  export type presentation_structureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the presentation_structure
     */
    select?: presentation_structureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: presentation_structureInclude<ExtArgs> | null
    /**
     * Filter, which presentation_structure to fetch.
     */
    where: presentation_structureWhereUniqueInput
  }


  /**
   * presentation_structure base type for findFirst actions
   */
  export type presentation_structureFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the presentation_structure
     */
    select?: presentation_structureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: presentation_structureInclude<ExtArgs> | null
    /**
     * Filter, which presentation_structure to fetch.
     */
    where?: presentation_structureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of presentation_structures to fetch.
     */
    orderBy?: Enumerable<presentation_structureOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for presentation_structures.
     */
    cursor?: presentation_structureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` presentation_structures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` presentation_structures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of presentation_structures.
     */
    distinct?: Enumerable<Presentation_structureScalarFieldEnum>
  }

  /**
   * presentation_structure findFirst
   */
  export interface presentation_structureFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends presentation_structureFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * presentation_structure findFirstOrThrow
   */
  export type presentation_structureFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the presentation_structure
     */
    select?: presentation_structureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: presentation_structureInclude<ExtArgs> | null
    /**
     * Filter, which presentation_structure to fetch.
     */
    where?: presentation_structureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of presentation_structures to fetch.
     */
    orderBy?: Enumerable<presentation_structureOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for presentation_structures.
     */
    cursor?: presentation_structureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` presentation_structures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` presentation_structures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of presentation_structures.
     */
    distinct?: Enumerable<Presentation_structureScalarFieldEnum>
  }


  /**
   * presentation_structure findMany
   */
  export type presentation_structureFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the presentation_structure
     */
    select?: presentation_structureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: presentation_structureInclude<ExtArgs> | null
    /**
     * Filter, which presentation_structures to fetch.
     */
    where?: presentation_structureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of presentation_structures to fetch.
     */
    orderBy?: Enumerable<presentation_structureOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing presentation_structures.
     */
    cursor?: presentation_structureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` presentation_structures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` presentation_structures.
     */
    skip?: number
    distinct?: Enumerable<Presentation_structureScalarFieldEnum>
  }


  /**
   * presentation_structure create
   */
  export type presentation_structureCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the presentation_structure
     */
    select?: presentation_structureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: presentation_structureInclude<ExtArgs> | null
    /**
     * The data needed to create a presentation_structure.
     */
    data: XOR<presentation_structureCreateInput, presentation_structureUncheckedCreateInput>
  }


  /**
   * presentation_structure createMany
   */
  export type presentation_structureCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many presentation_structures.
     */
    data: Enumerable<presentation_structureCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * presentation_structure update
   */
  export type presentation_structureUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the presentation_structure
     */
    select?: presentation_structureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: presentation_structureInclude<ExtArgs> | null
    /**
     * The data needed to update a presentation_structure.
     */
    data: XOR<presentation_structureUpdateInput, presentation_structureUncheckedUpdateInput>
    /**
     * Choose, which presentation_structure to update.
     */
    where: presentation_structureWhereUniqueInput
  }


  /**
   * presentation_structure updateMany
   */
  export type presentation_structureUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update presentation_structures.
     */
    data: XOR<presentation_structureUpdateManyMutationInput, presentation_structureUncheckedUpdateManyInput>
    /**
     * Filter which presentation_structures to update
     */
    where?: presentation_structureWhereInput
  }


  /**
   * presentation_structure upsert
   */
  export type presentation_structureUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the presentation_structure
     */
    select?: presentation_structureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: presentation_structureInclude<ExtArgs> | null
    /**
     * The filter to search for the presentation_structure to update in case it exists.
     */
    where: presentation_structureWhereUniqueInput
    /**
     * In case the presentation_structure found by the `where` argument doesn't exist, create a new presentation_structure with this data.
     */
    create: XOR<presentation_structureCreateInput, presentation_structureUncheckedCreateInput>
    /**
     * In case the presentation_structure was found with the provided `where` argument, update it with this data.
     */
    update: XOR<presentation_structureUpdateInput, presentation_structureUncheckedUpdateInput>
  }


  /**
   * presentation_structure delete
   */
  export type presentation_structureDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the presentation_structure
     */
    select?: presentation_structureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: presentation_structureInclude<ExtArgs> | null
    /**
     * Filter which presentation_structure to delete.
     */
    where: presentation_structureWhereUniqueInput
  }


  /**
   * presentation_structure deleteMany
   */
  export type presentation_structureDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which presentation_structures to delete
     */
    where?: presentation_structureWhereInput
  }


  /**
   * presentation_structure.presentation_content
   */
  export type presentation_structure$presentation_contentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the presentation_content
     */
    select?: presentation_contentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: presentation_contentInclude<ExtArgs> | null
    where?: presentation_contentWhereInput
    orderBy?: Enumerable<presentation_contentOrderByWithRelationInput>
    cursor?: presentation_contentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Presentation_contentScalarFieldEnum>
  }


  /**
   * presentation_structure without action
   */
  export type presentation_structureArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the presentation_structure
     */
    select?: presentation_structureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: presentation_structureInclude<ExtArgs> | null
  }



  /**
   * Model responsibilities
   */


  export type AggregateResponsibilities = {
    _count: ResponsibilitiesCountAggregateOutputType | null
    _avg: ResponsibilitiesAvgAggregateOutputType | null
    _sum: ResponsibilitiesSumAggregateOutputType | null
    _min: ResponsibilitiesMinAggregateOutputType | null
    _max: ResponsibilitiesMaxAggregateOutputType | null
  }

  export type ResponsibilitiesAvgAggregateOutputType = {
    id: number | null
    service_id: number | null
  }

  export type ResponsibilitiesSumAggregateOutputType = {
    id: number | null
    service_id: number | null
  }

  export type ResponsibilitiesMinAggregateOutputType = {
    id: number | null
    service_id: number | null
    responsibility: string | null
    responsible: string | null
  }

  export type ResponsibilitiesMaxAggregateOutputType = {
    id: number | null
    service_id: number | null
    responsibility: string | null
    responsible: string | null
  }

  export type ResponsibilitiesCountAggregateOutputType = {
    id: number
    service_id: number
    responsibility: number
    responsible: number
    _all: number
  }


  export type ResponsibilitiesAvgAggregateInputType = {
    id?: true
    service_id?: true
  }

  export type ResponsibilitiesSumAggregateInputType = {
    id?: true
    service_id?: true
  }

  export type ResponsibilitiesMinAggregateInputType = {
    id?: true
    service_id?: true
    responsibility?: true
    responsible?: true
  }

  export type ResponsibilitiesMaxAggregateInputType = {
    id?: true
    service_id?: true
    responsibility?: true
    responsible?: true
  }

  export type ResponsibilitiesCountAggregateInputType = {
    id?: true
    service_id?: true
    responsibility?: true
    responsible?: true
    _all?: true
  }

  export type ResponsibilitiesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which responsibilities to aggregate.
     */
    where?: responsibilitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of responsibilities to fetch.
     */
    orderBy?: Enumerable<responsibilitiesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: responsibilitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` responsibilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` responsibilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned responsibilities
    **/
    _count?: true | ResponsibilitiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ResponsibilitiesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ResponsibilitiesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResponsibilitiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResponsibilitiesMaxAggregateInputType
  }

  export type GetResponsibilitiesAggregateType<T extends ResponsibilitiesAggregateArgs> = {
        [P in keyof T & keyof AggregateResponsibilities]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResponsibilities[P]>
      : GetScalarType<T[P], AggregateResponsibilities[P]>
  }




  export type ResponsibilitiesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: responsibilitiesWhereInput
    orderBy?: Enumerable<responsibilitiesOrderByWithAggregationInput>
    by: ResponsibilitiesScalarFieldEnum[]
    having?: responsibilitiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResponsibilitiesCountAggregateInputType | true
    _avg?: ResponsibilitiesAvgAggregateInputType
    _sum?: ResponsibilitiesSumAggregateInputType
    _min?: ResponsibilitiesMinAggregateInputType
    _max?: ResponsibilitiesMaxAggregateInputType
  }


  export type ResponsibilitiesGroupByOutputType = {
    id: number
    service_id: number
    responsibility: string | null
    responsible: string | null
    _count: ResponsibilitiesCountAggregateOutputType | null
    _avg: ResponsibilitiesAvgAggregateOutputType | null
    _sum: ResponsibilitiesSumAggregateOutputType | null
    _min: ResponsibilitiesMinAggregateOutputType | null
    _max: ResponsibilitiesMaxAggregateOutputType | null
  }

  type GetResponsibilitiesGroupByPayload<T extends ResponsibilitiesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ResponsibilitiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResponsibilitiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResponsibilitiesGroupByOutputType[P]>
            : GetScalarType<T[P], ResponsibilitiesGroupByOutputType[P]>
        }
      >
    >


  export type responsibilitiesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    service_id?: boolean
    responsibility?: boolean
    responsible?: boolean
    services?: boolean | servicesArgs<ExtArgs>
  }, ExtArgs["result"]["responsibilities"]>

  export type responsibilitiesSelectScalar = {
    id?: boolean
    service_id?: boolean
    responsibility?: boolean
    responsible?: boolean
  }

  export type responsibilitiesInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    services?: boolean | servicesArgs<ExtArgs>
  }


  type responsibilitiesGetPayload<S extends boolean | null | undefined | responsibilitiesArgs> = $Types.GetResult<responsibilitiesPayload, S>

  type responsibilitiesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<responsibilitiesFindManyArgs, 'select' | 'include'> & {
      select?: ResponsibilitiesCountAggregateInputType | true
    }

  export interface responsibilitiesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['responsibilities'], meta: { name: 'responsibilities' } }
    /**
     * Find zero or one Responsibilities that matches the filter.
     * @param {responsibilitiesFindUniqueArgs} args - Arguments to find a Responsibilities
     * @example
     * // Get one Responsibilities
     * const responsibilities = await prisma.responsibilities.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends responsibilitiesFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, responsibilitiesFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'responsibilities'> extends True ? Prisma__responsibilitiesClient<$Types.GetResult<responsibilitiesPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__responsibilitiesClient<$Types.GetResult<responsibilitiesPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Responsibilities that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {responsibilitiesFindUniqueOrThrowArgs} args - Arguments to find a Responsibilities
     * @example
     * // Get one Responsibilities
     * const responsibilities = await prisma.responsibilities.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends responsibilitiesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, responsibilitiesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__responsibilitiesClient<$Types.GetResult<responsibilitiesPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Responsibilities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {responsibilitiesFindFirstArgs} args - Arguments to find a Responsibilities
     * @example
     * // Get one Responsibilities
     * const responsibilities = await prisma.responsibilities.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends responsibilitiesFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, responsibilitiesFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'responsibilities'> extends True ? Prisma__responsibilitiesClient<$Types.GetResult<responsibilitiesPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__responsibilitiesClient<$Types.GetResult<responsibilitiesPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Responsibilities that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {responsibilitiesFindFirstOrThrowArgs} args - Arguments to find a Responsibilities
     * @example
     * // Get one Responsibilities
     * const responsibilities = await prisma.responsibilities.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends responsibilitiesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, responsibilitiesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__responsibilitiesClient<$Types.GetResult<responsibilitiesPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Responsibilities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {responsibilitiesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Responsibilities
     * const responsibilities = await prisma.responsibilities.findMany()
     * 
     * // Get first 10 Responsibilities
     * const responsibilities = await prisma.responsibilities.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const responsibilitiesWithIdOnly = await prisma.responsibilities.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends responsibilitiesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, responsibilitiesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<responsibilitiesPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Responsibilities.
     * @param {responsibilitiesCreateArgs} args - Arguments to create a Responsibilities.
     * @example
     * // Create one Responsibilities
     * const Responsibilities = await prisma.responsibilities.create({
     *   data: {
     *     // ... data to create a Responsibilities
     *   }
     * })
     * 
    **/
    create<T extends responsibilitiesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, responsibilitiesCreateArgs<ExtArgs>>
    ): Prisma__responsibilitiesClient<$Types.GetResult<responsibilitiesPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Responsibilities.
     *     @param {responsibilitiesCreateManyArgs} args - Arguments to create many Responsibilities.
     *     @example
     *     // Create many Responsibilities
     *     const responsibilities = await prisma.responsibilities.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends responsibilitiesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, responsibilitiesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Responsibilities.
     * @param {responsibilitiesDeleteArgs} args - Arguments to delete one Responsibilities.
     * @example
     * // Delete one Responsibilities
     * const Responsibilities = await prisma.responsibilities.delete({
     *   where: {
     *     // ... filter to delete one Responsibilities
     *   }
     * })
     * 
    **/
    delete<T extends responsibilitiesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, responsibilitiesDeleteArgs<ExtArgs>>
    ): Prisma__responsibilitiesClient<$Types.GetResult<responsibilitiesPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Responsibilities.
     * @param {responsibilitiesUpdateArgs} args - Arguments to update one Responsibilities.
     * @example
     * // Update one Responsibilities
     * const responsibilities = await prisma.responsibilities.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends responsibilitiesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, responsibilitiesUpdateArgs<ExtArgs>>
    ): Prisma__responsibilitiesClient<$Types.GetResult<responsibilitiesPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Responsibilities.
     * @param {responsibilitiesDeleteManyArgs} args - Arguments to filter Responsibilities to delete.
     * @example
     * // Delete a few Responsibilities
     * const { count } = await prisma.responsibilities.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends responsibilitiesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, responsibilitiesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Responsibilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {responsibilitiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Responsibilities
     * const responsibilities = await prisma.responsibilities.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends responsibilitiesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, responsibilitiesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Responsibilities.
     * @param {responsibilitiesUpsertArgs} args - Arguments to update or create a Responsibilities.
     * @example
     * // Update or create a Responsibilities
     * const responsibilities = await prisma.responsibilities.upsert({
     *   create: {
     *     // ... data to create a Responsibilities
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Responsibilities we want to update
     *   }
     * })
    **/
    upsert<T extends responsibilitiesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, responsibilitiesUpsertArgs<ExtArgs>>
    ): Prisma__responsibilitiesClient<$Types.GetResult<responsibilitiesPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Responsibilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {responsibilitiesCountArgs} args - Arguments to filter Responsibilities to count.
     * @example
     * // Count the number of Responsibilities
     * const count = await prisma.responsibilities.count({
     *   where: {
     *     // ... the filter for the Responsibilities we want to count
     *   }
     * })
    **/
    count<T extends responsibilitiesCountArgs>(
      args?: Subset<T, responsibilitiesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResponsibilitiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Responsibilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResponsibilitiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResponsibilitiesAggregateArgs>(args: Subset<T, ResponsibilitiesAggregateArgs>): Prisma.PrismaPromise<GetResponsibilitiesAggregateType<T>>

    /**
     * Group by Responsibilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResponsibilitiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResponsibilitiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResponsibilitiesGroupByArgs['orderBy'] }
        : { orderBy?: ResponsibilitiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResponsibilitiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResponsibilitiesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for responsibilities.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__responsibilitiesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    services<T extends servicesArgs<ExtArgs> = {}>(args?: Subset<T, servicesArgs<ExtArgs>>): Prisma__servicesClient<$Types.GetResult<servicesPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * responsibilities base type for findUnique actions
   */
  export type responsibilitiesFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the responsibilities
     */
    select?: responsibilitiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: responsibilitiesInclude<ExtArgs> | null
    /**
     * Filter, which responsibilities to fetch.
     */
    where: responsibilitiesWhereUniqueInput
  }

  /**
   * responsibilities findUnique
   */
  export interface responsibilitiesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends responsibilitiesFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * responsibilities findUniqueOrThrow
   */
  export type responsibilitiesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the responsibilities
     */
    select?: responsibilitiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: responsibilitiesInclude<ExtArgs> | null
    /**
     * Filter, which responsibilities to fetch.
     */
    where: responsibilitiesWhereUniqueInput
  }


  /**
   * responsibilities base type for findFirst actions
   */
  export type responsibilitiesFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the responsibilities
     */
    select?: responsibilitiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: responsibilitiesInclude<ExtArgs> | null
    /**
     * Filter, which responsibilities to fetch.
     */
    where?: responsibilitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of responsibilities to fetch.
     */
    orderBy?: Enumerable<responsibilitiesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for responsibilities.
     */
    cursor?: responsibilitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` responsibilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` responsibilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of responsibilities.
     */
    distinct?: Enumerable<ResponsibilitiesScalarFieldEnum>
  }

  /**
   * responsibilities findFirst
   */
  export interface responsibilitiesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends responsibilitiesFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * responsibilities findFirstOrThrow
   */
  export type responsibilitiesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the responsibilities
     */
    select?: responsibilitiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: responsibilitiesInclude<ExtArgs> | null
    /**
     * Filter, which responsibilities to fetch.
     */
    where?: responsibilitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of responsibilities to fetch.
     */
    orderBy?: Enumerable<responsibilitiesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for responsibilities.
     */
    cursor?: responsibilitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` responsibilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` responsibilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of responsibilities.
     */
    distinct?: Enumerable<ResponsibilitiesScalarFieldEnum>
  }


  /**
   * responsibilities findMany
   */
  export type responsibilitiesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the responsibilities
     */
    select?: responsibilitiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: responsibilitiesInclude<ExtArgs> | null
    /**
     * Filter, which responsibilities to fetch.
     */
    where?: responsibilitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of responsibilities to fetch.
     */
    orderBy?: Enumerable<responsibilitiesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing responsibilities.
     */
    cursor?: responsibilitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` responsibilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` responsibilities.
     */
    skip?: number
    distinct?: Enumerable<ResponsibilitiesScalarFieldEnum>
  }


  /**
   * responsibilities create
   */
  export type responsibilitiesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the responsibilities
     */
    select?: responsibilitiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: responsibilitiesInclude<ExtArgs> | null
    /**
     * The data needed to create a responsibilities.
     */
    data: XOR<responsibilitiesCreateInput, responsibilitiesUncheckedCreateInput>
  }


  /**
   * responsibilities createMany
   */
  export type responsibilitiesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many responsibilities.
     */
    data: Enumerable<responsibilitiesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * responsibilities update
   */
  export type responsibilitiesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the responsibilities
     */
    select?: responsibilitiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: responsibilitiesInclude<ExtArgs> | null
    /**
     * The data needed to update a responsibilities.
     */
    data: XOR<responsibilitiesUpdateInput, responsibilitiesUncheckedUpdateInput>
    /**
     * Choose, which responsibilities to update.
     */
    where: responsibilitiesWhereUniqueInput
  }


  /**
   * responsibilities updateMany
   */
  export type responsibilitiesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update responsibilities.
     */
    data: XOR<responsibilitiesUpdateManyMutationInput, responsibilitiesUncheckedUpdateManyInput>
    /**
     * Filter which responsibilities to update
     */
    where?: responsibilitiesWhereInput
  }


  /**
   * responsibilities upsert
   */
  export type responsibilitiesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the responsibilities
     */
    select?: responsibilitiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: responsibilitiesInclude<ExtArgs> | null
    /**
     * The filter to search for the responsibilities to update in case it exists.
     */
    where: responsibilitiesWhereUniqueInput
    /**
     * In case the responsibilities found by the `where` argument doesn't exist, create a new responsibilities with this data.
     */
    create: XOR<responsibilitiesCreateInput, responsibilitiesUncheckedCreateInput>
    /**
     * In case the responsibilities was found with the provided `where` argument, update it with this data.
     */
    update: XOR<responsibilitiesUpdateInput, responsibilitiesUncheckedUpdateInput>
  }


  /**
   * responsibilities delete
   */
  export type responsibilitiesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the responsibilities
     */
    select?: responsibilitiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: responsibilitiesInclude<ExtArgs> | null
    /**
     * Filter which responsibilities to delete.
     */
    where: responsibilitiesWhereUniqueInput
  }


  /**
   * responsibilities deleteMany
   */
  export type responsibilitiesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which responsibilities to delete
     */
    where?: responsibilitiesWhereInput
  }


  /**
   * responsibilities without action
   */
  export type responsibilitiesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the responsibilities
     */
    select?: responsibilitiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: responsibilitiesInclude<ExtArgs> | null
  }



  /**
   * Model responsibilities_meta
   */


  export type AggregateResponsibilities_meta = {
    _count: Responsibilities_metaCountAggregateOutputType | null
    _avg: Responsibilities_metaAvgAggregateOutputType | null
    _sum: Responsibilities_metaSumAggregateOutputType | null
    _min: Responsibilities_metaMinAggregateOutputType | null
    _max: Responsibilities_metaMaxAggregateOutputType | null
  }

  export type Responsibilities_metaAvgAggregateOutputType = {
    id: number | null
  }

  export type Responsibilities_metaSumAggregateOutputType = {
    id: number | null
  }

  export type Responsibilities_metaMinAggregateOutputType = {
    id: number | null
    responsibility: string | null
    description: string | null
  }

  export type Responsibilities_metaMaxAggregateOutputType = {
    id: number | null
    responsibility: string | null
    description: string | null
  }

  export type Responsibilities_metaCountAggregateOutputType = {
    id: number
    responsibility: number
    description: number
    _all: number
  }


  export type Responsibilities_metaAvgAggregateInputType = {
    id?: true
  }

  export type Responsibilities_metaSumAggregateInputType = {
    id?: true
  }

  export type Responsibilities_metaMinAggregateInputType = {
    id?: true
    responsibility?: true
    description?: true
  }

  export type Responsibilities_metaMaxAggregateInputType = {
    id?: true
    responsibility?: true
    description?: true
  }

  export type Responsibilities_metaCountAggregateInputType = {
    id?: true
    responsibility?: true
    description?: true
    _all?: true
  }

  export type Responsibilities_metaAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which responsibilities_meta to aggregate.
     */
    where?: responsibilities_metaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of responsibilities_metas to fetch.
     */
    orderBy?: Enumerable<responsibilities_metaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: responsibilities_metaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` responsibilities_metas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` responsibilities_metas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned responsibilities_metas
    **/
    _count?: true | Responsibilities_metaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Responsibilities_metaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Responsibilities_metaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Responsibilities_metaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Responsibilities_metaMaxAggregateInputType
  }

  export type GetResponsibilities_metaAggregateType<T extends Responsibilities_metaAggregateArgs> = {
        [P in keyof T & keyof AggregateResponsibilities_meta]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResponsibilities_meta[P]>
      : GetScalarType<T[P], AggregateResponsibilities_meta[P]>
  }




  export type Responsibilities_metaGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: responsibilities_metaWhereInput
    orderBy?: Enumerable<responsibilities_metaOrderByWithAggregationInput>
    by: Responsibilities_metaScalarFieldEnum[]
    having?: responsibilities_metaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Responsibilities_metaCountAggregateInputType | true
    _avg?: Responsibilities_metaAvgAggregateInputType
    _sum?: Responsibilities_metaSumAggregateInputType
    _min?: Responsibilities_metaMinAggregateInputType
    _max?: Responsibilities_metaMaxAggregateInputType
  }


  export type Responsibilities_metaGroupByOutputType = {
    id: number
    responsibility: string | null
    description: string | null
    _count: Responsibilities_metaCountAggregateOutputType | null
    _avg: Responsibilities_metaAvgAggregateOutputType | null
    _sum: Responsibilities_metaSumAggregateOutputType | null
    _min: Responsibilities_metaMinAggregateOutputType | null
    _max: Responsibilities_metaMaxAggregateOutputType | null
  }

  type GetResponsibilities_metaGroupByPayload<T extends Responsibilities_metaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Responsibilities_metaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Responsibilities_metaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Responsibilities_metaGroupByOutputType[P]>
            : GetScalarType<T[P], Responsibilities_metaGroupByOutputType[P]>
        }
      >
    >


  export type responsibilities_metaSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    responsibility?: boolean
    description?: boolean
  }, ExtArgs["result"]["responsibilities_meta"]>

  export type responsibilities_metaSelectScalar = {
    id?: boolean
    responsibility?: boolean
    description?: boolean
  }


  type responsibilities_metaGetPayload<S extends boolean | null | undefined | responsibilities_metaArgs> = $Types.GetResult<responsibilities_metaPayload, S>

  type responsibilities_metaCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<responsibilities_metaFindManyArgs, 'select' | 'include'> & {
      select?: Responsibilities_metaCountAggregateInputType | true
    }

  export interface responsibilities_metaDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['responsibilities_meta'], meta: { name: 'responsibilities_meta' } }
    /**
     * Find zero or one Responsibilities_meta that matches the filter.
     * @param {responsibilities_metaFindUniqueArgs} args - Arguments to find a Responsibilities_meta
     * @example
     * // Get one Responsibilities_meta
     * const responsibilities_meta = await prisma.responsibilities_meta.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends responsibilities_metaFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, responsibilities_metaFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'responsibilities_meta'> extends True ? Prisma__responsibilities_metaClient<$Types.GetResult<responsibilities_metaPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__responsibilities_metaClient<$Types.GetResult<responsibilities_metaPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Responsibilities_meta that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {responsibilities_metaFindUniqueOrThrowArgs} args - Arguments to find a Responsibilities_meta
     * @example
     * // Get one Responsibilities_meta
     * const responsibilities_meta = await prisma.responsibilities_meta.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends responsibilities_metaFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, responsibilities_metaFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__responsibilities_metaClient<$Types.GetResult<responsibilities_metaPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Responsibilities_meta that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {responsibilities_metaFindFirstArgs} args - Arguments to find a Responsibilities_meta
     * @example
     * // Get one Responsibilities_meta
     * const responsibilities_meta = await prisma.responsibilities_meta.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends responsibilities_metaFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, responsibilities_metaFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'responsibilities_meta'> extends True ? Prisma__responsibilities_metaClient<$Types.GetResult<responsibilities_metaPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__responsibilities_metaClient<$Types.GetResult<responsibilities_metaPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Responsibilities_meta that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {responsibilities_metaFindFirstOrThrowArgs} args - Arguments to find a Responsibilities_meta
     * @example
     * // Get one Responsibilities_meta
     * const responsibilities_meta = await prisma.responsibilities_meta.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends responsibilities_metaFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, responsibilities_metaFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__responsibilities_metaClient<$Types.GetResult<responsibilities_metaPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Responsibilities_metas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {responsibilities_metaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Responsibilities_metas
     * const responsibilities_metas = await prisma.responsibilities_meta.findMany()
     * 
     * // Get first 10 Responsibilities_metas
     * const responsibilities_metas = await prisma.responsibilities_meta.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const responsibilities_metaWithIdOnly = await prisma.responsibilities_meta.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends responsibilities_metaFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, responsibilities_metaFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<responsibilities_metaPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Responsibilities_meta.
     * @param {responsibilities_metaCreateArgs} args - Arguments to create a Responsibilities_meta.
     * @example
     * // Create one Responsibilities_meta
     * const Responsibilities_meta = await prisma.responsibilities_meta.create({
     *   data: {
     *     // ... data to create a Responsibilities_meta
     *   }
     * })
     * 
    **/
    create<T extends responsibilities_metaCreateArgs<ExtArgs>>(
      args: SelectSubset<T, responsibilities_metaCreateArgs<ExtArgs>>
    ): Prisma__responsibilities_metaClient<$Types.GetResult<responsibilities_metaPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Responsibilities_metas.
     *     @param {responsibilities_metaCreateManyArgs} args - Arguments to create many Responsibilities_metas.
     *     @example
     *     // Create many Responsibilities_metas
     *     const responsibilities_meta = await prisma.responsibilities_meta.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends responsibilities_metaCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, responsibilities_metaCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Responsibilities_meta.
     * @param {responsibilities_metaDeleteArgs} args - Arguments to delete one Responsibilities_meta.
     * @example
     * // Delete one Responsibilities_meta
     * const Responsibilities_meta = await prisma.responsibilities_meta.delete({
     *   where: {
     *     // ... filter to delete one Responsibilities_meta
     *   }
     * })
     * 
    **/
    delete<T extends responsibilities_metaDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, responsibilities_metaDeleteArgs<ExtArgs>>
    ): Prisma__responsibilities_metaClient<$Types.GetResult<responsibilities_metaPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Responsibilities_meta.
     * @param {responsibilities_metaUpdateArgs} args - Arguments to update one Responsibilities_meta.
     * @example
     * // Update one Responsibilities_meta
     * const responsibilities_meta = await prisma.responsibilities_meta.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends responsibilities_metaUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, responsibilities_metaUpdateArgs<ExtArgs>>
    ): Prisma__responsibilities_metaClient<$Types.GetResult<responsibilities_metaPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Responsibilities_metas.
     * @param {responsibilities_metaDeleteManyArgs} args - Arguments to filter Responsibilities_metas to delete.
     * @example
     * // Delete a few Responsibilities_metas
     * const { count } = await prisma.responsibilities_meta.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends responsibilities_metaDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, responsibilities_metaDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Responsibilities_metas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {responsibilities_metaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Responsibilities_metas
     * const responsibilities_meta = await prisma.responsibilities_meta.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends responsibilities_metaUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, responsibilities_metaUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Responsibilities_meta.
     * @param {responsibilities_metaUpsertArgs} args - Arguments to update or create a Responsibilities_meta.
     * @example
     * // Update or create a Responsibilities_meta
     * const responsibilities_meta = await prisma.responsibilities_meta.upsert({
     *   create: {
     *     // ... data to create a Responsibilities_meta
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Responsibilities_meta we want to update
     *   }
     * })
    **/
    upsert<T extends responsibilities_metaUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, responsibilities_metaUpsertArgs<ExtArgs>>
    ): Prisma__responsibilities_metaClient<$Types.GetResult<responsibilities_metaPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Responsibilities_metas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {responsibilities_metaCountArgs} args - Arguments to filter Responsibilities_metas to count.
     * @example
     * // Count the number of Responsibilities_metas
     * const count = await prisma.responsibilities_meta.count({
     *   where: {
     *     // ... the filter for the Responsibilities_metas we want to count
     *   }
     * })
    **/
    count<T extends responsibilities_metaCountArgs>(
      args?: Subset<T, responsibilities_metaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Responsibilities_metaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Responsibilities_meta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Responsibilities_metaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Responsibilities_metaAggregateArgs>(args: Subset<T, Responsibilities_metaAggregateArgs>): Prisma.PrismaPromise<GetResponsibilities_metaAggregateType<T>>

    /**
     * Group by Responsibilities_meta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Responsibilities_metaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Responsibilities_metaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Responsibilities_metaGroupByArgs['orderBy'] }
        : { orderBy?: Responsibilities_metaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Responsibilities_metaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResponsibilities_metaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for responsibilities_meta.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__responsibilities_metaClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * responsibilities_meta base type for findUnique actions
   */
  export type responsibilities_metaFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the responsibilities_meta
     */
    select?: responsibilities_metaSelect<ExtArgs> | null
    /**
     * Filter, which responsibilities_meta to fetch.
     */
    where: responsibilities_metaWhereUniqueInput
  }

  /**
   * responsibilities_meta findUnique
   */
  export interface responsibilities_metaFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends responsibilities_metaFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * responsibilities_meta findUniqueOrThrow
   */
  export type responsibilities_metaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the responsibilities_meta
     */
    select?: responsibilities_metaSelect<ExtArgs> | null
    /**
     * Filter, which responsibilities_meta to fetch.
     */
    where: responsibilities_metaWhereUniqueInput
  }


  /**
   * responsibilities_meta base type for findFirst actions
   */
  export type responsibilities_metaFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the responsibilities_meta
     */
    select?: responsibilities_metaSelect<ExtArgs> | null
    /**
     * Filter, which responsibilities_meta to fetch.
     */
    where?: responsibilities_metaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of responsibilities_metas to fetch.
     */
    orderBy?: Enumerable<responsibilities_metaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for responsibilities_metas.
     */
    cursor?: responsibilities_metaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` responsibilities_metas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` responsibilities_metas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of responsibilities_metas.
     */
    distinct?: Enumerable<Responsibilities_metaScalarFieldEnum>
  }

  /**
   * responsibilities_meta findFirst
   */
  export interface responsibilities_metaFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends responsibilities_metaFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * responsibilities_meta findFirstOrThrow
   */
  export type responsibilities_metaFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the responsibilities_meta
     */
    select?: responsibilities_metaSelect<ExtArgs> | null
    /**
     * Filter, which responsibilities_meta to fetch.
     */
    where?: responsibilities_metaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of responsibilities_metas to fetch.
     */
    orderBy?: Enumerable<responsibilities_metaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for responsibilities_metas.
     */
    cursor?: responsibilities_metaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` responsibilities_metas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` responsibilities_metas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of responsibilities_metas.
     */
    distinct?: Enumerable<Responsibilities_metaScalarFieldEnum>
  }


  /**
   * responsibilities_meta findMany
   */
  export type responsibilities_metaFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the responsibilities_meta
     */
    select?: responsibilities_metaSelect<ExtArgs> | null
    /**
     * Filter, which responsibilities_metas to fetch.
     */
    where?: responsibilities_metaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of responsibilities_metas to fetch.
     */
    orderBy?: Enumerable<responsibilities_metaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing responsibilities_metas.
     */
    cursor?: responsibilities_metaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` responsibilities_metas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` responsibilities_metas.
     */
    skip?: number
    distinct?: Enumerable<Responsibilities_metaScalarFieldEnum>
  }


  /**
   * responsibilities_meta create
   */
  export type responsibilities_metaCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the responsibilities_meta
     */
    select?: responsibilities_metaSelect<ExtArgs> | null
    /**
     * The data needed to create a responsibilities_meta.
     */
    data?: XOR<responsibilities_metaCreateInput, responsibilities_metaUncheckedCreateInput>
  }


  /**
   * responsibilities_meta createMany
   */
  export type responsibilities_metaCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many responsibilities_metas.
     */
    data: Enumerable<responsibilities_metaCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * responsibilities_meta update
   */
  export type responsibilities_metaUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the responsibilities_meta
     */
    select?: responsibilities_metaSelect<ExtArgs> | null
    /**
     * The data needed to update a responsibilities_meta.
     */
    data: XOR<responsibilities_metaUpdateInput, responsibilities_metaUncheckedUpdateInput>
    /**
     * Choose, which responsibilities_meta to update.
     */
    where: responsibilities_metaWhereUniqueInput
  }


  /**
   * responsibilities_meta updateMany
   */
  export type responsibilities_metaUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update responsibilities_metas.
     */
    data: XOR<responsibilities_metaUpdateManyMutationInput, responsibilities_metaUncheckedUpdateManyInput>
    /**
     * Filter which responsibilities_metas to update
     */
    where?: responsibilities_metaWhereInput
  }


  /**
   * responsibilities_meta upsert
   */
  export type responsibilities_metaUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the responsibilities_meta
     */
    select?: responsibilities_metaSelect<ExtArgs> | null
    /**
     * The filter to search for the responsibilities_meta to update in case it exists.
     */
    where: responsibilities_metaWhereUniqueInput
    /**
     * In case the responsibilities_meta found by the `where` argument doesn't exist, create a new responsibilities_meta with this data.
     */
    create: XOR<responsibilities_metaCreateInput, responsibilities_metaUncheckedCreateInput>
    /**
     * In case the responsibilities_meta was found with the provided `where` argument, update it with this data.
     */
    update: XOR<responsibilities_metaUpdateInput, responsibilities_metaUncheckedUpdateInput>
  }


  /**
   * responsibilities_meta delete
   */
  export type responsibilities_metaDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the responsibilities_meta
     */
    select?: responsibilities_metaSelect<ExtArgs> | null
    /**
     * Filter which responsibilities_meta to delete.
     */
    where: responsibilities_metaWhereUniqueInput
  }


  /**
   * responsibilities_meta deleteMany
   */
  export type responsibilities_metaDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which responsibilities_metas to delete
     */
    where?: responsibilities_metaWhereInput
  }


  /**
   * responsibilities_meta without action
   */
  export type responsibilities_metaArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the responsibilities_meta
     */
    select?: responsibilities_metaSelect<ExtArgs> | null
  }



  /**
   * Model seasons
   */


  export type AggregateSeasons = {
    _count: SeasonsCountAggregateOutputType | null
    _avg: SeasonsAvgAggregateOutputType | null
    _sum: SeasonsSumAggregateOutputType | null
    _min: SeasonsMinAggregateOutputType | null
    _max: SeasonsMaxAggregateOutputType | null
  }

  export type SeasonsAvgAggregateOutputType = {
    id: number | null
  }

  export type SeasonsSumAggregateOutputType = {
    id: number | null
  }

  export type SeasonsMinAggregateOutputType = {
    id: number | null
    startdate: Date | null
    enddate: Date | null
    theme: string | null
    comments: string | null
    name: string | null
  }

  export type SeasonsMaxAggregateOutputType = {
    id: number | null
    startdate: Date | null
    enddate: Date | null
    theme: string | null
    comments: string | null
    name: string | null
  }

  export type SeasonsCountAggregateOutputType = {
    id: number
    startdate: number
    enddate: number
    theme: number
    comments: number
    name: number
    _all: number
  }


  export type SeasonsAvgAggregateInputType = {
    id?: true
  }

  export type SeasonsSumAggregateInputType = {
    id?: true
  }

  export type SeasonsMinAggregateInputType = {
    id?: true
    startdate?: true
    enddate?: true
    theme?: true
    comments?: true
    name?: true
  }

  export type SeasonsMaxAggregateInputType = {
    id?: true
    startdate?: true
    enddate?: true
    theme?: true
    comments?: true
    name?: true
  }

  export type SeasonsCountAggregateInputType = {
    id?: true
    startdate?: true
    enddate?: true
    theme?: true
    comments?: true
    name?: true
    _all?: true
  }

  export type SeasonsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which seasons to aggregate.
     */
    where?: seasonsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of seasons to fetch.
     */
    orderBy?: Enumerable<seasonsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: seasonsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` seasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` seasons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned seasons
    **/
    _count?: true | SeasonsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SeasonsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SeasonsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SeasonsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SeasonsMaxAggregateInputType
  }

  export type GetSeasonsAggregateType<T extends SeasonsAggregateArgs> = {
        [P in keyof T & keyof AggregateSeasons]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSeasons[P]>
      : GetScalarType<T[P], AggregateSeasons[P]>
  }




  export type SeasonsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: seasonsWhereInput
    orderBy?: Enumerable<seasonsOrderByWithAggregationInput>
    by: SeasonsScalarFieldEnum[]
    having?: seasonsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SeasonsCountAggregateInputType | true
    _avg?: SeasonsAvgAggregateInputType
    _sum?: SeasonsSumAggregateInputType
    _min?: SeasonsMinAggregateInputType
    _max?: SeasonsMaxAggregateInputType
  }


  export type SeasonsGroupByOutputType = {
    id: number
    startdate: Date | null
    enddate: Date | null
    theme: string | null
    comments: string | null
    name: string | null
    _count: SeasonsCountAggregateOutputType | null
    _avg: SeasonsAvgAggregateOutputType | null
    _sum: SeasonsSumAggregateOutputType | null
    _min: SeasonsMinAggregateOutputType | null
    _max: SeasonsMaxAggregateOutputType | null
  }

  type GetSeasonsGroupByPayload<T extends SeasonsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<SeasonsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SeasonsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SeasonsGroupByOutputType[P]>
            : GetScalarType<T[P], SeasonsGroupByOutputType[P]>
        }
      >
    >


  export type seasonsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    startdate?: boolean
    enddate?: boolean
    theme?: boolean
    comments?: boolean
    name?: boolean
  }, ExtArgs["result"]["seasons"]>

  export type seasonsSelectScalar = {
    id?: boolean
    startdate?: boolean
    enddate?: boolean
    theme?: boolean
    comments?: boolean
    name?: boolean
  }


  type seasonsGetPayload<S extends boolean | null | undefined | seasonsArgs> = $Types.GetResult<seasonsPayload, S>

  type seasonsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<seasonsFindManyArgs, 'select' | 'include'> & {
      select?: SeasonsCountAggregateInputType | true
    }

  export interface seasonsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['seasons'], meta: { name: 'seasons' } }
    /**
     * Find zero or one Seasons that matches the filter.
     * @param {seasonsFindUniqueArgs} args - Arguments to find a Seasons
     * @example
     * // Get one Seasons
     * const seasons = await prisma.seasons.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends seasonsFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, seasonsFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'seasons'> extends True ? Prisma__seasonsClient<$Types.GetResult<seasonsPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__seasonsClient<$Types.GetResult<seasonsPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Seasons that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {seasonsFindUniqueOrThrowArgs} args - Arguments to find a Seasons
     * @example
     * // Get one Seasons
     * const seasons = await prisma.seasons.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends seasonsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, seasonsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__seasonsClient<$Types.GetResult<seasonsPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Seasons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {seasonsFindFirstArgs} args - Arguments to find a Seasons
     * @example
     * // Get one Seasons
     * const seasons = await prisma.seasons.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends seasonsFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, seasonsFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'seasons'> extends True ? Prisma__seasonsClient<$Types.GetResult<seasonsPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__seasonsClient<$Types.GetResult<seasonsPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Seasons that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {seasonsFindFirstOrThrowArgs} args - Arguments to find a Seasons
     * @example
     * // Get one Seasons
     * const seasons = await prisma.seasons.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends seasonsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, seasonsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__seasonsClient<$Types.GetResult<seasonsPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Seasons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {seasonsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Seasons
     * const seasons = await prisma.seasons.findMany()
     * 
     * // Get first 10 Seasons
     * const seasons = await prisma.seasons.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const seasonsWithIdOnly = await prisma.seasons.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends seasonsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, seasonsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<seasonsPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Seasons.
     * @param {seasonsCreateArgs} args - Arguments to create a Seasons.
     * @example
     * // Create one Seasons
     * const Seasons = await prisma.seasons.create({
     *   data: {
     *     // ... data to create a Seasons
     *   }
     * })
     * 
    **/
    create<T extends seasonsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, seasonsCreateArgs<ExtArgs>>
    ): Prisma__seasonsClient<$Types.GetResult<seasonsPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Seasons.
     *     @param {seasonsCreateManyArgs} args - Arguments to create many Seasons.
     *     @example
     *     // Create many Seasons
     *     const seasons = await prisma.seasons.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends seasonsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, seasonsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Seasons.
     * @param {seasonsDeleteArgs} args - Arguments to delete one Seasons.
     * @example
     * // Delete one Seasons
     * const Seasons = await prisma.seasons.delete({
     *   where: {
     *     // ... filter to delete one Seasons
     *   }
     * })
     * 
    **/
    delete<T extends seasonsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, seasonsDeleteArgs<ExtArgs>>
    ): Prisma__seasonsClient<$Types.GetResult<seasonsPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Seasons.
     * @param {seasonsUpdateArgs} args - Arguments to update one Seasons.
     * @example
     * // Update one Seasons
     * const seasons = await prisma.seasons.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends seasonsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, seasonsUpdateArgs<ExtArgs>>
    ): Prisma__seasonsClient<$Types.GetResult<seasonsPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Seasons.
     * @param {seasonsDeleteManyArgs} args - Arguments to filter Seasons to delete.
     * @example
     * // Delete a few Seasons
     * const { count } = await prisma.seasons.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends seasonsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, seasonsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Seasons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {seasonsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Seasons
     * const seasons = await prisma.seasons.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends seasonsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, seasonsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Seasons.
     * @param {seasonsUpsertArgs} args - Arguments to update or create a Seasons.
     * @example
     * // Update or create a Seasons
     * const seasons = await prisma.seasons.upsert({
     *   create: {
     *     // ... data to create a Seasons
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Seasons we want to update
     *   }
     * })
    **/
    upsert<T extends seasonsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, seasonsUpsertArgs<ExtArgs>>
    ): Prisma__seasonsClient<$Types.GetResult<seasonsPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Seasons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {seasonsCountArgs} args - Arguments to filter Seasons to count.
     * @example
     * // Count the number of Seasons
     * const count = await prisma.seasons.count({
     *   where: {
     *     // ... the filter for the Seasons we want to count
     *   }
     * })
    **/
    count<T extends seasonsCountArgs>(
      args?: Subset<T, seasonsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SeasonsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Seasons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SeasonsAggregateArgs>(args: Subset<T, SeasonsAggregateArgs>): Prisma.PrismaPromise<GetSeasonsAggregateType<T>>

    /**
     * Group by Seasons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SeasonsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SeasonsGroupByArgs['orderBy'] }
        : { orderBy?: SeasonsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SeasonsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSeasonsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for seasons.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__seasonsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * seasons base type for findUnique actions
   */
  export type seasonsFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seasons
     */
    select?: seasonsSelect<ExtArgs> | null
    /**
     * Filter, which seasons to fetch.
     */
    where: seasonsWhereUniqueInput
  }

  /**
   * seasons findUnique
   */
  export interface seasonsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends seasonsFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * seasons findUniqueOrThrow
   */
  export type seasonsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seasons
     */
    select?: seasonsSelect<ExtArgs> | null
    /**
     * Filter, which seasons to fetch.
     */
    where: seasonsWhereUniqueInput
  }


  /**
   * seasons base type for findFirst actions
   */
  export type seasonsFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seasons
     */
    select?: seasonsSelect<ExtArgs> | null
    /**
     * Filter, which seasons to fetch.
     */
    where?: seasonsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of seasons to fetch.
     */
    orderBy?: Enumerable<seasonsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for seasons.
     */
    cursor?: seasonsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` seasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` seasons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of seasons.
     */
    distinct?: Enumerable<SeasonsScalarFieldEnum>
  }

  /**
   * seasons findFirst
   */
  export interface seasonsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends seasonsFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * seasons findFirstOrThrow
   */
  export type seasonsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seasons
     */
    select?: seasonsSelect<ExtArgs> | null
    /**
     * Filter, which seasons to fetch.
     */
    where?: seasonsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of seasons to fetch.
     */
    orderBy?: Enumerable<seasonsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for seasons.
     */
    cursor?: seasonsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` seasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` seasons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of seasons.
     */
    distinct?: Enumerable<SeasonsScalarFieldEnum>
  }


  /**
   * seasons findMany
   */
  export type seasonsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seasons
     */
    select?: seasonsSelect<ExtArgs> | null
    /**
     * Filter, which seasons to fetch.
     */
    where?: seasonsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of seasons to fetch.
     */
    orderBy?: Enumerable<seasonsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing seasons.
     */
    cursor?: seasonsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` seasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` seasons.
     */
    skip?: number
    distinct?: Enumerable<SeasonsScalarFieldEnum>
  }


  /**
   * seasons create
   */
  export type seasonsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seasons
     */
    select?: seasonsSelect<ExtArgs> | null
    /**
     * The data needed to create a seasons.
     */
    data?: XOR<seasonsCreateInput, seasonsUncheckedCreateInput>
  }


  /**
   * seasons createMany
   */
  export type seasonsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many seasons.
     */
    data: Enumerable<seasonsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * seasons update
   */
  export type seasonsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seasons
     */
    select?: seasonsSelect<ExtArgs> | null
    /**
     * The data needed to update a seasons.
     */
    data: XOR<seasonsUpdateInput, seasonsUncheckedUpdateInput>
    /**
     * Choose, which seasons to update.
     */
    where: seasonsWhereUniqueInput
  }


  /**
   * seasons updateMany
   */
  export type seasonsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update seasons.
     */
    data: XOR<seasonsUpdateManyMutationInput, seasonsUncheckedUpdateManyInput>
    /**
     * Filter which seasons to update
     */
    where?: seasonsWhereInput
  }


  /**
   * seasons upsert
   */
  export type seasonsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seasons
     */
    select?: seasonsSelect<ExtArgs> | null
    /**
     * The filter to search for the seasons to update in case it exists.
     */
    where: seasonsWhereUniqueInput
    /**
     * In case the seasons found by the `where` argument doesn't exist, create a new seasons with this data.
     */
    create: XOR<seasonsCreateInput, seasonsUncheckedCreateInput>
    /**
     * In case the seasons was found with the provided `where` argument, update it with this data.
     */
    update: XOR<seasonsUpdateInput, seasonsUncheckedUpdateInput>
  }


  /**
   * seasons delete
   */
  export type seasonsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seasons
     */
    select?: seasonsSelect<ExtArgs> | null
    /**
     * Filter which seasons to delete.
     */
    where: seasonsWhereUniqueInput
  }


  /**
   * seasons deleteMany
   */
  export type seasonsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which seasons to delete
     */
    where?: seasonsWhereInput
  }


  /**
   * seasons without action
   */
  export type seasonsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seasons
     */
    select?: seasonsSelect<ExtArgs> | null
  }



  /**
   * Model service_specific_presentation_structure
   */


  export type AggregateService_specific_presentation_structure = {
    _count: Service_specific_presentation_structureCountAggregateOutputType | null
    _avg: Service_specific_presentation_structureAvgAggregateOutputType | null
    _sum: Service_specific_presentation_structureSumAggregateOutputType | null
    _min: Service_specific_presentation_structureMinAggregateOutputType | null
    _max: Service_specific_presentation_structureMaxAggregateOutputType | null
  }

  export type Service_specific_presentation_structureAvgAggregateOutputType = {
    id: number | null
    service_id: number | null
    slot_number: number | null
    content_id: number | null
    header_id: number | null
  }

  export type Service_specific_presentation_structureSumAggregateOutputType = {
    id: number | null
    service_id: number | null
    slot_number: number | null
    content_id: number | null
    header_id: number | null
  }

  export type Service_specific_presentation_structureMinAggregateOutputType = {
    id: number | null
    service_id: number | null
    slot_name: string | null
    slot_number: number | null
    slot_type: string | null
    id_in_type_table: string | null
    content_id: number | null
    addedclass: string | null
    header_id: number | null
    instruction: string | null
  }

  export type Service_specific_presentation_structureMaxAggregateOutputType = {
    id: number | null
    service_id: number | null
    slot_name: string | null
    slot_number: number | null
    slot_type: string | null
    id_in_type_table: string | null
    content_id: number | null
    addedclass: string | null
    header_id: number | null
    instruction: string | null
  }

  export type Service_specific_presentation_structureCountAggregateOutputType = {
    id: number
    service_id: number
    slot_name: number
    slot_number: number
    slot_type: number
    id_in_type_table: number
    content_id: number
    addedclass: number
    header_id: number
    instruction: number
    _all: number
  }


  export type Service_specific_presentation_structureAvgAggregateInputType = {
    id?: true
    service_id?: true
    slot_number?: true
    content_id?: true
    header_id?: true
  }

  export type Service_specific_presentation_structureSumAggregateInputType = {
    id?: true
    service_id?: true
    slot_number?: true
    content_id?: true
    header_id?: true
  }

  export type Service_specific_presentation_structureMinAggregateInputType = {
    id?: true
    service_id?: true
    slot_name?: true
    slot_number?: true
    slot_type?: true
    id_in_type_table?: true
    content_id?: true
    addedclass?: true
    header_id?: true
    instruction?: true
  }

  export type Service_specific_presentation_structureMaxAggregateInputType = {
    id?: true
    service_id?: true
    slot_name?: true
    slot_number?: true
    slot_type?: true
    id_in_type_table?: true
    content_id?: true
    addedclass?: true
    header_id?: true
    instruction?: true
  }

  export type Service_specific_presentation_structureCountAggregateInputType = {
    id?: true
    service_id?: true
    slot_name?: true
    slot_number?: true
    slot_type?: true
    id_in_type_table?: true
    content_id?: true
    addedclass?: true
    header_id?: true
    instruction?: true
    _all?: true
  }

  export type Service_specific_presentation_structureAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which service_specific_presentation_structure to aggregate.
     */
    where?: service_specific_presentation_structureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of service_specific_presentation_structures to fetch.
     */
    orderBy?: Enumerable<service_specific_presentation_structureOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: service_specific_presentation_structureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` service_specific_presentation_structures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` service_specific_presentation_structures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned service_specific_presentation_structures
    **/
    _count?: true | Service_specific_presentation_structureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Service_specific_presentation_structureAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Service_specific_presentation_structureSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Service_specific_presentation_structureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Service_specific_presentation_structureMaxAggregateInputType
  }

  export type GetService_specific_presentation_structureAggregateType<T extends Service_specific_presentation_structureAggregateArgs> = {
        [P in keyof T & keyof AggregateService_specific_presentation_structure]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateService_specific_presentation_structure[P]>
      : GetScalarType<T[P], AggregateService_specific_presentation_structure[P]>
  }




  export type Service_specific_presentation_structureGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: service_specific_presentation_structureWhereInput
    orderBy?: Enumerable<service_specific_presentation_structureOrderByWithAggregationInput>
    by: Service_specific_presentation_structureScalarFieldEnum[]
    having?: service_specific_presentation_structureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Service_specific_presentation_structureCountAggregateInputType | true
    _avg?: Service_specific_presentation_structureAvgAggregateInputType
    _sum?: Service_specific_presentation_structureSumAggregateInputType
    _min?: Service_specific_presentation_structureMinAggregateInputType
    _max?: Service_specific_presentation_structureMaxAggregateInputType
  }


  export type Service_specific_presentation_structureGroupByOutputType = {
    id: number
    service_id: number
    slot_name: string | null
    slot_number: number | null
    slot_type: string | null
    id_in_type_table: string | null
    content_id: number
    addedclass: string | null
    header_id: number | null
    instruction: string | null
    _count: Service_specific_presentation_structureCountAggregateOutputType | null
    _avg: Service_specific_presentation_structureAvgAggregateOutputType | null
    _sum: Service_specific_presentation_structureSumAggregateOutputType | null
    _min: Service_specific_presentation_structureMinAggregateOutputType | null
    _max: Service_specific_presentation_structureMaxAggregateOutputType | null
  }

  type GetService_specific_presentation_structureGroupByPayload<T extends Service_specific_presentation_structureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Service_specific_presentation_structureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Service_specific_presentation_structureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Service_specific_presentation_structureGroupByOutputType[P]>
            : GetScalarType<T[P], Service_specific_presentation_structureGroupByOutputType[P]>
        }
      >
    >


  export type service_specific_presentation_structureSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    service_id?: boolean
    slot_name?: boolean
    slot_number?: boolean
    slot_type?: boolean
    id_in_type_table?: boolean
    content_id?: boolean
    addedclass?: boolean
    header_id?: boolean
    instruction?: boolean
  }, ExtArgs["result"]["service_specific_presentation_structure"]>

  export type service_specific_presentation_structureSelectScalar = {
    id?: boolean
    service_id?: boolean
    slot_name?: boolean
    slot_number?: boolean
    slot_type?: boolean
    id_in_type_table?: boolean
    content_id?: boolean
    addedclass?: boolean
    header_id?: boolean
    instruction?: boolean
  }


  type service_specific_presentation_structureGetPayload<S extends boolean | null | undefined | service_specific_presentation_structureArgs> = $Types.GetResult<service_specific_presentation_structurePayload, S>

  type service_specific_presentation_structureCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<service_specific_presentation_structureFindManyArgs, 'select' | 'include'> & {
      select?: Service_specific_presentation_structureCountAggregateInputType | true
    }

  export interface service_specific_presentation_structureDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['service_specific_presentation_structure'], meta: { name: 'service_specific_presentation_structure' } }
    /**
     * Find zero or one Service_specific_presentation_structure that matches the filter.
     * @param {service_specific_presentation_structureFindUniqueArgs} args - Arguments to find a Service_specific_presentation_structure
     * @example
     * // Get one Service_specific_presentation_structure
     * const service_specific_presentation_structure = await prisma.service_specific_presentation_structure.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends service_specific_presentation_structureFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, service_specific_presentation_structureFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'service_specific_presentation_structure'> extends True ? Prisma__service_specific_presentation_structureClient<$Types.GetResult<service_specific_presentation_structurePayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__service_specific_presentation_structureClient<$Types.GetResult<service_specific_presentation_structurePayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Service_specific_presentation_structure that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {service_specific_presentation_structureFindUniqueOrThrowArgs} args - Arguments to find a Service_specific_presentation_structure
     * @example
     * // Get one Service_specific_presentation_structure
     * const service_specific_presentation_structure = await prisma.service_specific_presentation_structure.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends service_specific_presentation_structureFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, service_specific_presentation_structureFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__service_specific_presentation_structureClient<$Types.GetResult<service_specific_presentation_structurePayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Service_specific_presentation_structure that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {service_specific_presentation_structureFindFirstArgs} args - Arguments to find a Service_specific_presentation_structure
     * @example
     * // Get one Service_specific_presentation_structure
     * const service_specific_presentation_structure = await prisma.service_specific_presentation_structure.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends service_specific_presentation_structureFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, service_specific_presentation_structureFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'service_specific_presentation_structure'> extends True ? Prisma__service_specific_presentation_structureClient<$Types.GetResult<service_specific_presentation_structurePayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__service_specific_presentation_structureClient<$Types.GetResult<service_specific_presentation_structurePayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Service_specific_presentation_structure that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {service_specific_presentation_structureFindFirstOrThrowArgs} args - Arguments to find a Service_specific_presentation_structure
     * @example
     * // Get one Service_specific_presentation_structure
     * const service_specific_presentation_structure = await prisma.service_specific_presentation_structure.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends service_specific_presentation_structureFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, service_specific_presentation_structureFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__service_specific_presentation_structureClient<$Types.GetResult<service_specific_presentation_structurePayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Service_specific_presentation_structures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {service_specific_presentation_structureFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Service_specific_presentation_structures
     * const service_specific_presentation_structures = await prisma.service_specific_presentation_structure.findMany()
     * 
     * // Get first 10 Service_specific_presentation_structures
     * const service_specific_presentation_structures = await prisma.service_specific_presentation_structure.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const service_specific_presentation_structureWithIdOnly = await prisma.service_specific_presentation_structure.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends service_specific_presentation_structureFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, service_specific_presentation_structureFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<service_specific_presentation_structurePayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Service_specific_presentation_structure.
     * @param {service_specific_presentation_structureCreateArgs} args - Arguments to create a Service_specific_presentation_structure.
     * @example
     * // Create one Service_specific_presentation_structure
     * const Service_specific_presentation_structure = await prisma.service_specific_presentation_structure.create({
     *   data: {
     *     // ... data to create a Service_specific_presentation_structure
     *   }
     * })
     * 
    **/
    create<T extends service_specific_presentation_structureCreateArgs<ExtArgs>>(
      args: SelectSubset<T, service_specific_presentation_structureCreateArgs<ExtArgs>>
    ): Prisma__service_specific_presentation_structureClient<$Types.GetResult<service_specific_presentation_structurePayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Service_specific_presentation_structures.
     *     @param {service_specific_presentation_structureCreateManyArgs} args - Arguments to create many Service_specific_presentation_structures.
     *     @example
     *     // Create many Service_specific_presentation_structures
     *     const service_specific_presentation_structure = await prisma.service_specific_presentation_structure.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends service_specific_presentation_structureCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, service_specific_presentation_structureCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Service_specific_presentation_structure.
     * @param {service_specific_presentation_structureDeleteArgs} args - Arguments to delete one Service_specific_presentation_structure.
     * @example
     * // Delete one Service_specific_presentation_structure
     * const Service_specific_presentation_structure = await prisma.service_specific_presentation_structure.delete({
     *   where: {
     *     // ... filter to delete one Service_specific_presentation_structure
     *   }
     * })
     * 
    **/
    delete<T extends service_specific_presentation_structureDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, service_specific_presentation_structureDeleteArgs<ExtArgs>>
    ): Prisma__service_specific_presentation_structureClient<$Types.GetResult<service_specific_presentation_structurePayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Service_specific_presentation_structure.
     * @param {service_specific_presentation_structureUpdateArgs} args - Arguments to update one Service_specific_presentation_structure.
     * @example
     * // Update one Service_specific_presentation_structure
     * const service_specific_presentation_structure = await prisma.service_specific_presentation_structure.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends service_specific_presentation_structureUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, service_specific_presentation_structureUpdateArgs<ExtArgs>>
    ): Prisma__service_specific_presentation_structureClient<$Types.GetResult<service_specific_presentation_structurePayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Service_specific_presentation_structures.
     * @param {service_specific_presentation_structureDeleteManyArgs} args - Arguments to filter Service_specific_presentation_structures to delete.
     * @example
     * // Delete a few Service_specific_presentation_structures
     * const { count } = await prisma.service_specific_presentation_structure.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends service_specific_presentation_structureDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, service_specific_presentation_structureDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Service_specific_presentation_structures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {service_specific_presentation_structureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Service_specific_presentation_structures
     * const service_specific_presentation_structure = await prisma.service_specific_presentation_structure.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends service_specific_presentation_structureUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, service_specific_presentation_structureUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Service_specific_presentation_structure.
     * @param {service_specific_presentation_structureUpsertArgs} args - Arguments to update or create a Service_specific_presentation_structure.
     * @example
     * // Update or create a Service_specific_presentation_structure
     * const service_specific_presentation_structure = await prisma.service_specific_presentation_structure.upsert({
     *   create: {
     *     // ... data to create a Service_specific_presentation_structure
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Service_specific_presentation_structure we want to update
     *   }
     * })
    **/
    upsert<T extends service_specific_presentation_structureUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, service_specific_presentation_structureUpsertArgs<ExtArgs>>
    ): Prisma__service_specific_presentation_structureClient<$Types.GetResult<service_specific_presentation_structurePayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Service_specific_presentation_structures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {service_specific_presentation_structureCountArgs} args - Arguments to filter Service_specific_presentation_structures to count.
     * @example
     * // Count the number of Service_specific_presentation_structures
     * const count = await prisma.service_specific_presentation_structure.count({
     *   where: {
     *     // ... the filter for the Service_specific_presentation_structures we want to count
     *   }
     * })
    **/
    count<T extends service_specific_presentation_structureCountArgs>(
      args?: Subset<T, service_specific_presentation_structureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Service_specific_presentation_structureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Service_specific_presentation_structure.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Service_specific_presentation_structureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Service_specific_presentation_structureAggregateArgs>(args: Subset<T, Service_specific_presentation_structureAggregateArgs>): Prisma.PrismaPromise<GetService_specific_presentation_structureAggregateType<T>>

    /**
     * Group by Service_specific_presentation_structure.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Service_specific_presentation_structureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Service_specific_presentation_structureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Service_specific_presentation_structureGroupByArgs['orderBy'] }
        : { orderBy?: Service_specific_presentation_structureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Service_specific_presentation_structureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetService_specific_presentation_structureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for service_specific_presentation_structure.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__service_specific_presentation_structureClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * service_specific_presentation_structure base type for findUnique actions
   */
  export type service_specific_presentation_structureFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_specific_presentation_structure
     */
    select?: service_specific_presentation_structureSelect<ExtArgs> | null
    /**
     * Filter, which service_specific_presentation_structure to fetch.
     */
    where: service_specific_presentation_structureWhereUniqueInput
  }

  /**
   * service_specific_presentation_structure findUnique
   */
  export interface service_specific_presentation_structureFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends service_specific_presentation_structureFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * service_specific_presentation_structure findUniqueOrThrow
   */
  export type service_specific_presentation_structureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_specific_presentation_structure
     */
    select?: service_specific_presentation_structureSelect<ExtArgs> | null
    /**
     * Filter, which service_specific_presentation_structure to fetch.
     */
    where: service_specific_presentation_structureWhereUniqueInput
  }


  /**
   * service_specific_presentation_structure base type for findFirst actions
   */
  export type service_specific_presentation_structureFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_specific_presentation_structure
     */
    select?: service_specific_presentation_structureSelect<ExtArgs> | null
    /**
     * Filter, which service_specific_presentation_structure to fetch.
     */
    where?: service_specific_presentation_structureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of service_specific_presentation_structures to fetch.
     */
    orderBy?: Enumerable<service_specific_presentation_structureOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for service_specific_presentation_structures.
     */
    cursor?: service_specific_presentation_structureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` service_specific_presentation_structures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` service_specific_presentation_structures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of service_specific_presentation_structures.
     */
    distinct?: Enumerable<Service_specific_presentation_structureScalarFieldEnum>
  }

  /**
   * service_specific_presentation_structure findFirst
   */
  export interface service_specific_presentation_structureFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends service_specific_presentation_structureFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * service_specific_presentation_structure findFirstOrThrow
   */
  export type service_specific_presentation_structureFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_specific_presentation_structure
     */
    select?: service_specific_presentation_structureSelect<ExtArgs> | null
    /**
     * Filter, which service_specific_presentation_structure to fetch.
     */
    where?: service_specific_presentation_structureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of service_specific_presentation_structures to fetch.
     */
    orderBy?: Enumerable<service_specific_presentation_structureOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for service_specific_presentation_structures.
     */
    cursor?: service_specific_presentation_structureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` service_specific_presentation_structures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` service_specific_presentation_structures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of service_specific_presentation_structures.
     */
    distinct?: Enumerable<Service_specific_presentation_structureScalarFieldEnum>
  }


  /**
   * service_specific_presentation_structure findMany
   */
  export type service_specific_presentation_structureFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_specific_presentation_structure
     */
    select?: service_specific_presentation_structureSelect<ExtArgs> | null
    /**
     * Filter, which service_specific_presentation_structures to fetch.
     */
    where?: service_specific_presentation_structureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of service_specific_presentation_structures to fetch.
     */
    orderBy?: Enumerable<service_specific_presentation_structureOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing service_specific_presentation_structures.
     */
    cursor?: service_specific_presentation_structureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` service_specific_presentation_structures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` service_specific_presentation_structures.
     */
    skip?: number
    distinct?: Enumerable<Service_specific_presentation_structureScalarFieldEnum>
  }


  /**
   * service_specific_presentation_structure create
   */
  export type service_specific_presentation_structureCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_specific_presentation_structure
     */
    select?: service_specific_presentation_structureSelect<ExtArgs> | null
    /**
     * The data needed to create a service_specific_presentation_structure.
     */
    data: XOR<service_specific_presentation_structureCreateInput, service_specific_presentation_structureUncheckedCreateInput>
  }


  /**
   * service_specific_presentation_structure createMany
   */
  export type service_specific_presentation_structureCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many service_specific_presentation_structures.
     */
    data: Enumerable<service_specific_presentation_structureCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * service_specific_presentation_structure update
   */
  export type service_specific_presentation_structureUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_specific_presentation_structure
     */
    select?: service_specific_presentation_structureSelect<ExtArgs> | null
    /**
     * The data needed to update a service_specific_presentation_structure.
     */
    data: XOR<service_specific_presentation_structureUpdateInput, service_specific_presentation_structureUncheckedUpdateInput>
    /**
     * Choose, which service_specific_presentation_structure to update.
     */
    where: service_specific_presentation_structureWhereUniqueInput
  }


  /**
   * service_specific_presentation_structure updateMany
   */
  export type service_specific_presentation_structureUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update service_specific_presentation_structures.
     */
    data: XOR<service_specific_presentation_structureUpdateManyMutationInput, service_specific_presentation_structureUncheckedUpdateManyInput>
    /**
     * Filter which service_specific_presentation_structures to update
     */
    where?: service_specific_presentation_structureWhereInput
  }


  /**
   * service_specific_presentation_structure upsert
   */
  export type service_specific_presentation_structureUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_specific_presentation_structure
     */
    select?: service_specific_presentation_structureSelect<ExtArgs> | null
    /**
     * The filter to search for the service_specific_presentation_structure to update in case it exists.
     */
    where: service_specific_presentation_structureWhereUniqueInput
    /**
     * In case the service_specific_presentation_structure found by the `where` argument doesn't exist, create a new service_specific_presentation_structure with this data.
     */
    create: XOR<service_specific_presentation_structureCreateInput, service_specific_presentation_structureUncheckedCreateInput>
    /**
     * In case the service_specific_presentation_structure was found with the provided `where` argument, update it with this data.
     */
    update: XOR<service_specific_presentation_structureUpdateInput, service_specific_presentation_structureUncheckedUpdateInput>
  }


  /**
   * service_specific_presentation_structure delete
   */
  export type service_specific_presentation_structureDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_specific_presentation_structure
     */
    select?: service_specific_presentation_structureSelect<ExtArgs> | null
    /**
     * Filter which service_specific_presentation_structure to delete.
     */
    where: service_specific_presentation_structureWhereUniqueInput
  }


  /**
   * service_specific_presentation_structure deleteMany
   */
  export type service_specific_presentation_structureDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which service_specific_presentation_structures to delete
     */
    where?: service_specific_presentation_structureWhereInput
  }


  /**
   * service_specific_presentation_structure without action
   */
  export type service_specific_presentation_structureArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_specific_presentation_structure
     */
    select?: service_specific_presentation_structureSelect<ExtArgs> | null
  }



  /**
   * Model services
   */


  export type AggregateServices = {
    _count: ServicesCountAggregateOutputType | null
    _avg: ServicesAvgAggregateOutputType | null
    _sum: ServicesSumAggregateOutputType | null
    _min: ServicesMinAggregateOutputType | null
    _max: ServicesMaxAggregateOutputType | null
  }

  export type ServicesAvgAggregateOutputType = {
    id: number | null
  }

  export type ServicesSumAggregateOutputType = {
    id: number | null
  }

  export type ServicesMinAggregateOutputType = {
    id: number | null
    servicedate: Date | null
    theme: string | null
  }

  export type ServicesMaxAggregateOutputType = {
    id: number | null
    servicedate: Date | null
    theme: string | null
  }

  export type ServicesCountAggregateOutputType = {
    id: number
    servicedate: number
    theme: number
    _all: number
  }


  export type ServicesAvgAggregateInputType = {
    id?: true
  }

  export type ServicesSumAggregateInputType = {
    id?: true
  }

  export type ServicesMinAggregateInputType = {
    id?: true
    servicedate?: true
    theme?: true
  }

  export type ServicesMaxAggregateInputType = {
    id?: true
    servicedate?: true
    theme?: true
  }

  export type ServicesCountAggregateInputType = {
    id?: true
    servicedate?: true
    theme?: true
    _all?: true
  }

  export type ServicesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which services to aggregate.
     */
    where?: servicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of services to fetch.
     */
    orderBy?: Enumerable<servicesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: servicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned services
    **/
    _count?: true | ServicesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServicesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServicesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServicesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServicesMaxAggregateInputType
  }

  export type GetServicesAggregateType<T extends ServicesAggregateArgs> = {
        [P in keyof T & keyof AggregateServices]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServices[P]>
      : GetScalarType<T[P], AggregateServices[P]>
  }




  export type ServicesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: servicesWhereInput
    orderBy?: Enumerable<servicesOrderByWithAggregationInput>
    by: ServicesScalarFieldEnum[]
    having?: servicesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServicesCountAggregateInputType | true
    _avg?: ServicesAvgAggregateInputType
    _sum?: ServicesSumAggregateInputType
    _min?: ServicesMinAggregateInputType
    _max?: ServicesMaxAggregateInputType
  }


  export type ServicesGroupByOutputType = {
    id: number
    servicedate: Date | null
    theme: string | null
    _count: ServicesCountAggregateOutputType | null
    _avg: ServicesAvgAggregateOutputType | null
    _sum: ServicesSumAggregateOutputType | null
    _min: ServicesMinAggregateOutputType | null
    _max: ServicesMaxAggregateOutputType | null
  }

  type GetServicesGroupByPayload<T extends ServicesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ServicesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServicesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServicesGroupByOutputType[P]>
            : GetScalarType<T[P], ServicesGroupByOutputType[P]>
        }
      >
    >


  export type servicesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    servicedate?: boolean
    theme?: boolean
    collected_offerings?: boolean | services$collected_offeringsArgs<ExtArgs>
    comments?: boolean | services$commentsArgs<ExtArgs>
    responsibilities?: boolean | services$responsibilitiesArgs<ExtArgs>
    servicesongs?: boolean | services$servicesongsArgs<ExtArgs>
    serviceverses?: boolean | services$serviceversesArgs<ExtArgs>
    _count?: boolean | ServicesCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["services"]>

  export type servicesSelectScalar = {
    id?: boolean
    servicedate?: boolean
    theme?: boolean
  }

  export type servicesInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    collected_offerings?: boolean | services$collected_offeringsArgs<ExtArgs>
    comments?: boolean | services$commentsArgs<ExtArgs>
    responsibilities?: boolean | services$responsibilitiesArgs<ExtArgs>
    servicesongs?: boolean | services$servicesongsArgs<ExtArgs>
    serviceverses?: boolean | services$serviceversesArgs<ExtArgs>
    _count?: boolean | ServicesCountOutputTypeArgs<ExtArgs>
  }


  type servicesGetPayload<S extends boolean | null | undefined | servicesArgs> = $Types.GetResult<servicesPayload, S>

  type servicesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<servicesFindManyArgs, 'select' | 'include'> & {
      select?: ServicesCountAggregateInputType | true
    }

  export interface servicesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['services'], meta: { name: 'services' } }
    /**
     * Find zero or one Services that matches the filter.
     * @param {servicesFindUniqueArgs} args - Arguments to find a Services
     * @example
     * // Get one Services
     * const services = await prisma.services.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends servicesFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, servicesFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'services'> extends True ? Prisma__servicesClient<$Types.GetResult<servicesPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__servicesClient<$Types.GetResult<servicesPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Services that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {servicesFindUniqueOrThrowArgs} args - Arguments to find a Services
     * @example
     * // Get one Services
     * const services = await prisma.services.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends servicesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, servicesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__servicesClient<$Types.GetResult<servicesPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicesFindFirstArgs} args - Arguments to find a Services
     * @example
     * // Get one Services
     * const services = await prisma.services.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends servicesFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, servicesFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'services'> extends True ? Prisma__servicesClient<$Types.GetResult<servicesPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__servicesClient<$Types.GetResult<servicesPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Services that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicesFindFirstOrThrowArgs} args - Arguments to find a Services
     * @example
     * // Get one Services
     * const services = await prisma.services.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends servicesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, servicesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__servicesClient<$Types.GetResult<servicesPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Services
     * const services = await prisma.services.findMany()
     * 
     * // Get first 10 Services
     * const services = await prisma.services.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const servicesWithIdOnly = await prisma.services.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends servicesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, servicesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<servicesPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Services.
     * @param {servicesCreateArgs} args - Arguments to create a Services.
     * @example
     * // Create one Services
     * const Services = await prisma.services.create({
     *   data: {
     *     // ... data to create a Services
     *   }
     * })
     * 
    **/
    create<T extends servicesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, servicesCreateArgs<ExtArgs>>
    ): Prisma__servicesClient<$Types.GetResult<servicesPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Services.
     *     @param {servicesCreateManyArgs} args - Arguments to create many Services.
     *     @example
     *     // Create many Services
     *     const services = await prisma.services.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends servicesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, servicesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Services.
     * @param {servicesDeleteArgs} args - Arguments to delete one Services.
     * @example
     * // Delete one Services
     * const Services = await prisma.services.delete({
     *   where: {
     *     // ... filter to delete one Services
     *   }
     * })
     * 
    **/
    delete<T extends servicesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, servicesDeleteArgs<ExtArgs>>
    ): Prisma__servicesClient<$Types.GetResult<servicesPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Services.
     * @param {servicesUpdateArgs} args - Arguments to update one Services.
     * @example
     * // Update one Services
     * const services = await prisma.services.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends servicesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, servicesUpdateArgs<ExtArgs>>
    ): Prisma__servicesClient<$Types.GetResult<servicesPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Services.
     * @param {servicesDeleteManyArgs} args - Arguments to filter Services to delete.
     * @example
     * // Delete a few Services
     * const { count } = await prisma.services.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends servicesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, servicesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Services
     * const services = await prisma.services.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends servicesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, servicesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Services.
     * @param {servicesUpsertArgs} args - Arguments to update or create a Services.
     * @example
     * // Update or create a Services
     * const services = await prisma.services.upsert({
     *   create: {
     *     // ... data to create a Services
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Services we want to update
     *   }
     * })
    **/
    upsert<T extends servicesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, servicesUpsertArgs<ExtArgs>>
    ): Prisma__servicesClient<$Types.GetResult<servicesPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicesCountArgs} args - Arguments to filter Services to count.
     * @example
     * // Count the number of Services
     * const count = await prisma.services.count({
     *   where: {
     *     // ... the filter for the Services we want to count
     *   }
     * })
    **/
    count<T extends servicesCountArgs>(
      args?: Subset<T, servicesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServicesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServicesAggregateArgs>(args: Subset<T, ServicesAggregateArgs>): Prisma.PrismaPromise<GetServicesAggregateType<T>>

    /**
     * Group by Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServicesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServicesGroupByArgs['orderBy'] }
        : { orderBy?: ServicesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServicesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServicesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for services.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__servicesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    collected_offerings<T extends services$collected_offeringsArgs<ExtArgs> = {}>(args?: Subset<T, services$collected_offeringsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<collected_offeringsPayload<ExtArgs>, T, 'findMany', never>| Null>;

    comments<T extends services$commentsArgs<ExtArgs> = {}>(args?: Subset<T, services$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<commentsPayload<ExtArgs>, T, 'findMany', never>| Null>;

    responsibilities<T extends services$responsibilitiesArgs<ExtArgs> = {}>(args?: Subset<T, services$responsibilitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<responsibilitiesPayload<ExtArgs>, T, 'findMany', never>| Null>;

    servicesongs<T extends services$servicesongsArgs<ExtArgs> = {}>(args?: Subset<T, services$servicesongsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<servicesongsPayload<ExtArgs>, T, 'findMany', never>| Null>;

    serviceverses<T extends services$serviceversesArgs<ExtArgs> = {}>(args?: Subset<T, services$serviceversesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<serviceversesPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * services base type for findUnique actions
   */
  export type servicesFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the services
     */
    select?: servicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: servicesInclude<ExtArgs> | null
    /**
     * Filter, which services to fetch.
     */
    where: servicesWhereUniqueInput
  }

  /**
   * services findUnique
   */
  export interface servicesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends servicesFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * services findUniqueOrThrow
   */
  export type servicesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the services
     */
    select?: servicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: servicesInclude<ExtArgs> | null
    /**
     * Filter, which services to fetch.
     */
    where: servicesWhereUniqueInput
  }


  /**
   * services base type for findFirst actions
   */
  export type servicesFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the services
     */
    select?: servicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: servicesInclude<ExtArgs> | null
    /**
     * Filter, which services to fetch.
     */
    where?: servicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of services to fetch.
     */
    orderBy?: Enumerable<servicesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for services.
     */
    cursor?: servicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of services.
     */
    distinct?: Enumerable<ServicesScalarFieldEnum>
  }

  /**
   * services findFirst
   */
  export interface servicesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends servicesFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * services findFirstOrThrow
   */
  export type servicesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the services
     */
    select?: servicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: servicesInclude<ExtArgs> | null
    /**
     * Filter, which services to fetch.
     */
    where?: servicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of services to fetch.
     */
    orderBy?: Enumerable<servicesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for services.
     */
    cursor?: servicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of services.
     */
    distinct?: Enumerable<ServicesScalarFieldEnum>
  }


  /**
   * services findMany
   */
  export type servicesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the services
     */
    select?: servicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: servicesInclude<ExtArgs> | null
    /**
     * Filter, which services to fetch.
     */
    where?: servicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of services to fetch.
     */
    orderBy?: Enumerable<servicesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing services.
     */
    cursor?: servicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` services.
     */
    skip?: number
    distinct?: Enumerable<ServicesScalarFieldEnum>
  }


  /**
   * services create
   */
  export type servicesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the services
     */
    select?: servicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: servicesInclude<ExtArgs> | null
    /**
     * The data needed to create a services.
     */
    data?: XOR<servicesCreateInput, servicesUncheckedCreateInput>
  }


  /**
   * services createMany
   */
  export type servicesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many services.
     */
    data: Enumerable<servicesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * services update
   */
  export type servicesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the services
     */
    select?: servicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: servicesInclude<ExtArgs> | null
    /**
     * The data needed to update a services.
     */
    data: XOR<servicesUpdateInput, servicesUncheckedUpdateInput>
    /**
     * Choose, which services to update.
     */
    where: servicesWhereUniqueInput
  }


  /**
   * services updateMany
   */
  export type servicesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update services.
     */
    data: XOR<servicesUpdateManyMutationInput, servicesUncheckedUpdateManyInput>
    /**
     * Filter which services to update
     */
    where?: servicesWhereInput
  }


  /**
   * services upsert
   */
  export type servicesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the services
     */
    select?: servicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: servicesInclude<ExtArgs> | null
    /**
     * The filter to search for the services to update in case it exists.
     */
    where: servicesWhereUniqueInput
    /**
     * In case the services found by the `where` argument doesn't exist, create a new services with this data.
     */
    create: XOR<servicesCreateInput, servicesUncheckedCreateInput>
    /**
     * In case the services was found with the provided `where` argument, update it with this data.
     */
    update: XOR<servicesUpdateInput, servicesUncheckedUpdateInput>
  }


  /**
   * services delete
   */
  export type servicesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the services
     */
    select?: servicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: servicesInclude<ExtArgs> | null
    /**
     * Filter which services to delete.
     */
    where: servicesWhereUniqueInput
  }


  /**
   * services deleteMany
   */
  export type servicesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which services to delete
     */
    where?: servicesWhereInput
  }


  /**
   * services.collected_offerings
   */
  export type services$collected_offeringsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collected_offerings
     */
    select?: collected_offeringsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: collected_offeringsInclude<ExtArgs> | null
    where?: collected_offeringsWhereInput
    orderBy?: Enumerable<collected_offeringsOrderByWithRelationInput>
    cursor?: collected_offeringsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Collected_offeringsScalarFieldEnum>
  }


  /**
   * services.comments
   */
  export type services$commentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: commentsInclude<ExtArgs> | null
    where?: commentsWhereInput
    orderBy?: Enumerable<commentsOrderByWithRelationInput>
    cursor?: commentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CommentsScalarFieldEnum>
  }


  /**
   * services.responsibilities
   */
  export type services$responsibilitiesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the responsibilities
     */
    select?: responsibilitiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: responsibilitiesInclude<ExtArgs> | null
    where?: responsibilitiesWhereInput
    orderBy?: Enumerable<responsibilitiesOrderByWithRelationInput>
    cursor?: responsibilitiesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ResponsibilitiesScalarFieldEnum>
  }


  /**
   * services.servicesongs
   */
  export type services$servicesongsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicesongs
     */
    select?: servicesongsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: servicesongsInclude<ExtArgs> | null
    where?: servicesongsWhereInput
    orderBy?: Enumerable<servicesongsOrderByWithRelationInput>
    cursor?: servicesongsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ServicesongsScalarFieldEnum>
  }


  /**
   * services.serviceverses
   */
  export type services$serviceversesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceverses
     */
    select?: serviceversesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: serviceversesInclude<ExtArgs> | null
    where?: serviceversesWhereInput
    orderBy?: Enumerable<serviceversesOrderByWithRelationInput>
    cursor?: serviceversesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ServiceversesScalarFieldEnum>
  }


  /**
   * services without action
   */
  export type servicesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the services
     */
    select?: servicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: servicesInclude<ExtArgs> | null
  }



  /**
   * Model servicesongs
   */


  export type AggregateServicesongs = {
    _count: ServicesongsCountAggregateOutputType | null
    _avg: ServicesongsAvgAggregateOutputType | null
    _sum: ServicesongsSumAggregateOutputType | null
    _min: ServicesongsMinAggregateOutputType | null
    _max: ServicesongsMaxAggregateOutputType | null
  }

  export type ServicesongsAvgAggregateOutputType = {
    id: number | null
    service_id: number | null
    song_id: number | null
    position: number | null
  }

  export type ServicesongsSumAggregateOutputType = {
    id: bigint | null
    service_id: number | null
    song_id: number | null
    position: number | null
  }

  export type ServicesongsMinAggregateOutputType = {
    id: bigint | null
    service_id: number | null
    song_title: string | null
    verses: string | null
    is_instrumental: string | null
    song_id: number | null
    songtype: string | null
    position: number | null
  }

  export type ServicesongsMaxAggregateOutputType = {
    id: bigint | null
    service_id: number | null
    song_title: string | null
    verses: string | null
    is_instrumental: string | null
    song_id: number | null
    songtype: string | null
    position: number | null
  }

  export type ServicesongsCountAggregateOutputType = {
    id: number
    service_id: number
    song_title: number
    verses: number
    is_instrumental: number
    song_id: number
    songtype: number
    position: number
    _all: number
  }


  export type ServicesongsAvgAggregateInputType = {
    id?: true
    service_id?: true
    song_id?: true
    position?: true
  }

  export type ServicesongsSumAggregateInputType = {
    id?: true
    service_id?: true
    song_id?: true
    position?: true
  }

  export type ServicesongsMinAggregateInputType = {
    id?: true
    service_id?: true
    song_title?: true
    verses?: true
    is_instrumental?: true
    song_id?: true
    songtype?: true
    position?: true
  }

  export type ServicesongsMaxAggregateInputType = {
    id?: true
    service_id?: true
    song_title?: true
    verses?: true
    is_instrumental?: true
    song_id?: true
    songtype?: true
    position?: true
  }

  export type ServicesongsCountAggregateInputType = {
    id?: true
    service_id?: true
    song_title?: true
    verses?: true
    is_instrumental?: true
    song_id?: true
    songtype?: true
    position?: true
    _all?: true
  }

  export type ServicesongsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which servicesongs to aggregate.
     */
    where?: servicesongsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicesongs to fetch.
     */
    orderBy?: Enumerable<servicesongsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: servicesongsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicesongs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicesongs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned servicesongs
    **/
    _count?: true | ServicesongsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServicesongsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServicesongsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServicesongsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServicesongsMaxAggregateInputType
  }

  export type GetServicesongsAggregateType<T extends ServicesongsAggregateArgs> = {
        [P in keyof T & keyof AggregateServicesongs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServicesongs[P]>
      : GetScalarType<T[P], AggregateServicesongs[P]>
  }




  export type ServicesongsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: servicesongsWhereInput
    orderBy?: Enumerable<servicesongsOrderByWithAggregationInput>
    by: ServicesongsScalarFieldEnum[]
    having?: servicesongsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServicesongsCountAggregateInputType | true
    _avg?: ServicesongsAvgAggregateInputType
    _sum?: ServicesongsSumAggregateInputType
    _min?: ServicesongsMinAggregateInputType
    _max?: ServicesongsMaxAggregateInputType
  }


  export type ServicesongsGroupByOutputType = {
    id: bigint
    service_id: number
    song_title: string | null
    verses: string | null
    is_instrumental: string | null
    song_id: number | null
    songtype: string
    position: number | null
    _count: ServicesongsCountAggregateOutputType | null
    _avg: ServicesongsAvgAggregateOutputType | null
    _sum: ServicesongsSumAggregateOutputType | null
    _min: ServicesongsMinAggregateOutputType | null
    _max: ServicesongsMaxAggregateOutputType | null
  }

  type GetServicesongsGroupByPayload<T extends ServicesongsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ServicesongsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServicesongsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServicesongsGroupByOutputType[P]>
            : GetScalarType<T[P], ServicesongsGroupByOutputType[P]>
        }
      >
    >


  export type servicesongsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    service_id?: boolean
    song_title?: boolean
    verses?: boolean
    is_instrumental?: boolean
    song_id?: boolean
    songtype?: boolean
    position?: boolean
    services?: boolean | servicesArgs<ExtArgs>
  }, ExtArgs["result"]["servicesongs"]>

  export type servicesongsSelectScalar = {
    id?: boolean
    service_id?: boolean
    song_title?: boolean
    verses?: boolean
    is_instrumental?: boolean
    song_id?: boolean
    songtype?: boolean
    position?: boolean
  }

  export type servicesongsInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    services?: boolean | servicesArgs<ExtArgs>
  }


  type servicesongsGetPayload<S extends boolean | null | undefined | servicesongsArgs> = $Types.GetResult<servicesongsPayload, S>

  type servicesongsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<servicesongsFindManyArgs, 'select' | 'include'> & {
      select?: ServicesongsCountAggregateInputType | true
    }

  export interface servicesongsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['servicesongs'], meta: { name: 'servicesongs' } }
    /**
     * Find zero or one Servicesongs that matches the filter.
     * @param {servicesongsFindUniqueArgs} args - Arguments to find a Servicesongs
     * @example
     * // Get one Servicesongs
     * const servicesongs = await prisma.servicesongs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends servicesongsFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, servicesongsFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'servicesongs'> extends True ? Prisma__servicesongsClient<$Types.GetResult<servicesongsPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__servicesongsClient<$Types.GetResult<servicesongsPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Servicesongs that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {servicesongsFindUniqueOrThrowArgs} args - Arguments to find a Servicesongs
     * @example
     * // Get one Servicesongs
     * const servicesongs = await prisma.servicesongs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends servicesongsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, servicesongsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__servicesongsClient<$Types.GetResult<servicesongsPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Servicesongs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicesongsFindFirstArgs} args - Arguments to find a Servicesongs
     * @example
     * // Get one Servicesongs
     * const servicesongs = await prisma.servicesongs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends servicesongsFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, servicesongsFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'servicesongs'> extends True ? Prisma__servicesongsClient<$Types.GetResult<servicesongsPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__servicesongsClient<$Types.GetResult<servicesongsPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Servicesongs that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicesongsFindFirstOrThrowArgs} args - Arguments to find a Servicesongs
     * @example
     * // Get one Servicesongs
     * const servicesongs = await prisma.servicesongs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends servicesongsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, servicesongsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__servicesongsClient<$Types.GetResult<servicesongsPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Servicesongs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicesongsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Servicesongs
     * const servicesongs = await prisma.servicesongs.findMany()
     * 
     * // Get first 10 Servicesongs
     * const servicesongs = await prisma.servicesongs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const servicesongsWithIdOnly = await prisma.servicesongs.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends servicesongsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, servicesongsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<servicesongsPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Servicesongs.
     * @param {servicesongsCreateArgs} args - Arguments to create a Servicesongs.
     * @example
     * // Create one Servicesongs
     * const Servicesongs = await prisma.servicesongs.create({
     *   data: {
     *     // ... data to create a Servicesongs
     *   }
     * })
     * 
    **/
    create<T extends servicesongsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, servicesongsCreateArgs<ExtArgs>>
    ): Prisma__servicesongsClient<$Types.GetResult<servicesongsPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Servicesongs.
     *     @param {servicesongsCreateManyArgs} args - Arguments to create many Servicesongs.
     *     @example
     *     // Create many Servicesongs
     *     const servicesongs = await prisma.servicesongs.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends servicesongsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, servicesongsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Servicesongs.
     * @param {servicesongsDeleteArgs} args - Arguments to delete one Servicesongs.
     * @example
     * // Delete one Servicesongs
     * const Servicesongs = await prisma.servicesongs.delete({
     *   where: {
     *     // ... filter to delete one Servicesongs
     *   }
     * })
     * 
    **/
    delete<T extends servicesongsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, servicesongsDeleteArgs<ExtArgs>>
    ): Prisma__servicesongsClient<$Types.GetResult<servicesongsPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Servicesongs.
     * @param {servicesongsUpdateArgs} args - Arguments to update one Servicesongs.
     * @example
     * // Update one Servicesongs
     * const servicesongs = await prisma.servicesongs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends servicesongsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, servicesongsUpdateArgs<ExtArgs>>
    ): Prisma__servicesongsClient<$Types.GetResult<servicesongsPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Servicesongs.
     * @param {servicesongsDeleteManyArgs} args - Arguments to filter Servicesongs to delete.
     * @example
     * // Delete a few Servicesongs
     * const { count } = await prisma.servicesongs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends servicesongsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, servicesongsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Servicesongs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicesongsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Servicesongs
     * const servicesongs = await prisma.servicesongs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends servicesongsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, servicesongsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Servicesongs.
     * @param {servicesongsUpsertArgs} args - Arguments to update or create a Servicesongs.
     * @example
     * // Update or create a Servicesongs
     * const servicesongs = await prisma.servicesongs.upsert({
     *   create: {
     *     // ... data to create a Servicesongs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Servicesongs we want to update
     *   }
     * })
    **/
    upsert<T extends servicesongsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, servicesongsUpsertArgs<ExtArgs>>
    ): Prisma__servicesongsClient<$Types.GetResult<servicesongsPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Servicesongs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicesongsCountArgs} args - Arguments to filter Servicesongs to count.
     * @example
     * // Count the number of Servicesongs
     * const count = await prisma.servicesongs.count({
     *   where: {
     *     // ... the filter for the Servicesongs we want to count
     *   }
     * })
    **/
    count<T extends servicesongsCountArgs>(
      args?: Subset<T, servicesongsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServicesongsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Servicesongs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicesongsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServicesongsAggregateArgs>(args: Subset<T, ServicesongsAggregateArgs>): Prisma.PrismaPromise<GetServicesongsAggregateType<T>>

    /**
     * Group by Servicesongs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicesongsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServicesongsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServicesongsGroupByArgs['orderBy'] }
        : { orderBy?: ServicesongsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServicesongsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServicesongsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for servicesongs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__servicesongsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    services<T extends servicesArgs<ExtArgs> = {}>(args?: Subset<T, servicesArgs<ExtArgs>>): Prisma__servicesClient<$Types.GetResult<servicesPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * servicesongs base type for findUnique actions
   */
  export type servicesongsFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicesongs
     */
    select?: servicesongsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: servicesongsInclude<ExtArgs> | null
    /**
     * Filter, which servicesongs to fetch.
     */
    where: servicesongsWhereUniqueInput
  }

  /**
   * servicesongs findUnique
   */
  export interface servicesongsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends servicesongsFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * servicesongs findUniqueOrThrow
   */
  export type servicesongsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicesongs
     */
    select?: servicesongsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: servicesongsInclude<ExtArgs> | null
    /**
     * Filter, which servicesongs to fetch.
     */
    where: servicesongsWhereUniqueInput
  }


  /**
   * servicesongs base type for findFirst actions
   */
  export type servicesongsFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicesongs
     */
    select?: servicesongsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: servicesongsInclude<ExtArgs> | null
    /**
     * Filter, which servicesongs to fetch.
     */
    where?: servicesongsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicesongs to fetch.
     */
    orderBy?: Enumerable<servicesongsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for servicesongs.
     */
    cursor?: servicesongsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicesongs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicesongs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of servicesongs.
     */
    distinct?: Enumerable<ServicesongsScalarFieldEnum>
  }

  /**
   * servicesongs findFirst
   */
  export interface servicesongsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends servicesongsFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * servicesongs findFirstOrThrow
   */
  export type servicesongsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicesongs
     */
    select?: servicesongsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: servicesongsInclude<ExtArgs> | null
    /**
     * Filter, which servicesongs to fetch.
     */
    where?: servicesongsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicesongs to fetch.
     */
    orderBy?: Enumerable<servicesongsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for servicesongs.
     */
    cursor?: servicesongsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicesongs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicesongs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of servicesongs.
     */
    distinct?: Enumerable<ServicesongsScalarFieldEnum>
  }


  /**
   * servicesongs findMany
   */
  export type servicesongsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicesongs
     */
    select?: servicesongsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: servicesongsInclude<ExtArgs> | null
    /**
     * Filter, which servicesongs to fetch.
     */
    where?: servicesongsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicesongs to fetch.
     */
    orderBy?: Enumerable<servicesongsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing servicesongs.
     */
    cursor?: servicesongsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicesongs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicesongs.
     */
    skip?: number
    distinct?: Enumerable<ServicesongsScalarFieldEnum>
  }


  /**
   * servicesongs create
   */
  export type servicesongsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicesongs
     */
    select?: servicesongsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: servicesongsInclude<ExtArgs> | null
    /**
     * The data needed to create a servicesongs.
     */
    data: XOR<servicesongsCreateInput, servicesongsUncheckedCreateInput>
  }


  /**
   * servicesongs createMany
   */
  export type servicesongsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many servicesongs.
     */
    data: Enumerable<servicesongsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * servicesongs update
   */
  export type servicesongsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicesongs
     */
    select?: servicesongsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: servicesongsInclude<ExtArgs> | null
    /**
     * The data needed to update a servicesongs.
     */
    data: XOR<servicesongsUpdateInput, servicesongsUncheckedUpdateInput>
    /**
     * Choose, which servicesongs to update.
     */
    where: servicesongsWhereUniqueInput
  }


  /**
   * servicesongs updateMany
   */
  export type servicesongsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update servicesongs.
     */
    data: XOR<servicesongsUpdateManyMutationInput, servicesongsUncheckedUpdateManyInput>
    /**
     * Filter which servicesongs to update
     */
    where?: servicesongsWhereInput
  }


  /**
   * servicesongs upsert
   */
  export type servicesongsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicesongs
     */
    select?: servicesongsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: servicesongsInclude<ExtArgs> | null
    /**
     * The filter to search for the servicesongs to update in case it exists.
     */
    where: servicesongsWhereUniqueInput
    /**
     * In case the servicesongs found by the `where` argument doesn't exist, create a new servicesongs with this data.
     */
    create: XOR<servicesongsCreateInput, servicesongsUncheckedCreateInput>
    /**
     * In case the servicesongs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<servicesongsUpdateInput, servicesongsUncheckedUpdateInput>
  }


  /**
   * servicesongs delete
   */
  export type servicesongsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicesongs
     */
    select?: servicesongsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: servicesongsInclude<ExtArgs> | null
    /**
     * Filter which servicesongs to delete.
     */
    where: servicesongsWhereUniqueInput
  }


  /**
   * servicesongs deleteMany
   */
  export type servicesongsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which servicesongs to delete
     */
    where?: servicesongsWhereInput
  }


  /**
   * servicesongs without action
   */
  export type servicesongsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicesongs
     */
    select?: servicesongsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: servicesongsInclude<ExtArgs> | null
  }



  /**
   * Model serviceverses
   */


  export type AggregateServiceverses = {
    _count: ServiceversesCountAggregateOutputType | null
    _avg: ServiceversesAvgAggregateOutputType | null
    _sum: ServiceversesSumAggregateOutputType | null
    _min: ServiceversesMinAggregateOutputType | null
    _max: ServiceversesMaxAggregateOutputType | null
  }

  export type ServiceversesAvgAggregateOutputType = {
    id: number | null
    service_id: number | null
    startchapter: number | null
    endchapter: number | null
    startverse: number | null
    endverse: number | null
  }

  export type ServiceversesSumAggregateOutputType = {
    id: number | null
    service_id: number | null
    startchapter: number | null
    endchapter: number | null
    startverse: number | null
    endverse: number | null
  }

  export type ServiceversesMinAggregateOutputType = {
    id: number | null
    service_id: number | null
    segment_name: string | null
    testament: string | null
    startbook: string | null
    endbook: string | null
    startchapter: number | null
    endchapter: number | null
    startverse: number | null
    endverse: number | null
  }

  export type ServiceversesMaxAggregateOutputType = {
    id: number | null
    service_id: number | null
    segment_name: string | null
    testament: string | null
    startbook: string | null
    endbook: string | null
    startchapter: number | null
    endchapter: number | null
    startverse: number | null
    endverse: number | null
  }

  export type ServiceversesCountAggregateOutputType = {
    id: number
    service_id: number
    segment_name: number
    testament: number
    startbook: number
    endbook: number
    startchapter: number
    endchapter: number
    startverse: number
    endverse: number
    _all: number
  }


  export type ServiceversesAvgAggregateInputType = {
    id?: true
    service_id?: true
    startchapter?: true
    endchapter?: true
    startverse?: true
    endverse?: true
  }

  export type ServiceversesSumAggregateInputType = {
    id?: true
    service_id?: true
    startchapter?: true
    endchapter?: true
    startverse?: true
    endverse?: true
  }

  export type ServiceversesMinAggregateInputType = {
    id?: true
    service_id?: true
    segment_name?: true
    testament?: true
    startbook?: true
    endbook?: true
    startchapter?: true
    endchapter?: true
    startverse?: true
    endverse?: true
  }

  export type ServiceversesMaxAggregateInputType = {
    id?: true
    service_id?: true
    segment_name?: true
    testament?: true
    startbook?: true
    endbook?: true
    startchapter?: true
    endchapter?: true
    startverse?: true
    endverse?: true
  }

  export type ServiceversesCountAggregateInputType = {
    id?: true
    service_id?: true
    segment_name?: true
    testament?: true
    startbook?: true
    endbook?: true
    startchapter?: true
    endchapter?: true
    startverse?: true
    endverse?: true
    _all?: true
  }

  export type ServiceversesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which serviceverses to aggregate.
     */
    where?: serviceversesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of serviceverses to fetch.
     */
    orderBy?: Enumerable<serviceversesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: serviceversesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` serviceverses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` serviceverses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned serviceverses
    **/
    _count?: true | ServiceversesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceversesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceversesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceversesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceversesMaxAggregateInputType
  }

  export type GetServiceversesAggregateType<T extends ServiceversesAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceverses]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceverses[P]>
      : GetScalarType<T[P], AggregateServiceverses[P]>
  }




  export type ServiceversesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: serviceversesWhereInput
    orderBy?: Enumerable<serviceversesOrderByWithAggregationInput>
    by: ServiceversesScalarFieldEnum[]
    having?: serviceversesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceversesCountAggregateInputType | true
    _avg?: ServiceversesAvgAggregateInputType
    _sum?: ServiceversesSumAggregateInputType
    _min?: ServiceversesMinAggregateInputType
    _max?: ServiceversesMaxAggregateInputType
  }


  export type ServiceversesGroupByOutputType = {
    id: number
    service_id: number
    segment_name: string | null
    testament: string | null
    startbook: string | null
    endbook: string | null
    startchapter: number | null
    endchapter: number | null
    startverse: number | null
    endverse: number | null
    _count: ServiceversesCountAggregateOutputType | null
    _avg: ServiceversesAvgAggregateOutputType | null
    _sum: ServiceversesSumAggregateOutputType | null
    _min: ServiceversesMinAggregateOutputType | null
    _max: ServiceversesMaxAggregateOutputType | null
  }

  type GetServiceversesGroupByPayload<T extends ServiceversesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ServiceversesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceversesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceversesGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceversesGroupByOutputType[P]>
        }
      >
    >


  export type serviceversesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    service_id?: boolean
    segment_name?: boolean
    testament?: boolean
    startbook?: boolean
    endbook?: boolean
    startchapter?: boolean
    endchapter?: boolean
    startverse?: boolean
    endverse?: boolean
    services?: boolean | servicesArgs<ExtArgs>
  }, ExtArgs["result"]["serviceverses"]>

  export type serviceversesSelectScalar = {
    id?: boolean
    service_id?: boolean
    segment_name?: boolean
    testament?: boolean
    startbook?: boolean
    endbook?: boolean
    startchapter?: boolean
    endchapter?: boolean
    startverse?: boolean
    endverse?: boolean
  }

  export type serviceversesInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    services?: boolean | servicesArgs<ExtArgs>
  }


  type serviceversesGetPayload<S extends boolean | null | undefined | serviceversesArgs> = $Types.GetResult<serviceversesPayload, S>

  type serviceversesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<serviceversesFindManyArgs, 'select' | 'include'> & {
      select?: ServiceversesCountAggregateInputType | true
    }

  export interface serviceversesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['serviceverses'], meta: { name: 'serviceverses' } }
    /**
     * Find zero or one Serviceverses that matches the filter.
     * @param {serviceversesFindUniqueArgs} args - Arguments to find a Serviceverses
     * @example
     * // Get one Serviceverses
     * const serviceverses = await prisma.serviceverses.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends serviceversesFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, serviceversesFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'serviceverses'> extends True ? Prisma__serviceversesClient<$Types.GetResult<serviceversesPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__serviceversesClient<$Types.GetResult<serviceversesPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Serviceverses that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {serviceversesFindUniqueOrThrowArgs} args - Arguments to find a Serviceverses
     * @example
     * // Get one Serviceverses
     * const serviceverses = await prisma.serviceverses.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends serviceversesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, serviceversesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__serviceversesClient<$Types.GetResult<serviceversesPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Serviceverses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviceversesFindFirstArgs} args - Arguments to find a Serviceverses
     * @example
     * // Get one Serviceverses
     * const serviceverses = await prisma.serviceverses.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends serviceversesFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, serviceversesFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'serviceverses'> extends True ? Prisma__serviceversesClient<$Types.GetResult<serviceversesPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__serviceversesClient<$Types.GetResult<serviceversesPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Serviceverses that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviceversesFindFirstOrThrowArgs} args - Arguments to find a Serviceverses
     * @example
     * // Get one Serviceverses
     * const serviceverses = await prisma.serviceverses.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends serviceversesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, serviceversesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__serviceversesClient<$Types.GetResult<serviceversesPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Serviceverses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviceversesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Serviceverses
     * const serviceverses = await prisma.serviceverses.findMany()
     * 
     * // Get first 10 Serviceverses
     * const serviceverses = await prisma.serviceverses.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceversesWithIdOnly = await prisma.serviceverses.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends serviceversesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, serviceversesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<serviceversesPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Serviceverses.
     * @param {serviceversesCreateArgs} args - Arguments to create a Serviceverses.
     * @example
     * // Create one Serviceverses
     * const Serviceverses = await prisma.serviceverses.create({
     *   data: {
     *     // ... data to create a Serviceverses
     *   }
     * })
     * 
    **/
    create<T extends serviceversesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, serviceversesCreateArgs<ExtArgs>>
    ): Prisma__serviceversesClient<$Types.GetResult<serviceversesPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Serviceverses.
     *     @param {serviceversesCreateManyArgs} args - Arguments to create many Serviceverses.
     *     @example
     *     // Create many Serviceverses
     *     const serviceverses = await prisma.serviceverses.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends serviceversesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, serviceversesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Serviceverses.
     * @param {serviceversesDeleteArgs} args - Arguments to delete one Serviceverses.
     * @example
     * // Delete one Serviceverses
     * const Serviceverses = await prisma.serviceverses.delete({
     *   where: {
     *     // ... filter to delete one Serviceverses
     *   }
     * })
     * 
    **/
    delete<T extends serviceversesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, serviceversesDeleteArgs<ExtArgs>>
    ): Prisma__serviceversesClient<$Types.GetResult<serviceversesPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Serviceverses.
     * @param {serviceversesUpdateArgs} args - Arguments to update one Serviceverses.
     * @example
     * // Update one Serviceverses
     * const serviceverses = await prisma.serviceverses.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends serviceversesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, serviceversesUpdateArgs<ExtArgs>>
    ): Prisma__serviceversesClient<$Types.GetResult<serviceversesPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Serviceverses.
     * @param {serviceversesDeleteManyArgs} args - Arguments to filter Serviceverses to delete.
     * @example
     * // Delete a few Serviceverses
     * const { count } = await prisma.serviceverses.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends serviceversesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, serviceversesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Serviceverses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviceversesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Serviceverses
     * const serviceverses = await prisma.serviceverses.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends serviceversesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, serviceversesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Serviceverses.
     * @param {serviceversesUpsertArgs} args - Arguments to update or create a Serviceverses.
     * @example
     * // Update or create a Serviceverses
     * const serviceverses = await prisma.serviceverses.upsert({
     *   create: {
     *     // ... data to create a Serviceverses
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Serviceverses we want to update
     *   }
     * })
    **/
    upsert<T extends serviceversesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, serviceversesUpsertArgs<ExtArgs>>
    ): Prisma__serviceversesClient<$Types.GetResult<serviceversesPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Serviceverses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviceversesCountArgs} args - Arguments to filter Serviceverses to count.
     * @example
     * // Count the number of Serviceverses
     * const count = await prisma.serviceverses.count({
     *   where: {
     *     // ... the filter for the Serviceverses we want to count
     *   }
     * })
    **/
    count<T extends serviceversesCountArgs>(
      args?: Subset<T, serviceversesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceversesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Serviceverses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceversesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceversesAggregateArgs>(args: Subset<T, ServiceversesAggregateArgs>): Prisma.PrismaPromise<GetServiceversesAggregateType<T>>

    /**
     * Group by Serviceverses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceversesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceversesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceversesGroupByArgs['orderBy'] }
        : { orderBy?: ServiceversesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceversesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceversesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for serviceverses.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__serviceversesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    services<T extends servicesArgs<ExtArgs> = {}>(args?: Subset<T, servicesArgs<ExtArgs>>): Prisma__servicesClient<$Types.GetResult<servicesPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * serviceverses base type for findUnique actions
   */
  export type serviceversesFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceverses
     */
    select?: serviceversesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: serviceversesInclude<ExtArgs> | null
    /**
     * Filter, which serviceverses to fetch.
     */
    where: serviceversesWhereUniqueInput
  }

  /**
   * serviceverses findUnique
   */
  export interface serviceversesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends serviceversesFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * serviceverses findUniqueOrThrow
   */
  export type serviceversesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceverses
     */
    select?: serviceversesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: serviceversesInclude<ExtArgs> | null
    /**
     * Filter, which serviceverses to fetch.
     */
    where: serviceversesWhereUniqueInput
  }


  /**
   * serviceverses base type for findFirst actions
   */
  export type serviceversesFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceverses
     */
    select?: serviceversesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: serviceversesInclude<ExtArgs> | null
    /**
     * Filter, which serviceverses to fetch.
     */
    where?: serviceversesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of serviceverses to fetch.
     */
    orderBy?: Enumerable<serviceversesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for serviceverses.
     */
    cursor?: serviceversesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` serviceverses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` serviceverses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of serviceverses.
     */
    distinct?: Enumerable<ServiceversesScalarFieldEnum>
  }

  /**
   * serviceverses findFirst
   */
  export interface serviceversesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends serviceversesFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * serviceverses findFirstOrThrow
   */
  export type serviceversesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceverses
     */
    select?: serviceversesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: serviceversesInclude<ExtArgs> | null
    /**
     * Filter, which serviceverses to fetch.
     */
    where?: serviceversesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of serviceverses to fetch.
     */
    orderBy?: Enumerable<serviceversesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for serviceverses.
     */
    cursor?: serviceversesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` serviceverses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` serviceverses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of serviceverses.
     */
    distinct?: Enumerable<ServiceversesScalarFieldEnum>
  }


  /**
   * serviceverses findMany
   */
  export type serviceversesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceverses
     */
    select?: serviceversesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: serviceversesInclude<ExtArgs> | null
    /**
     * Filter, which serviceverses to fetch.
     */
    where?: serviceversesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of serviceverses to fetch.
     */
    orderBy?: Enumerable<serviceversesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing serviceverses.
     */
    cursor?: serviceversesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` serviceverses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` serviceverses.
     */
    skip?: number
    distinct?: Enumerable<ServiceversesScalarFieldEnum>
  }


  /**
   * serviceverses create
   */
  export type serviceversesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceverses
     */
    select?: serviceversesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: serviceversesInclude<ExtArgs> | null
    /**
     * The data needed to create a serviceverses.
     */
    data: XOR<serviceversesCreateInput, serviceversesUncheckedCreateInput>
  }


  /**
   * serviceverses createMany
   */
  export type serviceversesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many serviceverses.
     */
    data: Enumerable<serviceversesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * serviceverses update
   */
  export type serviceversesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceverses
     */
    select?: serviceversesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: serviceversesInclude<ExtArgs> | null
    /**
     * The data needed to update a serviceverses.
     */
    data: XOR<serviceversesUpdateInput, serviceversesUncheckedUpdateInput>
    /**
     * Choose, which serviceverses to update.
     */
    where: serviceversesWhereUniqueInput
  }


  /**
   * serviceverses updateMany
   */
  export type serviceversesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update serviceverses.
     */
    data: XOR<serviceversesUpdateManyMutationInput, serviceversesUncheckedUpdateManyInput>
    /**
     * Filter which serviceverses to update
     */
    where?: serviceversesWhereInput
  }


  /**
   * serviceverses upsert
   */
  export type serviceversesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceverses
     */
    select?: serviceversesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: serviceversesInclude<ExtArgs> | null
    /**
     * The filter to search for the serviceverses to update in case it exists.
     */
    where: serviceversesWhereUniqueInput
    /**
     * In case the serviceverses found by the `where` argument doesn't exist, create a new serviceverses with this data.
     */
    create: XOR<serviceversesCreateInput, serviceversesUncheckedCreateInput>
    /**
     * In case the serviceverses was found with the provided `where` argument, update it with this data.
     */
    update: XOR<serviceversesUpdateInput, serviceversesUncheckedUpdateInput>
  }


  /**
   * serviceverses delete
   */
  export type serviceversesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceverses
     */
    select?: serviceversesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: serviceversesInclude<ExtArgs> | null
    /**
     * Filter which serviceverses to delete.
     */
    where: serviceversesWhereUniqueInput
  }


  /**
   * serviceverses deleteMany
   */
  export type serviceversesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which serviceverses to delete
     */
    where?: serviceversesWhereInput
  }


  /**
   * serviceverses without action
   */
  export type serviceversesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceverses
     */
    select?: serviceversesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: serviceversesInclude<ExtArgs> | null
  }



  /**
   * Model smallgroups
   */


  export type AggregateSmallgroups = {
    _count: SmallgroupsCountAggregateOutputType | null
    _avg: SmallgroupsAvgAggregateOutputType | null
    _sum: SmallgroupsSumAggregateOutputType | null
    _min: SmallgroupsMinAggregateOutputType | null
    _max: SmallgroupsMaxAggregateOutputType | null
  }

  export type SmallgroupsAvgAggregateOutputType = {
    id: number | null
  }

  export type SmallgroupsSumAggregateOutputType = {
    id: number | null
  }

  export type SmallgroupsMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    resp_name: string | null
    day: string | null
    time_and_place: string | null
    is_active: boolean | null
  }

  export type SmallgroupsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    resp_name: string | null
    day: string | null
    time_and_place: string | null
    is_active: boolean | null
  }

  export type SmallgroupsCountAggregateOutputType = {
    id: number
    name: number
    description: number
    resp_name: number
    day: number
    time_and_place: number
    is_active: number
    _all: number
  }


  export type SmallgroupsAvgAggregateInputType = {
    id?: true
  }

  export type SmallgroupsSumAggregateInputType = {
    id?: true
  }

  export type SmallgroupsMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    resp_name?: true
    day?: true
    time_and_place?: true
    is_active?: true
  }

  export type SmallgroupsMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    resp_name?: true
    day?: true
    time_and_place?: true
    is_active?: true
  }

  export type SmallgroupsCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    resp_name?: true
    day?: true
    time_and_place?: true
    is_active?: true
    _all?: true
  }

  export type SmallgroupsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which smallgroups to aggregate.
     */
    where?: smallgroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of smallgroups to fetch.
     */
    orderBy?: Enumerable<smallgroupsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: smallgroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` smallgroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` smallgroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned smallgroups
    **/
    _count?: true | SmallgroupsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SmallgroupsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SmallgroupsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SmallgroupsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SmallgroupsMaxAggregateInputType
  }

  export type GetSmallgroupsAggregateType<T extends SmallgroupsAggregateArgs> = {
        [P in keyof T & keyof AggregateSmallgroups]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSmallgroups[P]>
      : GetScalarType<T[P], AggregateSmallgroups[P]>
  }




  export type SmallgroupsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: smallgroupsWhereInput
    orderBy?: Enumerable<smallgroupsOrderByWithAggregationInput>
    by: SmallgroupsScalarFieldEnum[]
    having?: smallgroupsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SmallgroupsCountAggregateInputType | true
    _avg?: SmallgroupsAvgAggregateInputType
    _sum?: SmallgroupsSumAggregateInputType
    _min?: SmallgroupsMinAggregateInputType
    _max?: SmallgroupsMaxAggregateInputType
  }


  export type SmallgroupsGroupByOutputType = {
    id: number
    name: string | null
    description: string | null
    resp_name: string | null
    day: string | null
    time_and_place: string | null
    is_active: boolean | null
    _count: SmallgroupsCountAggregateOutputType | null
    _avg: SmallgroupsAvgAggregateOutputType | null
    _sum: SmallgroupsSumAggregateOutputType | null
    _min: SmallgroupsMinAggregateOutputType | null
    _max: SmallgroupsMaxAggregateOutputType | null
  }

  type GetSmallgroupsGroupByPayload<T extends SmallgroupsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<SmallgroupsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SmallgroupsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SmallgroupsGroupByOutputType[P]>
            : GetScalarType<T[P], SmallgroupsGroupByOutputType[P]>
        }
      >
    >


  export type smallgroupsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    resp_name?: boolean
    day?: boolean
    time_and_place?: boolean
    is_active?: boolean
  }, ExtArgs["result"]["smallgroups"]>

  export type smallgroupsSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    resp_name?: boolean
    day?: boolean
    time_and_place?: boolean
    is_active?: boolean
  }


  type smallgroupsGetPayload<S extends boolean | null | undefined | smallgroupsArgs> = $Types.GetResult<smallgroupsPayload, S>

  type smallgroupsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<smallgroupsFindManyArgs, 'select' | 'include'> & {
      select?: SmallgroupsCountAggregateInputType | true
    }

  export interface smallgroupsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['smallgroups'], meta: { name: 'smallgroups' } }
    /**
     * Find zero or one Smallgroups that matches the filter.
     * @param {smallgroupsFindUniqueArgs} args - Arguments to find a Smallgroups
     * @example
     * // Get one Smallgroups
     * const smallgroups = await prisma.smallgroups.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends smallgroupsFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, smallgroupsFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'smallgroups'> extends True ? Prisma__smallgroupsClient<$Types.GetResult<smallgroupsPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__smallgroupsClient<$Types.GetResult<smallgroupsPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Smallgroups that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {smallgroupsFindUniqueOrThrowArgs} args - Arguments to find a Smallgroups
     * @example
     * // Get one Smallgroups
     * const smallgroups = await prisma.smallgroups.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends smallgroupsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, smallgroupsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__smallgroupsClient<$Types.GetResult<smallgroupsPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Smallgroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {smallgroupsFindFirstArgs} args - Arguments to find a Smallgroups
     * @example
     * // Get one Smallgroups
     * const smallgroups = await prisma.smallgroups.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends smallgroupsFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, smallgroupsFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'smallgroups'> extends True ? Prisma__smallgroupsClient<$Types.GetResult<smallgroupsPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__smallgroupsClient<$Types.GetResult<smallgroupsPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Smallgroups that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {smallgroupsFindFirstOrThrowArgs} args - Arguments to find a Smallgroups
     * @example
     * // Get one Smallgroups
     * const smallgroups = await prisma.smallgroups.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends smallgroupsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, smallgroupsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__smallgroupsClient<$Types.GetResult<smallgroupsPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Smallgroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {smallgroupsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Smallgroups
     * const smallgroups = await prisma.smallgroups.findMany()
     * 
     * // Get first 10 Smallgroups
     * const smallgroups = await prisma.smallgroups.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const smallgroupsWithIdOnly = await prisma.smallgroups.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends smallgroupsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, smallgroupsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<smallgroupsPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Smallgroups.
     * @param {smallgroupsCreateArgs} args - Arguments to create a Smallgroups.
     * @example
     * // Create one Smallgroups
     * const Smallgroups = await prisma.smallgroups.create({
     *   data: {
     *     // ... data to create a Smallgroups
     *   }
     * })
     * 
    **/
    create<T extends smallgroupsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, smallgroupsCreateArgs<ExtArgs>>
    ): Prisma__smallgroupsClient<$Types.GetResult<smallgroupsPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Smallgroups.
     *     @param {smallgroupsCreateManyArgs} args - Arguments to create many Smallgroups.
     *     @example
     *     // Create many Smallgroups
     *     const smallgroups = await prisma.smallgroups.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends smallgroupsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, smallgroupsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Smallgroups.
     * @param {smallgroupsDeleteArgs} args - Arguments to delete one Smallgroups.
     * @example
     * // Delete one Smallgroups
     * const Smallgroups = await prisma.smallgroups.delete({
     *   where: {
     *     // ... filter to delete one Smallgroups
     *   }
     * })
     * 
    **/
    delete<T extends smallgroupsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, smallgroupsDeleteArgs<ExtArgs>>
    ): Prisma__smallgroupsClient<$Types.GetResult<smallgroupsPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Smallgroups.
     * @param {smallgroupsUpdateArgs} args - Arguments to update one Smallgroups.
     * @example
     * // Update one Smallgroups
     * const smallgroups = await prisma.smallgroups.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends smallgroupsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, smallgroupsUpdateArgs<ExtArgs>>
    ): Prisma__smallgroupsClient<$Types.GetResult<smallgroupsPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Smallgroups.
     * @param {smallgroupsDeleteManyArgs} args - Arguments to filter Smallgroups to delete.
     * @example
     * // Delete a few Smallgroups
     * const { count } = await prisma.smallgroups.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends smallgroupsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, smallgroupsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Smallgroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {smallgroupsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Smallgroups
     * const smallgroups = await prisma.smallgroups.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends smallgroupsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, smallgroupsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Smallgroups.
     * @param {smallgroupsUpsertArgs} args - Arguments to update or create a Smallgroups.
     * @example
     * // Update or create a Smallgroups
     * const smallgroups = await prisma.smallgroups.upsert({
     *   create: {
     *     // ... data to create a Smallgroups
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Smallgroups we want to update
     *   }
     * })
    **/
    upsert<T extends smallgroupsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, smallgroupsUpsertArgs<ExtArgs>>
    ): Prisma__smallgroupsClient<$Types.GetResult<smallgroupsPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Smallgroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {smallgroupsCountArgs} args - Arguments to filter Smallgroups to count.
     * @example
     * // Count the number of Smallgroups
     * const count = await prisma.smallgroups.count({
     *   where: {
     *     // ... the filter for the Smallgroups we want to count
     *   }
     * })
    **/
    count<T extends smallgroupsCountArgs>(
      args?: Subset<T, smallgroupsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SmallgroupsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Smallgroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SmallgroupsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SmallgroupsAggregateArgs>(args: Subset<T, SmallgroupsAggregateArgs>): Prisma.PrismaPromise<GetSmallgroupsAggregateType<T>>

    /**
     * Group by Smallgroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SmallgroupsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SmallgroupsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SmallgroupsGroupByArgs['orderBy'] }
        : { orderBy?: SmallgroupsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SmallgroupsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSmallgroupsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for smallgroups.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__smallgroupsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * smallgroups base type for findUnique actions
   */
  export type smallgroupsFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the smallgroups
     */
    select?: smallgroupsSelect<ExtArgs> | null
    /**
     * Filter, which smallgroups to fetch.
     */
    where: smallgroupsWhereUniqueInput
  }

  /**
   * smallgroups findUnique
   */
  export interface smallgroupsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends smallgroupsFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * smallgroups findUniqueOrThrow
   */
  export type smallgroupsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the smallgroups
     */
    select?: smallgroupsSelect<ExtArgs> | null
    /**
     * Filter, which smallgroups to fetch.
     */
    where: smallgroupsWhereUniqueInput
  }


  /**
   * smallgroups base type for findFirst actions
   */
  export type smallgroupsFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the smallgroups
     */
    select?: smallgroupsSelect<ExtArgs> | null
    /**
     * Filter, which smallgroups to fetch.
     */
    where?: smallgroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of smallgroups to fetch.
     */
    orderBy?: Enumerable<smallgroupsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for smallgroups.
     */
    cursor?: smallgroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` smallgroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` smallgroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of smallgroups.
     */
    distinct?: Enumerable<SmallgroupsScalarFieldEnum>
  }

  /**
   * smallgroups findFirst
   */
  export interface smallgroupsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends smallgroupsFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * smallgroups findFirstOrThrow
   */
  export type smallgroupsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the smallgroups
     */
    select?: smallgroupsSelect<ExtArgs> | null
    /**
     * Filter, which smallgroups to fetch.
     */
    where?: smallgroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of smallgroups to fetch.
     */
    orderBy?: Enumerable<smallgroupsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for smallgroups.
     */
    cursor?: smallgroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` smallgroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` smallgroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of smallgroups.
     */
    distinct?: Enumerable<SmallgroupsScalarFieldEnum>
  }


  /**
   * smallgroups findMany
   */
  export type smallgroupsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the smallgroups
     */
    select?: smallgroupsSelect<ExtArgs> | null
    /**
     * Filter, which smallgroups to fetch.
     */
    where?: smallgroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of smallgroups to fetch.
     */
    orderBy?: Enumerable<smallgroupsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing smallgroups.
     */
    cursor?: smallgroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` smallgroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` smallgroups.
     */
    skip?: number
    distinct?: Enumerable<SmallgroupsScalarFieldEnum>
  }


  /**
   * smallgroups create
   */
  export type smallgroupsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the smallgroups
     */
    select?: smallgroupsSelect<ExtArgs> | null
    /**
     * The data needed to create a smallgroups.
     */
    data?: XOR<smallgroupsCreateInput, smallgroupsUncheckedCreateInput>
  }


  /**
   * smallgroups createMany
   */
  export type smallgroupsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many smallgroups.
     */
    data: Enumerable<smallgroupsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * smallgroups update
   */
  export type smallgroupsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the smallgroups
     */
    select?: smallgroupsSelect<ExtArgs> | null
    /**
     * The data needed to update a smallgroups.
     */
    data: XOR<smallgroupsUpdateInput, smallgroupsUncheckedUpdateInput>
    /**
     * Choose, which smallgroups to update.
     */
    where: smallgroupsWhereUniqueInput
  }


  /**
   * smallgroups updateMany
   */
  export type smallgroupsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update smallgroups.
     */
    data: XOR<smallgroupsUpdateManyMutationInput, smallgroupsUncheckedUpdateManyInput>
    /**
     * Filter which smallgroups to update
     */
    where?: smallgroupsWhereInput
  }


  /**
   * smallgroups upsert
   */
  export type smallgroupsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the smallgroups
     */
    select?: smallgroupsSelect<ExtArgs> | null
    /**
     * The filter to search for the smallgroups to update in case it exists.
     */
    where: smallgroupsWhereUniqueInput
    /**
     * In case the smallgroups found by the `where` argument doesn't exist, create a new smallgroups with this data.
     */
    create: XOR<smallgroupsCreateInput, smallgroupsUncheckedCreateInput>
    /**
     * In case the smallgroups was found with the provided `where` argument, update it with this data.
     */
    update: XOR<smallgroupsUpdateInput, smallgroupsUncheckedUpdateInput>
  }


  /**
   * smallgroups delete
   */
  export type smallgroupsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the smallgroups
     */
    select?: smallgroupsSelect<ExtArgs> | null
    /**
     * Filter which smallgroups to delete.
     */
    where: smallgroupsWhereUniqueInput
  }


  /**
   * smallgroups deleteMany
   */
  export type smallgroupsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which smallgroups to delete
     */
    where?: smallgroupsWhereInput
  }


  /**
   * smallgroups without action
   */
  export type smallgroupsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the smallgroups
     */
    select?: smallgroupsSelect<ExtArgs> | null
  }



  /**
   * Model songdata
   */


  export type AggregateSongdata = {
    _count: SongdataCountAggregateOutputType | null
    _avg: SongdataAvgAggregateOutputType | null
    _sum: SongdataSumAggregateOutputType | null
    _min: SongdataMinAggregateOutputType | null
    _max: SongdataMaxAggregateOutputType | null
  }

  export type SongdataAvgAggregateOutputType = {
    id: number | null
  }

  export type SongdataSumAggregateOutputType = {
    id: number | null
  }

  export type SongdataMinAggregateOutputType = {
    id: number | null
    title: string | null
    composer: string | null
    lyrics: string | null
    version_description: string | null
  }

  export type SongdataMaxAggregateOutputType = {
    id: number | null
    title: string | null
    composer: string | null
    lyrics: string | null
    version_description: string | null
  }

  export type SongdataCountAggregateOutputType = {
    id: number
    title: number
    composer: number
    lyrics: number
    version_description: number
    _all: number
  }


  export type SongdataAvgAggregateInputType = {
    id?: true
  }

  export type SongdataSumAggregateInputType = {
    id?: true
  }

  export type SongdataMinAggregateInputType = {
    id?: true
    title?: true
    composer?: true
    lyrics?: true
    version_description?: true
  }

  export type SongdataMaxAggregateInputType = {
    id?: true
    title?: true
    composer?: true
    lyrics?: true
    version_description?: true
  }

  export type SongdataCountAggregateInputType = {
    id?: true
    title?: true
    composer?: true
    lyrics?: true
    version_description?: true
    _all?: true
  }

  export type SongdataAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which songdata to aggregate.
     */
    where?: songdataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of songdata to fetch.
     */
    orderBy?: Enumerable<songdataOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: songdataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` songdata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` songdata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned songdata
    **/
    _count?: true | SongdataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SongdataAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SongdataSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SongdataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SongdataMaxAggregateInputType
  }

  export type GetSongdataAggregateType<T extends SongdataAggregateArgs> = {
        [P in keyof T & keyof AggregateSongdata]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSongdata[P]>
      : GetScalarType<T[P], AggregateSongdata[P]>
  }




  export type SongdataGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: songdataWhereInput
    orderBy?: Enumerable<songdataOrderByWithAggregationInput>
    by: SongdataScalarFieldEnum[]
    having?: songdataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SongdataCountAggregateInputType | true
    _avg?: SongdataAvgAggregateInputType
    _sum?: SongdataSumAggregateInputType
    _min?: SongdataMinAggregateInputType
    _max?: SongdataMaxAggregateInputType
  }


  export type SongdataGroupByOutputType = {
    id: number
    title: string | null
    composer: string | null
    lyrics: string | null
    version_description: string | null
    _count: SongdataCountAggregateOutputType | null
    _avg: SongdataAvgAggregateOutputType | null
    _sum: SongdataSumAggregateOutputType | null
    _min: SongdataMinAggregateOutputType | null
    _max: SongdataMaxAggregateOutputType | null
  }

  type GetSongdataGroupByPayload<T extends SongdataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<SongdataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SongdataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SongdataGroupByOutputType[P]>
            : GetScalarType<T[P], SongdataGroupByOutputType[P]>
        }
      >
    >


  export type songdataSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    composer?: boolean
    lyrics?: boolean
    version_description?: boolean
    songtags?: boolean | songdata$songtagsArgs<ExtArgs>
    versedata?: boolean | songdata$versedataArgs<ExtArgs>
    _count?: boolean | SongdataCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["songdata"]>

  export type songdataSelectScalar = {
    id?: boolean
    title?: boolean
    composer?: boolean
    lyrics?: boolean
    version_description?: boolean
  }

  export type songdataInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    songtags?: boolean | songdata$songtagsArgs<ExtArgs>
    versedata?: boolean | songdata$versedataArgs<ExtArgs>
    _count?: boolean | SongdataCountOutputTypeArgs<ExtArgs>
  }


  type songdataGetPayload<S extends boolean | null | undefined | songdataArgs> = $Types.GetResult<songdataPayload, S>

  type songdataCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<songdataFindManyArgs, 'select' | 'include'> & {
      select?: SongdataCountAggregateInputType | true
    }

  export interface songdataDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['songdata'], meta: { name: 'songdata' } }
    /**
     * Find zero or one Songdata that matches the filter.
     * @param {songdataFindUniqueArgs} args - Arguments to find a Songdata
     * @example
     * // Get one Songdata
     * const songdata = await prisma.songdata.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends songdataFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, songdataFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'songdata'> extends True ? Prisma__songdataClient<$Types.GetResult<songdataPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__songdataClient<$Types.GetResult<songdataPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Songdata that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {songdataFindUniqueOrThrowArgs} args - Arguments to find a Songdata
     * @example
     * // Get one Songdata
     * const songdata = await prisma.songdata.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends songdataFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, songdataFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__songdataClient<$Types.GetResult<songdataPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Songdata that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {songdataFindFirstArgs} args - Arguments to find a Songdata
     * @example
     * // Get one Songdata
     * const songdata = await prisma.songdata.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends songdataFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, songdataFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'songdata'> extends True ? Prisma__songdataClient<$Types.GetResult<songdataPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__songdataClient<$Types.GetResult<songdataPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Songdata that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {songdataFindFirstOrThrowArgs} args - Arguments to find a Songdata
     * @example
     * // Get one Songdata
     * const songdata = await prisma.songdata.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends songdataFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, songdataFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__songdataClient<$Types.GetResult<songdataPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Songdata that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {songdataFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Songdata
     * const songdata = await prisma.songdata.findMany()
     * 
     * // Get first 10 Songdata
     * const songdata = await prisma.songdata.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const songdataWithIdOnly = await prisma.songdata.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends songdataFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, songdataFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<songdataPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Songdata.
     * @param {songdataCreateArgs} args - Arguments to create a Songdata.
     * @example
     * // Create one Songdata
     * const Songdata = await prisma.songdata.create({
     *   data: {
     *     // ... data to create a Songdata
     *   }
     * })
     * 
    **/
    create<T extends songdataCreateArgs<ExtArgs>>(
      args: SelectSubset<T, songdataCreateArgs<ExtArgs>>
    ): Prisma__songdataClient<$Types.GetResult<songdataPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Songdata.
     *     @param {songdataCreateManyArgs} args - Arguments to create many Songdata.
     *     @example
     *     // Create many Songdata
     *     const songdata = await prisma.songdata.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends songdataCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, songdataCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Songdata.
     * @param {songdataDeleteArgs} args - Arguments to delete one Songdata.
     * @example
     * // Delete one Songdata
     * const Songdata = await prisma.songdata.delete({
     *   where: {
     *     // ... filter to delete one Songdata
     *   }
     * })
     * 
    **/
    delete<T extends songdataDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, songdataDeleteArgs<ExtArgs>>
    ): Prisma__songdataClient<$Types.GetResult<songdataPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Songdata.
     * @param {songdataUpdateArgs} args - Arguments to update one Songdata.
     * @example
     * // Update one Songdata
     * const songdata = await prisma.songdata.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends songdataUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, songdataUpdateArgs<ExtArgs>>
    ): Prisma__songdataClient<$Types.GetResult<songdataPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Songdata.
     * @param {songdataDeleteManyArgs} args - Arguments to filter Songdata to delete.
     * @example
     * // Delete a few Songdata
     * const { count } = await prisma.songdata.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends songdataDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, songdataDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Songdata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {songdataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Songdata
     * const songdata = await prisma.songdata.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends songdataUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, songdataUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Songdata.
     * @param {songdataUpsertArgs} args - Arguments to update or create a Songdata.
     * @example
     * // Update or create a Songdata
     * const songdata = await prisma.songdata.upsert({
     *   create: {
     *     // ... data to create a Songdata
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Songdata we want to update
     *   }
     * })
    **/
    upsert<T extends songdataUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, songdataUpsertArgs<ExtArgs>>
    ): Prisma__songdataClient<$Types.GetResult<songdataPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Songdata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {songdataCountArgs} args - Arguments to filter Songdata to count.
     * @example
     * // Count the number of Songdata
     * const count = await prisma.songdata.count({
     *   where: {
     *     // ... the filter for the Songdata we want to count
     *   }
     * })
    **/
    count<T extends songdataCountArgs>(
      args?: Subset<T, songdataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SongdataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Songdata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SongdataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SongdataAggregateArgs>(args: Subset<T, SongdataAggregateArgs>): Prisma.PrismaPromise<GetSongdataAggregateType<T>>

    /**
     * Group by Songdata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SongdataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SongdataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SongdataGroupByArgs['orderBy'] }
        : { orderBy?: SongdataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SongdataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSongdataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for songdata.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__songdataClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    songtags<T extends songdata$songtagsArgs<ExtArgs> = {}>(args?: Subset<T, songdata$songtagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<songtagsPayload<ExtArgs>, T, 'findMany', never>| Null>;

    versedata<T extends songdata$versedataArgs<ExtArgs> = {}>(args?: Subset<T, songdata$versedataArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<versedataPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * songdata base type for findUnique actions
   */
  export type songdataFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the songdata
     */
    select?: songdataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: songdataInclude<ExtArgs> | null
    /**
     * Filter, which songdata to fetch.
     */
    where: songdataWhereUniqueInput
  }

  /**
   * songdata findUnique
   */
  export interface songdataFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends songdataFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * songdata findUniqueOrThrow
   */
  export type songdataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the songdata
     */
    select?: songdataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: songdataInclude<ExtArgs> | null
    /**
     * Filter, which songdata to fetch.
     */
    where: songdataWhereUniqueInput
  }


  /**
   * songdata base type for findFirst actions
   */
  export type songdataFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the songdata
     */
    select?: songdataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: songdataInclude<ExtArgs> | null
    /**
     * Filter, which songdata to fetch.
     */
    where?: songdataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of songdata to fetch.
     */
    orderBy?: Enumerable<songdataOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for songdata.
     */
    cursor?: songdataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` songdata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` songdata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of songdata.
     */
    distinct?: Enumerable<SongdataScalarFieldEnum>
  }

  /**
   * songdata findFirst
   */
  export interface songdataFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends songdataFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * songdata findFirstOrThrow
   */
  export type songdataFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the songdata
     */
    select?: songdataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: songdataInclude<ExtArgs> | null
    /**
     * Filter, which songdata to fetch.
     */
    where?: songdataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of songdata to fetch.
     */
    orderBy?: Enumerable<songdataOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for songdata.
     */
    cursor?: songdataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` songdata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` songdata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of songdata.
     */
    distinct?: Enumerable<SongdataScalarFieldEnum>
  }


  /**
   * songdata findMany
   */
  export type songdataFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the songdata
     */
    select?: songdataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: songdataInclude<ExtArgs> | null
    /**
     * Filter, which songdata to fetch.
     */
    where?: songdataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of songdata to fetch.
     */
    orderBy?: Enumerable<songdataOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing songdata.
     */
    cursor?: songdataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` songdata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` songdata.
     */
    skip?: number
    distinct?: Enumerable<SongdataScalarFieldEnum>
  }


  /**
   * songdata create
   */
  export type songdataCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the songdata
     */
    select?: songdataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: songdataInclude<ExtArgs> | null
    /**
     * The data needed to create a songdata.
     */
    data?: XOR<songdataCreateInput, songdataUncheckedCreateInput>
  }


  /**
   * songdata createMany
   */
  export type songdataCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many songdata.
     */
    data: Enumerable<songdataCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * songdata update
   */
  export type songdataUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the songdata
     */
    select?: songdataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: songdataInclude<ExtArgs> | null
    /**
     * The data needed to update a songdata.
     */
    data: XOR<songdataUpdateInput, songdataUncheckedUpdateInput>
    /**
     * Choose, which songdata to update.
     */
    where: songdataWhereUniqueInput
  }


  /**
   * songdata updateMany
   */
  export type songdataUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update songdata.
     */
    data: XOR<songdataUpdateManyMutationInput, songdataUncheckedUpdateManyInput>
    /**
     * Filter which songdata to update
     */
    where?: songdataWhereInput
  }


  /**
   * songdata upsert
   */
  export type songdataUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the songdata
     */
    select?: songdataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: songdataInclude<ExtArgs> | null
    /**
     * The filter to search for the songdata to update in case it exists.
     */
    where: songdataWhereUniqueInput
    /**
     * In case the songdata found by the `where` argument doesn't exist, create a new songdata with this data.
     */
    create: XOR<songdataCreateInput, songdataUncheckedCreateInput>
    /**
     * In case the songdata was found with the provided `where` argument, update it with this data.
     */
    update: XOR<songdataUpdateInput, songdataUncheckedUpdateInput>
  }


  /**
   * songdata delete
   */
  export type songdataDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the songdata
     */
    select?: songdataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: songdataInclude<ExtArgs> | null
    /**
     * Filter which songdata to delete.
     */
    where: songdataWhereUniqueInput
  }


  /**
   * songdata deleteMany
   */
  export type songdataDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which songdata to delete
     */
    where?: songdataWhereInput
  }


  /**
   * songdata.songtags
   */
  export type songdata$songtagsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the songtags
     */
    select?: songtagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: songtagsInclude<ExtArgs> | null
    where?: songtagsWhereInput
    orderBy?: Enumerable<songtagsOrderByWithRelationInput>
    cursor?: songtagsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SongtagsScalarFieldEnum>
  }


  /**
   * songdata.versedata
   */
  export type songdata$versedataArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the versedata
     */
    select?: versedataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: versedataInclude<ExtArgs> | null
    where?: versedataWhereInput
    orderBy?: Enumerable<versedataOrderByWithRelationInput>
    cursor?: versedataWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<VersedataScalarFieldEnum>
  }


  /**
   * songdata without action
   */
  export type songdataArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the songdata
     */
    select?: songdataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: songdataInclude<ExtArgs> | null
  }



  /**
   * Model songsegments
   */


  export type AggregateSongsegments = {
    _count: SongsegmentsCountAggregateOutputType | null
    _avg: SongsegmentsAvgAggregateOutputType | null
    _sum: SongsegmentsSumAggregateOutputType | null
    _min: SongsegmentsMinAggregateOutputType | null
    _max: SongsegmentsMaxAggregateOutputType | null
  }

  export type SongsegmentsAvgAggregateOutputType = {
    id: number | null
  }

  export type SongsegmentsSumAggregateOutputType = {
    id: number | null
  }

  export type SongsegmentsMinAggregateOutputType = {
    id: number | null
    songdescription: string | null
    restrictedto: string | null
    singlename: string | null
    is_multi: boolean | null
    segment_name_is_title: boolean | null
  }

  export type SongsegmentsMaxAggregateOutputType = {
    id: number | null
    songdescription: string | null
    restrictedto: string | null
    singlename: string | null
    is_multi: boolean | null
    segment_name_is_title: boolean | null
  }

  export type SongsegmentsCountAggregateOutputType = {
    id: number
    songdescription: number
    restrictedto: number
    singlename: number
    is_multi: number
    segment_name_is_title: number
    _all: number
  }


  export type SongsegmentsAvgAggregateInputType = {
    id?: true
  }

  export type SongsegmentsSumAggregateInputType = {
    id?: true
  }

  export type SongsegmentsMinAggregateInputType = {
    id?: true
    songdescription?: true
    restrictedto?: true
    singlename?: true
    is_multi?: true
    segment_name_is_title?: true
  }

  export type SongsegmentsMaxAggregateInputType = {
    id?: true
    songdescription?: true
    restrictedto?: true
    singlename?: true
    is_multi?: true
    segment_name_is_title?: true
  }

  export type SongsegmentsCountAggregateInputType = {
    id?: true
    songdescription?: true
    restrictedto?: true
    singlename?: true
    is_multi?: true
    segment_name_is_title?: true
    _all?: true
  }

  export type SongsegmentsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which songsegments to aggregate.
     */
    where?: songsegmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of songsegments to fetch.
     */
    orderBy?: Enumerable<songsegmentsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: songsegmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` songsegments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` songsegments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned songsegments
    **/
    _count?: true | SongsegmentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SongsegmentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SongsegmentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SongsegmentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SongsegmentsMaxAggregateInputType
  }

  export type GetSongsegmentsAggregateType<T extends SongsegmentsAggregateArgs> = {
        [P in keyof T & keyof AggregateSongsegments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSongsegments[P]>
      : GetScalarType<T[P], AggregateSongsegments[P]>
  }




  export type SongsegmentsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: songsegmentsWhereInput
    orderBy?: Enumerable<songsegmentsOrderByWithAggregationInput>
    by: SongsegmentsScalarFieldEnum[]
    having?: songsegmentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SongsegmentsCountAggregateInputType | true
    _avg?: SongsegmentsAvgAggregateInputType
    _sum?: SongsegmentsSumAggregateInputType
    _min?: SongsegmentsMinAggregateInputType
    _max?: SongsegmentsMaxAggregateInputType
  }


  export type SongsegmentsGroupByOutputType = {
    id: number
    songdescription: string | null
    restrictedto: string | null
    singlename: string | null
    is_multi: boolean | null
    segment_name_is_title: boolean | null
    _count: SongsegmentsCountAggregateOutputType | null
    _avg: SongsegmentsAvgAggregateOutputType | null
    _sum: SongsegmentsSumAggregateOutputType | null
    _min: SongsegmentsMinAggregateOutputType | null
    _max: SongsegmentsMaxAggregateOutputType | null
  }

  type GetSongsegmentsGroupByPayload<T extends SongsegmentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<SongsegmentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SongsegmentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SongsegmentsGroupByOutputType[P]>
            : GetScalarType<T[P], SongsegmentsGroupByOutputType[P]>
        }
      >
    >


  export type songsegmentsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    songdescription?: boolean
    restrictedto?: boolean
    singlename?: boolean
    is_multi?: boolean
    segment_name_is_title?: boolean
  }, ExtArgs["result"]["songsegments"]>

  export type songsegmentsSelectScalar = {
    id?: boolean
    songdescription?: boolean
    restrictedto?: boolean
    singlename?: boolean
    is_multi?: boolean
    segment_name_is_title?: boolean
  }


  type songsegmentsGetPayload<S extends boolean | null | undefined | songsegmentsArgs> = $Types.GetResult<songsegmentsPayload, S>

  type songsegmentsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<songsegmentsFindManyArgs, 'select' | 'include'> & {
      select?: SongsegmentsCountAggregateInputType | true
    }

  export interface songsegmentsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['songsegments'], meta: { name: 'songsegments' } }
    /**
     * Find zero or one Songsegments that matches the filter.
     * @param {songsegmentsFindUniqueArgs} args - Arguments to find a Songsegments
     * @example
     * // Get one Songsegments
     * const songsegments = await prisma.songsegments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends songsegmentsFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, songsegmentsFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'songsegments'> extends True ? Prisma__songsegmentsClient<$Types.GetResult<songsegmentsPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__songsegmentsClient<$Types.GetResult<songsegmentsPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Songsegments that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {songsegmentsFindUniqueOrThrowArgs} args - Arguments to find a Songsegments
     * @example
     * // Get one Songsegments
     * const songsegments = await prisma.songsegments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends songsegmentsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, songsegmentsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__songsegmentsClient<$Types.GetResult<songsegmentsPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Songsegments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {songsegmentsFindFirstArgs} args - Arguments to find a Songsegments
     * @example
     * // Get one Songsegments
     * const songsegments = await prisma.songsegments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends songsegmentsFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, songsegmentsFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'songsegments'> extends True ? Prisma__songsegmentsClient<$Types.GetResult<songsegmentsPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__songsegmentsClient<$Types.GetResult<songsegmentsPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Songsegments that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {songsegmentsFindFirstOrThrowArgs} args - Arguments to find a Songsegments
     * @example
     * // Get one Songsegments
     * const songsegments = await prisma.songsegments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends songsegmentsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, songsegmentsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__songsegmentsClient<$Types.GetResult<songsegmentsPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Songsegments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {songsegmentsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Songsegments
     * const songsegments = await prisma.songsegments.findMany()
     * 
     * // Get first 10 Songsegments
     * const songsegments = await prisma.songsegments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const songsegmentsWithIdOnly = await prisma.songsegments.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends songsegmentsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, songsegmentsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<songsegmentsPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Songsegments.
     * @param {songsegmentsCreateArgs} args - Arguments to create a Songsegments.
     * @example
     * // Create one Songsegments
     * const Songsegments = await prisma.songsegments.create({
     *   data: {
     *     // ... data to create a Songsegments
     *   }
     * })
     * 
    **/
    create<T extends songsegmentsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, songsegmentsCreateArgs<ExtArgs>>
    ): Prisma__songsegmentsClient<$Types.GetResult<songsegmentsPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Songsegments.
     *     @param {songsegmentsCreateManyArgs} args - Arguments to create many Songsegments.
     *     @example
     *     // Create many Songsegments
     *     const songsegments = await prisma.songsegments.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends songsegmentsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, songsegmentsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Songsegments.
     * @param {songsegmentsDeleteArgs} args - Arguments to delete one Songsegments.
     * @example
     * // Delete one Songsegments
     * const Songsegments = await prisma.songsegments.delete({
     *   where: {
     *     // ... filter to delete one Songsegments
     *   }
     * })
     * 
    **/
    delete<T extends songsegmentsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, songsegmentsDeleteArgs<ExtArgs>>
    ): Prisma__songsegmentsClient<$Types.GetResult<songsegmentsPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Songsegments.
     * @param {songsegmentsUpdateArgs} args - Arguments to update one Songsegments.
     * @example
     * // Update one Songsegments
     * const songsegments = await prisma.songsegments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends songsegmentsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, songsegmentsUpdateArgs<ExtArgs>>
    ): Prisma__songsegmentsClient<$Types.GetResult<songsegmentsPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Songsegments.
     * @param {songsegmentsDeleteManyArgs} args - Arguments to filter Songsegments to delete.
     * @example
     * // Delete a few Songsegments
     * const { count } = await prisma.songsegments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends songsegmentsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, songsegmentsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Songsegments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {songsegmentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Songsegments
     * const songsegments = await prisma.songsegments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends songsegmentsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, songsegmentsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Songsegments.
     * @param {songsegmentsUpsertArgs} args - Arguments to update or create a Songsegments.
     * @example
     * // Update or create a Songsegments
     * const songsegments = await prisma.songsegments.upsert({
     *   create: {
     *     // ... data to create a Songsegments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Songsegments we want to update
     *   }
     * })
    **/
    upsert<T extends songsegmentsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, songsegmentsUpsertArgs<ExtArgs>>
    ): Prisma__songsegmentsClient<$Types.GetResult<songsegmentsPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Songsegments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {songsegmentsCountArgs} args - Arguments to filter Songsegments to count.
     * @example
     * // Count the number of Songsegments
     * const count = await prisma.songsegments.count({
     *   where: {
     *     // ... the filter for the Songsegments we want to count
     *   }
     * })
    **/
    count<T extends songsegmentsCountArgs>(
      args?: Subset<T, songsegmentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SongsegmentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Songsegments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SongsegmentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SongsegmentsAggregateArgs>(args: Subset<T, SongsegmentsAggregateArgs>): Prisma.PrismaPromise<GetSongsegmentsAggregateType<T>>

    /**
     * Group by Songsegments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SongsegmentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SongsegmentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SongsegmentsGroupByArgs['orderBy'] }
        : { orderBy?: SongsegmentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SongsegmentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSongsegmentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for songsegments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__songsegmentsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * songsegments base type for findUnique actions
   */
  export type songsegmentsFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the songsegments
     */
    select?: songsegmentsSelect<ExtArgs> | null
    /**
     * Filter, which songsegments to fetch.
     */
    where: songsegmentsWhereUniqueInput
  }

  /**
   * songsegments findUnique
   */
  export interface songsegmentsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends songsegmentsFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * songsegments findUniqueOrThrow
   */
  export type songsegmentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the songsegments
     */
    select?: songsegmentsSelect<ExtArgs> | null
    /**
     * Filter, which songsegments to fetch.
     */
    where: songsegmentsWhereUniqueInput
  }


  /**
   * songsegments base type for findFirst actions
   */
  export type songsegmentsFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the songsegments
     */
    select?: songsegmentsSelect<ExtArgs> | null
    /**
     * Filter, which songsegments to fetch.
     */
    where?: songsegmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of songsegments to fetch.
     */
    orderBy?: Enumerable<songsegmentsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for songsegments.
     */
    cursor?: songsegmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` songsegments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` songsegments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of songsegments.
     */
    distinct?: Enumerable<SongsegmentsScalarFieldEnum>
  }

  /**
   * songsegments findFirst
   */
  export interface songsegmentsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends songsegmentsFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * songsegments findFirstOrThrow
   */
  export type songsegmentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the songsegments
     */
    select?: songsegmentsSelect<ExtArgs> | null
    /**
     * Filter, which songsegments to fetch.
     */
    where?: songsegmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of songsegments to fetch.
     */
    orderBy?: Enumerable<songsegmentsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for songsegments.
     */
    cursor?: songsegmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` songsegments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` songsegments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of songsegments.
     */
    distinct?: Enumerable<SongsegmentsScalarFieldEnum>
  }


  /**
   * songsegments findMany
   */
  export type songsegmentsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the songsegments
     */
    select?: songsegmentsSelect<ExtArgs> | null
    /**
     * Filter, which songsegments to fetch.
     */
    where?: songsegmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of songsegments to fetch.
     */
    orderBy?: Enumerable<songsegmentsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing songsegments.
     */
    cursor?: songsegmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` songsegments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` songsegments.
     */
    skip?: number
    distinct?: Enumerable<SongsegmentsScalarFieldEnum>
  }


  /**
   * songsegments create
   */
  export type songsegmentsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the songsegments
     */
    select?: songsegmentsSelect<ExtArgs> | null
    /**
     * The data needed to create a songsegments.
     */
    data?: XOR<songsegmentsCreateInput, songsegmentsUncheckedCreateInput>
  }


  /**
   * songsegments createMany
   */
  export type songsegmentsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many songsegments.
     */
    data: Enumerable<songsegmentsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * songsegments update
   */
  export type songsegmentsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the songsegments
     */
    select?: songsegmentsSelect<ExtArgs> | null
    /**
     * The data needed to update a songsegments.
     */
    data: XOR<songsegmentsUpdateInput, songsegmentsUncheckedUpdateInput>
    /**
     * Choose, which songsegments to update.
     */
    where: songsegmentsWhereUniqueInput
  }


  /**
   * songsegments updateMany
   */
  export type songsegmentsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update songsegments.
     */
    data: XOR<songsegmentsUpdateManyMutationInput, songsegmentsUncheckedUpdateManyInput>
    /**
     * Filter which songsegments to update
     */
    where?: songsegmentsWhereInput
  }


  /**
   * songsegments upsert
   */
  export type songsegmentsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the songsegments
     */
    select?: songsegmentsSelect<ExtArgs> | null
    /**
     * The filter to search for the songsegments to update in case it exists.
     */
    where: songsegmentsWhereUniqueInput
    /**
     * In case the songsegments found by the `where` argument doesn't exist, create a new songsegments with this data.
     */
    create: XOR<songsegmentsCreateInput, songsegmentsUncheckedCreateInput>
    /**
     * In case the songsegments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<songsegmentsUpdateInput, songsegmentsUncheckedUpdateInput>
  }


  /**
   * songsegments delete
   */
  export type songsegmentsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the songsegments
     */
    select?: songsegmentsSelect<ExtArgs> | null
    /**
     * Filter which songsegments to delete.
     */
    where: songsegmentsWhereUniqueInput
  }


  /**
   * songsegments deleteMany
   */
  export type songsegmentsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which songsegments to delete
     */
    where?: songsegmentsWhereInput
  }


  /**
   * songsegments without action
   */
  export type songsegmentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the songsegments
     */
    select?: songsegmentsSelect<ExtArgs> | null
  }



  /**
   * Model songtags
   */


  export type AggregateSongtags = {
    _count: SongtagsCountAggregateOutputType | null
    _avg: SongtagsAvgAggregateOutputType | null
    _sum: SongtagsSumAggregateOutputType | null
    _min: SongtagsMinAggregateOutputType | null
    _max: SongtagsMaxAggregateOutputType | null
  }

  export type SongtagsAvgAggregateOutputType = {
    id: number | null
    song_id: number | null
  }

  export type SongtagsSumAggregateOutputType = {
    id: number | null
    song_id: number | null
  }

  export type SongtagsMinAggregateOutputType = {
    id: number | null
    song_id: number | null
    tag: string | null
  }

  export type SongtagsMaxAggregateOutputType = {
    id: number | null
    song_id: number | null
    tag: string | null
  }

  export type SongtagsCountAggregateOutputType = {
    id: number
    song_id: number
    tag: number
    _all: number
  }


  export type SongtagsAvgAggregateInputType = {
    id?: true
    song_id?: true
  }

  export type SongtagsSumAggregateInputType = {
    id?: true
    song_id?: true
  }

  export type SongtagsMinAggregateInputType = {
    id?: true
    song_id?: true
    tag?: true
  }

  export type SongtagsMaxAggregateInputType = {
    id?: true
    song_id?: true
    tag?: true
  }

  export type SongtagsCountAggregateInputType = {
    id?: true
    song_id?: true
    tag?: true
    _all?: true
  }

  export type SongtagsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which songtags to aggregate.
     */
    where?: songtagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of songtags to fetch.
     */
    orderBy?: Enumerable<songtagsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: songtagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` songtags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` songtags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned songtags
    **/
    _count?: true | SongtagsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SongtagsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SongtagsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SongtagsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SongtagsMaxAggregateInputType
  }

  export type GetSongtagsAggregateType<T extends SongtagsAggregateArgs> = {
        [P in keyof T & keyof AggregateSongtags]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSongtags[P]>
      : GetScalarType<T[P], AggregateSongtags[P]>
  }




  export type SongtagsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: songtagsWhereInput
    orderBy?: Enumerable<songtagsOrderByWithAggregationInput>
    by: SongtagsScalarFieldEnum[]
    having?: songtagsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SongtagsCountAggregateInputType | true
    _avg?: SongtagsAvgAggregateInputType
    _sum?: SongtagsSumAggregateInputType
    _min?: SongtagsMinAggregateInputType
    _max?: SongtagsMaxAggregateInputType
  }


  export type SongtagsGroupByOutputType = {
    id: number
    song_id: number
    tag: string | null
    _count: SongtagsCountAggregateOutputType | null
    _avg: SongtagsAvgAggregateOutputType | null
    _sum: SongtagsSumAggregateOutputType | null
    _min: SongtagsMinAggregateOutputType | null
    _max: SongtagsMaxAggregateOutputType | null
  }

  type GetSongtagsGroupByPayload<T extends SongtagsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<SongtagsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SongtagsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SongtagsGroupByOutputType[P]>
            : GetScalarType<T[P], SongtagsGroupByOutputType[P]>
        }
      >
    >


  export type songtagsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    song_id?: boolean
    tag?: boolean
    songdata?: boolean | songdataArgs<ExtArgs>
  }, ExtArgs["result"]["songtags"]>

  export type songtagsSelectScalar = {
    id?: boolean
    song_id?: boolean
    tag?: boolean
  }

  export type songtagsInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    songdata?: boolean | songdataArgs<ExtArgs>
  }


  type songtagsGetPayload<S extends boolean | null | undefined | songtagsArgs> = $Types.GetResult<songtagsPayload, S>

  type songtagsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<songtagsFindManyArgs, 'select' | 'include'> & {
      select?: SongtagsCountAggregateInputType | true
    }

  export interface songtagsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['songtags'], meta: { name: 'songtags' } }
    /**
     * Find zero or one Songtags that matches the filter.
     * @param {songtagsFindUniqueArgs} args - Arguments to find a Songtags
     * @example
     * // Get one Songtags
     * const songtags = await prisma.songtags.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends songtagsFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, songtagsFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'songtags'> extends True ? Prisma__songtagsClient<$Types.GetResult<songtagsPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__songtagsClient<$Types.GetResult<songtagsPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Songtags that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {songtagsFindUniqueOrThrowArgs} args - Arguments to find a Songtags
     * @example
     * // Get one Songtags
     * const songtags = await prisma.songtags.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends songtagsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, songtagsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__songtagsClient<$Types.GetResult<songtagsPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Songtags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {songtagsFindFirstArgs} args - Arguments to find a Songtags
     * @example
     * // Get one Songtags
     * const songtags = await prisma.songtags.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends songtagsFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, songtagsFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'songtags'> extends True ? Prisma__songtagsClient<$Types.GetResult<songtagsPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__songtagsClient<$Types.GetResult<songtagsPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Songtags that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {songtagsFindFirstOrThrowArgs} args - Arguments to find a Songtags
     * @example
     * // Get one Songtags
     * const songtags = await prisma.songtags.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends songtagsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, songtagsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__songtagsClient<$Types.GetResult<songtagsPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Songtags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {songtagsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Songtags
     * const songtags = await prisma.songtags.findMany()
     * 
     * // Get first 10 Songtags
     * const songtags = await prisma.songtags.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const songtagsWithIdOnly = await prisma.songtags.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends songtagsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, songtagsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<songtagsPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Songtags.
     * @param {songtagsCreateArgs} args - Arguments to create a Songtags.
     * @example
     * // Create one Songtags
     * const Songtags = await prisma.songtags.create({
     *   data: {
     *     // ... data to create a Songtags
     *   }
     * })
     * 
    **/
    create<T extends songtagsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, songtagsCreateArgs<ExtArgs>>
    ): Prisma__songtagsClient<$Types.GetResult<songtagsPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Songtags.
     *     @param {songtagsCreateManyArgs} args - Arguments to create many Songtags.
     *     @example
     *     // Create many Songtags
     *     const songtags = await prisma.songtags.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends songtagsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, songtagsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Songtags.
     * @param {songtagsDeleteArgs} args - Arguments to delete one Songtags.
     * @example
     * // Delete one Songtags
     * const Songtags = await prisma.songtags.delete({
     *   where: {
     *     // ... filter to delete one Songtags
     *   }
     * })
     * 
    **/
    delete<T extends songtagsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, songtagsDeleteArgs<ExtArgs>>
    ): Prisma__songtagsClient<$Types.GetResult<songtagsPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Songtags.
     * @param {songtagsUpdateArgs} args - Arguments to update one Songtags.
     * @example
     * // Update one Songtags
     * const songtags = await prisma.songtags.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends songtagsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, songtagsUpdateArgs<ExtArgs>>
    ): Prisma__songtagsClient<$Types.GetResult<songtagsPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Songtags.
     * @param {songtagsDeleteManyArgs} args - Arguments to filter Songtags to delete.
     * @example
     * // Delete a few Songtags
     * const { count } = await prisma.songtags.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends songtagsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, songtagsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Songtags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {songtagsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Songtags
     * const songtags = await prisma.songtags.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends songtagsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, songtagsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Songtags.
     * @param {songtagsUpsertArgs} args - Arguments to update or create a Songtags.
     * @example
     * // Update or create a Songtags
     * const songtags = await prisma.songtags.upsert({
     *   create: {
     *     // ... data to create a Songtags
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Songtags we want to update
     *   }
     * })
    **/
    upsert<T extends songtagsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, songtagsUpsertArgs<ExtArgs>>
    ): Prisma__songtagsClient<$Types.GetResult<songtagsPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Songtags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {songtagsCountArgs} args - Arguments to filter Songtags to count.
     * @example
     * // Count the number of Songtags
     * const count = await prisma.songtags.count({
     *   where: {
     *     // ... the filter for the Songtags we want to count
     *   }
     * })
    **/
    count<T extends songtagsCountArgs>(
      args?: Subset<T, songtagsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SongtagsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Songtags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SongtagsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SongtagsAggregateArgs>(args: Subset<T, SongtagsAggregateArgs>): Prisma.PrismaPromise<GetSongtagsAggregateType<T>>

    /**
     * Group by Songtags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SongtagsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SongtagsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SongtagsGroupByArgs['orderBy'] }
        : { orderBy?: SongtagsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SongtagsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSongtagsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for songtags.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__songtagsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    songdata<T extends songdataArgs<ExtArgs> = {}>(args?: Subset<T, songdataArgs<ExtArgs>>): Prisma__songdataClient<$Types.GetResult<songdataPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * songtags base type for findUnique actions
   */
  export type songtagsFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the songtags
     */
    select?: songtagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: songtagsInclude<ExtArgs> | null
    /**
     * Filter, which songtags to fetch.
     */
    where: songtagsWhereUniqueInput
  }

  /**
   * songtags findUnique
   */
  export interface songtagsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends songtagsFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * songtags findUniqueOrThrow
   */
  export type songtagsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the songtags
     */
    select?: songtagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: songtagsInclude<ExtArgs> | null
    /**
     * Filter, which songtags to fetch.
     */
    where: songtagsWhereUniqueInput
  }


  /**
   * songtags base type for findFirst actions
   */
  export type songtagsFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the songtags
     */
    select?: songtagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: songtagsInclude<ExtArgs> | null
    /**
     * Filter, which songtags to fetch.
     */
    where?: songtagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of songtags to fetch.
     */
    orderBy?: Enumerable<songtagsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for songtags.
     */
    cursor?: songtagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` songtags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` songtags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of songtags.
     */
    distinct?: Enumerable<SongtagsScalarFieldEnum>
  }

  /**
   * songtags findFirst
   */
  export interface songtagsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends songtagsFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * songtags findFirstOrThrow
   */
  export type songtagsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the songtags
     */
    select?: songtagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: songtagsInclude<ExtArgs> | null
    /**
     * Filter, which songtags to fetch.
     */
    where?: songtagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of songtags to fetch.
     */
    orderBy?: Enumerable<songtagsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for songtags.
     */
    cursor?: songtagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` songtags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` songtags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of songtags.
     */
    distinct?: Enumerable<SongtagsScalarFieldEnum>
  }


  /**
   * songtags findMany
   */
  export type songtagsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the songtags
     */
    select?: songtagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: songtagsInclude<ExtArgs> | null
    /**
     * Filter, which songtags to fetch.
     */
    where?: songtagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of songtags to fetch.
     */
    orderBy?: Enumerable<songtagsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing songtags.
     */
    cursor?: songtagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` songtags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` songtags.
     */
    skip?: number
    distinct?: Enumerable<SongtagsScalarFieldEnum>
  }


  /**
   * songtags create
   */
  export type songtagsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the songtags
     */
    select?: songtagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: songtagsInclude<ExtArgs> | null
    /**
     * The data needed to create a songtags.
     */
    data: XOR<songtagsCreateInput, songtagsUncheckedCreateInput>
  }


  /**
   * songtags createMany
   */
  export type songtagsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many songtags.
     */
    data: Enumerable<songtagsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * songtags update
   */
  export type songtagsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the songtags
     */
    select?: songtagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: songtagsInclude<ExtArgs> | null
    /**
     * The data needed to update a songtags.
     */
    data: XOR<songtagsUpdateInput, songtagsUncheckedUpdateInput>
    /**
     * Choose, which songtags to update.
     */
    where: songtagsWhereUniqueInput
  }


  /**
   * songtags updateMany
   */
  export type songtagsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update songtags.
     */
    data: XOR<songtagsUpdateManyMutationInput, songtagsUncheckedUpdateManyInput>
    /**
     * Filter which songtags to update
     */
    where?: songtagsWhereInput
  }


  /**
   * songtags upsert
   */
  export type songtagsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the songtags
     */
    select?: songtagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: songtagsInclude<ExtArgs> | null
    /**
     * The filter to search for the songtags to update in case it exists.
     */
    where: songtagsWhereUniqueInput
    /**
     * In case the songtags found by the `where` argument doesn't exist, create a new songtags with this data.
     */
    create: XOR<songtagsCreateInput, songtagsUncheckedCreateInput>
    /**
     * In case the songtags was found with the provided `where` argument, update it with this data.
     */
    update: XOR<songtagsUpdateInput, songtagsUncheckedUpdateInput>
  }


  /**
   * songtags delete
   */
  export type songtagsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the songtags
     */
    select?: songtagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: songtagsInclude<ExtArgs> | null
    /**
     * Filter which songtags to delete.
     */
    where: songtagsWhereUniqueInput
  }


  /**
   * songtags deleteMany
   */
  export type songtagsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which songtags to delete
     */
    where?: songtagsWhereInput
  }


  /**
   * songtags without action
   */
  export type songtagsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the songtags
     */
    select?: songtagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: songtagsInclude<ExtArgs> | null
  }



  /**
   * Model styles
   */


  export type AggregateStyles = {
    _count: StylesCountAggregateOutputType | null
    _avg: StylesAvgAggregateOutputType | null
    _sum: StylesSumAggregateOutputType | null
    _min: StylesMinAggregateOutputType | null
    _max: StylesMaxAggregateOutputType | null
  }

  export type StylesAvgAggregateOutputType = {
    id: number | null
  }

  export type StylesSumAggregateOutputType = {
    id: number | null
  }

  export type StylesMinAggregateOutputType = {
    id: number | null
    classname: string | null
    tagname: string | null
    attr: string | null
    value: string | null
    stylesheet: string | null
  }

  export type StylesMaxAggregateOutputType = {
    id: number | null
    classname: string | null
    tagname: string | null
    attr: string | null
    value: string | null
    stylesheet: string | null
  }

  export type StylesCountAggregateOutputType = {
    id: number
    classname: number
    tagname: number
    attr: number
    value: number
    stylesheet: number
    _all: number
  }


  export type StylesAvgAggregateInputType = {
    id?: true
  }

  export type StylesSumAggregateInputType = {
    id?: true
  }

  export type StylesMinAggregateInputType = {
    id?: true
    classname?: true
    tagname?: true
    attr?: true
    value?: true
    stylesheet?: true
  }

  export type StylesMaxAggregateInputType = {
    id?: true
    classname?: true
    tagname?: true
    attr?: true
    value?: true
    stylesheet?: true
  }

  export type StylesCountAggregateInputType = {
    id?: true
    classname?: true
    tagname?: true
    attr?: true
    value?: true
    stylesheet?: true
    _all?: true
  }

  export type StylesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which styles to aggregate.
     */
    where?: stylesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of styles to fetch.
     */
    orderBy?: Enumerable<stylesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: stylesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` styles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` styles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned styles
    **/
    _count?: true | StylesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StylesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StylesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StylesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StylesMaxAggregateInputType
  }

  export type GetStylesAggregateType<T extends StylesAggregateArgs> = {
        [P in keyof T & keyof AggregateStyles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStyles[P]>
      : GetScalarType<T[P], AggregateStyles[P]>
  }




  export type StylesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: stylesWhereInput
    orderBy?: Enumerable<stylesOrderByWithAggregationInput>
    by: StylesScalarFieldEnum[]
    having?: stylesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StylesCountAggregateInputType | true
    _avg?: StylesAvgAggregateInputType
    _sum?: StylesSumAggregateInputType
    _min?: StylesMinAggregateInputType
    _max?: StylesMaxAggregateInputType
  }


  export type StylesGroupByOutputType = {
    id: number
    classname: string | null
    tagname: string | null
    attr: string | null
    value: string | null
    stylesheet: string | null
    _count: StylesCountAggregateOutputType | null
    _avg: StylesAvgAggregateOutputType | null
    _sum: StylesSumAggregateOutputType | null
    _min: StylesMinAggregateOutputType | null
    _max: StylesMaxAggregateOutputType | null
  }

  type GetStylesGroupByPayload<T extends StylesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<StylesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StylesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StylesGroupByOutputType[P]>
            : GetScalarType<T[P], StylesGroupByOutputType[P]>
        }
      >
    >


  export type stylesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    classname?: boolean
    tagname?: boolean
    attr?: boolean
    value?: boolean
    stylesheet?: boolean
  }, ExtArgs["result"]["styles"]>

  export type stylesSelectScalar = {
    id?: boolean
    classname?: boolean
    tagname?: boolean
    attr?: boolean
    value?: boolean
    stylesheet?: boolean
  }


  type stylesGetPayload<S extends boolean | null | undefined | stylesArgs> = $Types.GetResult<stylesPayload, S>

  type stylesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<stylesFindManyArgs, 'select' | 'include'> & {
      select?: StylesCountAggregateInputType | true
    }

  export interface stylesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['styles'], meta: { name: 'styles' } }
    /**
     * Find zero or one Styles that matches the filter.
     * @param {stylesFindUniqueArgs} args - Arguments to find a Styles
     * @example
     * // Get one Styles
     * const styles = await prisma.styles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends stylesFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, stylesFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'styles'> extends True ? Prisma__stylesClient<$Types.GetResult<stylesPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__stylesClient<$Types.GetResult<stylesPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Styles that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {stylesFindUniqueOrThrowArgs} args - Arguments to find a Styles
     * @example
     * // Get one Styles
     * const styles = await prisma.styles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends stylesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, stylesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__stylesClient<$Types.GetResult<stylesPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Styles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stylesFindFirstArgs} args - Arguments to find a Styles
     * @example
     * // Get one Styles
     * const styles = await prisma.styles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends stylesFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, stylesFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'styles'> extends True ? Prisma__stylesClient<$Types.GetResult<stylesPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__stylesClient<$Types.GetResult<stylesPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Styles that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stylesFindFirstOrThrowArgs} args - Arguments to find a Styles
     * @example
     * // Get one Styles
     * const styles = await prisma.styles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends stylesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, stylesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__stylesClient<$Types.GetResult<stylesPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Styles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stylesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Styles
     * const styles = await prisma.styles.findMany()
     * 
     * // Get first 10 Styles
     * const styles = await prisma.styles.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stylesWithIdOnly = await prisma.styles.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends stylesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, stylesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<stylesPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Styles.
     * @param {stylesCreateArgs} args - Arguments to create a Styles.
     * @example
     * // Create one Styles
     * const Styles = await prisma.styles.create({
     *   data: {
     *     // ... data to create a Styles
     *   }
     * })
     * 
    **/
    create<T extends stylesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, stylesCreateArgs<ExtArgs>>
    ): Prisma__stylesClient<$Types.GetResult<stylesPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Styles.
     *     @param {stylesCreateManyArgs} args - Arguments to create many Styles.
     *     @example
     *     // Create many Styles
     *     const styles = await prisma.styles.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends stylesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, stylesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Styles.
     * @param {stylesDeleteArgs} args - Arguments to delete one Styles.
     * @example
     * // Delete one Styles
     * const Styles = await prisma.styles.delete({
     *   where: {
     *     // ... filter to delete one Styles
     *   }
     * })
     * 
    **/
    delete<T extends stylesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, stylesDeleteArgs<ExtArgs>>
    ): Prisma__stylesClient<$Types.GetResult<stylesPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Styles.
     * @param {stylesUpdateArgs} args - Arguments to update one Styles.
     * @example
     * // Update one Styles
     * const styles = await prisma.styles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends stylesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, stylesUpdateArgs<ExtArgs>>
    ): Prisma__stylesClient<$Types.GetResult<stylesPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Styles.
     * @param {stylesDeleteManyArgs} args - Arguments to filter Styles to delete.
     * @example
     * // Delete a few Styles
     * const { count } = await prisma.styles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends stylesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, stylesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Styles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stylesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Styles
     * const styles = await prisma.styles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends stylesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, stylesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Styles.
     * @param {stylesUpsertArgs} args - Arguments to update or create a Styles.
     * @example
     * // Update or create a Styles
     * const styles = await prisma.styles.upsert({
     *   create: {
     *     // ... data to create a Styles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Styles we want to update
     *   }
     * })
    **/
    upsert<T extends stylesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, stylesUpsertArgs<ExtArgs>>
    ): Prisma__stylesClient<$Types.GetResult<stylesPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Styles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stylesCountArgs} args - Arguments to filter Styles to count.
     * @example
     * // Count the number of Styles
     * const count = await prisma.styles.count({
     *   where: {
     *     // ... the filter for the Styles we want to count
     *   }
     * })
    **/
    count<T extends stylesCountArgs>(
      args?: Subset<T, stylesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StylesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Styles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StylesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StylesAggregateArgs>(args: Subset<T, StylesAggregateArgs>): Prisma.PrismaPromise<GetStylesAggregateType<T>>

    /**
     * Group by Styles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StylesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StylesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StylesGroupByArgs['orderBy'] }
        : { orderBy?: StylesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StylesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStylesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for styles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__stylesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * styles base type for findUnique actions
   */
  export type stylesFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the styles
     */
    select?: stylesSelect<ExtArgs> | null
    /**
     * Filter, which styles to fetch.
     */
    where: stylesWhereUniqueInput
  }

  /**
   * styles findUnique
   */
  export interface stylesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends stylesFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * styles findUniqueOrThrow
   */
  export type stylesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the styles
     */
    select?: stylesSelect<ExtArgs> | null
    /**
     * Filter, which styles to fetch.
     */
    where: stylesWhereUniqueInput
  }


  /**
   * styles base type for findFirst actions
   */
  export type stylesFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the styles
     */
    select?: stylesSelect<ExtArgs> | null
    /**
     * Filter, which styles to fetch.
     */
    where?: stylesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of styles to fetch.
     */
    orderBy?: Enumerable<stylesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for styles.
     */
    cursor?: stylesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` styles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` styles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of styles.
     */
    distinct?: Enumerable<StylesScalarFieldEnum>
  }

  /**
   * styles findFirst
   */
  export interface stylesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends stylesFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * styles findFirstOrThrow
   */
  export type stylesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the styles
     */
    select?: stylesSelect<ExtArgs> | null
    /**
     * Filter, which styles to fetch.
     */
    where?: stylesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of styles to fetch.
     */
    orderBy?: Enumerable<stylesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for styles.
     */
    cursor?: stylesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` styles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` styles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of styles.
     */
    distinct?: Enumerable<StylesScalarFieldEnum>
  }


  /**
   * styles findMany
   */
  export type stylesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the styles
     */
    select?: stylesSelect<ExtArgs> | null
    /**
     * Filter, which styles to fetch.
     */
    where?: stylesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of styles to fetch.
     */
    orderBy?: Enumerable<stylesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing styles.
     */
    cursor?: stylesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` styles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` styles.
     */
    skip?: number
    distinct?: Enumerable<StylesScalarFieldEnum>
  }


  /**
   * styles create
   */
  export type stylesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the styles
     */
    select?: stylesSelect<ExtArgs> | null
    /**
     * The data needed to create a styles.
     */
    data?: XOR<stylesCreateInput, stylesUncheckedCreateInput>
  }


  /**
   * styles createMany
   */
  export type stylesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many styles.
     */
    data: Enumerable<stylesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * styles update
   */
  export type stylesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the styles
     */
    select?: stylesSelect<ExtArgs> | null
    /**
     * The data needed to update a styles.
     */
    data: XOR<stylesUpdateInput, stylesUncheckedUpdateInput>
    /**
     * Choose, which styles to update.
     */
    where: stylesWhereUniqueInput
  }


  /**
   * styles updateMany
   */
  export type stylesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update styles.
     */
    data: XOR<stylesUpdateManyMutationInput, stylesUncheckedUpdateManyInput>
    /**
     * Filter which styles to update
     */
    where?: stylesWhereInput
  }


  /**
   * styles upsert
   */
  export type stylesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the styles
     */
    select?: stylesSelect<ExtArgs> | null
    /**
     * The filter to search for the styles to update in case it exists.
     */
    where: stylesWhereUniqueInput
    /**
     * In case the styles found by the `where` argument doesn't exist, create a new styles with this data.
     */
    create: XOR<stylesCreateInput, stylesUncheckedCreateInput>
    /**
     * In case the styles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<stylesUpdateInput, stylesUncheckedUpdateInput>
  }


  /**
   * styles delete
   */
  export type stylesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the styles
     */
    select?: stylesSelect<ExtArgs> | null
    /**
     * Filter which styles to delete.
     */
    where: stylesWhereUniqueInput
  }


  /**
   * styles deleteMany
   */
  export type stylesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which styles to delete
     */
    where?: stylesWhereInput
  }


  /**
   * styles without action
   */
  export type stylesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the styles
     */
    select?: stylesSelect<ExtArgs> | null
  }



  /**
   * Model users
   */


  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersAvgAggregateOutputType = {
    id: number | null
  }

  export type UsersSumAggregateOutputType = {
    id: number | null
  }

  export type UsersMinAggregateOutputType = {
    id: number | null
    username: string | null
    password: string | null
  }

  export type UsersMaxAggregateOutputType = {
    id: number | null
    username: string | null
    password: string | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    username: number
    password: number
    _all: number
  }


  export type UsersAvgAggregateInputType = {
    id?: true
  }

  export type UsersSumAggregateInputType = {
    id?: true
  }

  export type UsersMinAggregateInputType = {
    id?: true
    username?: true
    password?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    username?: true
    password?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    username?: true
    password?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to aggregate.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: Enumerable<usersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type UsersGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
    orderBy?: Enumerable<usersOrderByWithAggregationInput>
    by: UsersScalarFieldEnum[]
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _avg?: UsersAvgAggregateInputType
    _sum?: UsersSumAggregateInputType
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }


  export type UsersGroupByOutputType = {
    id: number
    username: string | null
    password: string | null
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends UsersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
  }, ExtArgs["result"]["users"]>

  export type usersSelectScalar = {
    id?: boolean
    username?: boolean
    password?: boolean
  }


  type usersGetPayload<S extends boolean | null | undefined | usersArgs> = $Types.GetResult<usersPayload, S>

  type usersCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<usersFindManyArgs, 'select' | 'include'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface usersDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users'], meta: { name: 'users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends usersFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, usersFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'users'> extends True ? Prisma__usersClient<$Types.GetResult<usersPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__usersClient<$Types.GetResult<usersPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Users that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, usersFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__usersClient<$Types.GetResult<usersPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends usersFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, usersFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'users'> extends True ? Prisma__usersClient<$Types.GetResult<usersPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__usersClient<$Types.GetResult<usersPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Users that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, usersFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__usersClient<$Types.GetResult<usersPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends usersFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, usersFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<usersPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
    **/
    create<T extends usersCreateArgs<ExtArgs>>(
      args: SelectSubset<T, usersCreateArgs<ExtArgs>>
    ): Prisma__usersClient<$Types.GetResult<usersPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Users.
     *     @param {usersCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const users = await prisma.users.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends usersCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, usersCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
    **/
    delete<T extends usersDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, usersDeleteArgs<ExtArgs>>
    ): Prisma__usersClient<$Types.GetResult<usersPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends usersUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, usersUpdateArgs<ExtArgs>>
    ): Prisma__usersClient<$Types.GetResult<usersPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends usersDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, usersDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends usersUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, usersUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
    **/
    upsert<T extends usersUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, usersUpsertArgs<ExtArgs>>
    ): Prisma__usersClient<$Types.GetResult<usersPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsersGroupByArgs['orderBy'] }
        : { orderBy?: UsersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__usersClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * users base type for findUnique actions
   */
  export type usersFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findUnique
   */
  export interface usersFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends usersFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * users findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }


  /**
   * users base type for findFirst actions
   */
  export type usersFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: Enumerable<usersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: Enumerable<UsersScalarFieldEnum>
  }

  /**
   * users findFirst
   */
  export interface usersFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends usersFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * users findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: Enumerable<usersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: Enumerable<UsersScalarFieldEnum>
  }


  /**
   * users findMany
   */
  export type usersFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: Enumerable<usersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: Enumerable<UsersScalarFieldEnum>
  }


  /**
   * users create
   */
  export type usersCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * The data needed to create a users.
     */
    data?: XOR<usersCreateInput, usersUncheckedCreateInput>
  }


  /**
   * users createMany
   */
  export type usersCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: Enumerable<usersCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * users update
   */
  export type usersUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * The data needed to update a users.
     */
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     */
    where: usersWhereUniqueInput
  }


  /**
   * users updateMany
   */
  export type usersUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
  }


  /**
   * users upsert
   */
  export type usersUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * The filter to search for the users to update in case it exists.
     */
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     */
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }


  /**
   * users delete
   */
  export type usersDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Filter which users to delete.
     */
    where: usersWhereUniqueInput
  }


  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: usersWhereInput
  }


  /**
   * users without action
   */
  export type usersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
  }



  /**
   * Model versedata
   */


  export type AggregateVersedata = {
    _count: VersedataCountAggregateOutputType | null
    _avg: VersedataAvgAggregateOutputType | null
    _sum: VersedataSumAggregateOutputType | null
    _min: VersedataMinAggregateOutputType | null
    _max: VersedataMaxAggregateOutputType | null
  }

  export type VersedataAvgAggregateOutputType = {
    id: number | null
    song_id: number | null
  }

  export type VersedataSumAggregateOutputType = {
    id: number | null
    song_id: number | null
  }

  export type VersedataMinAggregateOutputType = {
    id: number | null
    song_id: number | null
    verse: string | null
    versetype: string | null
  }

  export type VersedataMaxAggregateOutputType = {
    id: number | null
    song_id: number | null
    verse: string | null
    versetype: string | null
  }

  export type VersedataCountAggregateOutputType = {
    id: number
    song_id: number
    verse: number
    versetype: number
    _all: number
  }


  export type VersedataAvgAggregateInputType = {
    id?: true
    song_id?: true
  }

  export type VersedataSumAggregateInputType = {
    id?: true
    song_id?: true
  }

  export type VersedataMinAggregateInputType = {
    id?: true
    song_id?: true
    verse?: true
    versetype?: true
  }

  export type VersedataMaxAggregateInputType = {
    id?: true
    song_id?: true
    verse?: true
    versetype?: true
  }

  export type VersedataCountAggregateInputType = {
    id?: true
    song_id?: true
    verse?: true
    versetype?: true
    _all?: true
  }

  export type VersedataAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which versedata to aggregate.
     */
    where?: versedataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of versedata to fetch.
     */
    orderBy?: Enumerable<versedataOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: versedataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` versedata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` versedata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned versedata
    **/
    _count?: true | VersedataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VersedataAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VersedataSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VersedataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VersedataMaxAggregateInputType
  }

  export type GetVersedataAggregateType<T extends VersedataAggregateArgs> = {
        [P in keyof T & keyof AggregateVersedata]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVersedata[P]>
      : GetScalarType<T[P], AggregateVersedata[P]>
  }




  export type VersedataGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: versedataWhereInput
    orderBy?: Enumerable<versedataOrderByWithAggregationInput>
    by: VersedataScalarFieldEnum[]
    having?: versedataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VersedataCountAggregateInputType | true
    _avg?: VersedataAvgAggregateInputType
    _sum?: VersedataSumAggregateInputType
    _min?: VersedataMinAggregateInputType
    _max?: VersedataMaxAggregateInputType
  }


  export type VersedataGroupByOutputType = {
    id: number
    song_id: number
    verse: string | null
    versetype: string | null
    _count: VersedataCountAggregateOutputType | null
    _avg: VersedataAvgAggregateOutputType | null
    _sum: VersedataSumAggregateOutputType | null
    _min: VersedataMinAggregateOutputType | null
    _max: VersedataMaxAggregateOutputType | null
  }

  type GetVersedataGroupByPayload<T extends VersedataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<VersedataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VersedataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VersedataGroupByOutputType[P]>
            : GetScalarType<T[P], VersedataGroupByOutputType[P]>
        }
      >
    >


  export type versedataSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    song_id?: boolean
    verse?: boolean
    versetype?: boolean
    songdata?: boolean | songdataArgs<ExtArgs>
  }, ExtArgs["result"]["versedata"]>

  export type versedataSelectScalar = {
    id?: boolean
    song_id?: boolean
    verse?: boolean
    versetype?: boolean
  }

  export type versedataInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    songdata?: boolean | songdataArgs<ExtArgs>
  }


  type versedataGetPayload<S extends boolean | null | undefined | versedataArgs> = $Types.GetResult<versedataPayload, S>

  type versedataCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<versedataFindManyArgs, 'select' | 'include'> & {
      select?: VersedataCountAggregateInputType | true
    }

  export interface versedataDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['versedata'], meta: { name: 'versedata' } }
    /**
     * Find zero or one Versedata that matches the filter.
     * @param {versedataFindUniqueArgs} args - Arguments to find a Versedata
     * @example
     * // Get one Versedata
     * const versedata = await prisma.versedata.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends versedataFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, versedataFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'versedata'> extends True ? Prisma__versedataClient<$Types.GetResult<versedataPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__versedataClient<$Types.GetResult<versedataPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Versedata that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {versedataFindUniqueOrThrowArgs} args - Arguments to find a Versedata
     * @example
     * // Get one Versedata
     * const versedata = await prisma.versedata.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends versedataFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, versedataFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__versedataClient<$Types.GetResult<versedataPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Versedata that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {versedataFindFirstArgs} args - Arguments to find a Versedata
     * @example
     * // Get one Versedata
     * const versedata = await prisma.versedata.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends versedataFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, versedataFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'versedata'> extends True ? Prisma__versedataClient<$Types.GetResult<versedataPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__versedataClient<$Types.GetResult<versedataPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Versedata that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {versedataFindFirstOrThrowArgs} args - Arguments to find a Versedata
     * @example
     * // Get one Versedata
     * const versedata = await prisma.versedata.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends versedataFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, versedataFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__versedataClient<$Types.GetResult<versedataPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Versedata that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {versedataFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Versedata
     * const versedata = await prisma.versedata.findMany()
     * 
     * // Get first 10 Versedata
     * const versedata = await prisma.versedata.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const versedataWithIdOnly = await prisma.versedata.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends versedataFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, versedataFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<versedataPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Versedata.
     * @param {versedataCreateArgs} args - Arguments to create a Versedata.
     * @example
     * // Create one Versedata
     * const Versedata = await prisma.versedata.create({
     *   data: {
     *     // ... data to create a Versedata
     *   }
     * })
     * 
    **/
    create<T extends versedataCreateArgs<ExtArgs>>(
      args: SelectSubset<T, versedataCreateArgs<ExtArgs>>
    ): Prisma__versedataClient<$Types.GetResult<versedataPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Versedata.
     *     @param {versedataCreateManyArgs} args - Arguments to create many Versedata.
     *     @example
     *     // Create many Versedata
     *     const versedata = await prisma.versedata.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends versedataCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, versedataCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Versedata.
     * @param {versedataDeleteArgs} args - Arguments to delete one Versedata.
     * @example
     * // Delete one Versedata
     * const Versedata = await prisma.versedata.delete({
     *   where: {
     *     // ... filter to delete one Versedata
     *   }
     * })
     * 
    **/
    delete<T extends versedataDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, versedataDeleteArgs<ExtArgs>>
    ): Prisma__versedataClient<$Types.GetResult<versedataPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Versedata.
     * @param {versedataUpdateArgs} args - Arguments to update one Versedata.
     * @example
     * // Update one Versedata
     * const versedata = await prisma.versedata.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends versedataUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, versedataUpdateArgs<ExtArgs>>
    ): Prisma__versedataClient<$Types.GetResult<versedataPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Versedata.
     * @param {versedataDeleteManyArgs} args - Arguments to filter Versedata to delete.
     * @example
     * // Delete a few Versedata
     * const { count } = await prisma.versedata.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends versedataDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, versedataDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Versedata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {versedataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Versedata
     * const versedata = await prisma.versedata.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends versedataUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, versedataUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Versedata.
     * @param {versedataUpsertArgs} args - Arguments to update or create a Versedata.
     * @example
     * // Update or create a Versedata
     * const versedata = await prisma.versedata.upsert({
     *   create: {
     *     // ... data to create a Versedata
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Versedata we want to update
     *   }
     * })
    **/
    upsert<T extends versedataUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, versedataUpsertArgs<ExtArgs>>
    ): Prisma__versedataClient<$Types.GetResult<versedataPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Versedata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {versedataCountArgs} args - Arguments to filter Versedata to count.
     * @example
     * // Count the number of Versedata
     * const count = await prisma.versedata.count({
     *   where: {
     *     // ... the filter for the Versedata we want to count
     *   }
     * })
    **/
    count<T extends versedataCountArgs>(
      args?: Subset<T, versedataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VersedataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Versedata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VersedataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VersedataAggregateArgs>(args: Subset<T, VersedataAggregateArgs>): Prisma.PrismaPromise<GetVersedataAggregateType<T>>

    /**
     * Group by Versedata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VersedataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VersedataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VersedataGroupByArgs['orderBy'] }
        : { orderBy?: VersedataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VersedataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVersedataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for versedata.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__versedataClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    songdata<T extends songdataArgs<ExtArgs> = {}>(args?: Subset<T, songdataArgs<ExtArgs>>): Prisma__songdataClient<$Types.GetResult<songdataPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * versedata base type for findUnique actions
   */
  export type versedataFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the versedata
     */
    select?: versedataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: versedataInclude<ExtArgs> | null
    /**
     * Filter, which versedata to fetch.
     */
    where: versedataWhereUniqueInput
  }

  /**
   * versedata findUnique
   */
  export interface versedataFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends versedataFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * versedata findUniqueOrThrow
   */
  export type versedataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the versedata
     */
    select?: versedataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: versedataInclude<ExtArgs> | null
    /**
     * Filter, which versedata to fetch.
     */
    where: versedataWhereUniqueInput
  }


  /**
   * versedata base type for findFirst actions
   */
  export type versedataFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the versedata
     */
    select?: versedataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: versedataInclude<ExtArgs> | null
    /**
     * Filter, which versedata to fetch.
     */
    where?: versedataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of versedata to fetch.
     */
    orderBy?: Enumerable<versedataOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for versedata.
     */
    cursor?: versedataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` versedata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` versedata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of versedata.
     */
    distinct?: Enumerable<VersedataScalarFieldEnum>
  }

  /**
   * versedata findFirst
   */
  export interface versedataFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends versedataFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * versedata findFirstOrThrow
   */
  export type versedataFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the versedata
     */
    select?: versedataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: versedataInclude<ExtArgs> | null
    /**
     * Filter, which versedata to fetch.
     */
    where?: versedataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of versedata to fetch.
     */
    orderBy?: Enumerable<versedataOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for versedata.
     */
    cursor?: versedataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` versedata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` versedata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of versedata.
     */
    distinct?: Enumerable<VersedataScalarFieldEnum>
  }


  /**
   * versedata findMany
   */
  export type versedataFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the versedata
     */
    select?: versedataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: versedataInclude<ExtArgs> | null
    /**
     * Filter, which versedata to fetch.
     */
    where?: versedataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of versedata to fetch.
     */
    orderBy?: Enumerable<versedataOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing versedata.
     */
    cursor?: versedataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` versedata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` versedata.
     */
    skip?: number
    distinct?: Enumerable<VersedataScalarFieldEnum>
  }


  /**
   * versedata create
   */
  export type versedataCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the versedata
     */
    select?: versedataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: versedataInclude<ExtArgs> | null
    /**
     * The data needed to create a versedata.
     */
    data: XOR<versedataCreateInput, versedataUncheckedCreateInput>
  }


  /**
   * versedata createMany
   */
  export type versedataCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many versedata.
     */
    data: Enumerable<versedataCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * versedata update
   */
  export type versedataUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the versedata
     */
    select?: versedataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: versedataInclude<ExtArgs> | null
    /**
     * The data needed to update a versedata.
     */
    data: XOR<versedataUpdateInput, versedataUncheckedUpdateInput>
    /**
     * Choose, which versedata to update.
     */
    where: versedataWhereUniqueInput
  }


  /**
   * versedata updateMany
   */
  export type versedataUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update versedata.
     */
    data: XOR<versedataUpdateManyMutationInput, versedataUncheckedUpdateManyInput>
    /**
     * Filter which versedata to update
     */
    where?: versedataWhereInput
  }


  /**
   * versedata upsert
   */
  export type versedataUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the versedata
     */
    select?: versedataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: versedataInclude<ExtArgs> | null
    /**
     * The filter to search for the versedata to update in case it exists.
     */
    where: versedataWhereUniqueInput
    /**
     * In case the versedata found by the `where` argument doesn't exist, create a new versedata with this data.
     */
    create: XOR<versedataCreateInput, versedataUncheckedCreateInput>
    /**
     * In case the versedata was found with the provided `where` argument, update it with this data.
     */
    update: XOR<versedataUpdateInput, versedataUncheckedUpdateInput>
  }


  /**
   * versedata delete
   */
  export type versedataDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the versedata
     */
    select?: versedataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: versedataInclude<ExtArgs> | null
    /**
     * Filter which versedata to delete.
     */
    where: versedataWhereUniqueInput
  }


  /**
   * versedata deleteMany
   */
  export type versedataDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which versedata to delete
     */
    where?: versedataWhereInput
  }


  /**
   * versedata without action
   */
  export type versedataArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the versedata
     */
    select?: versedataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: versedataInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const BackgroundsScalarFieldEnum: {
    id: 'id',
    filename: 'filename',
    description: 'description'
  };

  export type BackgroundsScalarFieldEnum = (typeof BackgroundsScalarFieldEnum)[keyof typeof BackgroundsScalarFieldEnum]


  export const BiblesegmentsScalarFieldEnum: {
    id: 'id',
    start_book: 'start_book',
    start_chap: 'start_chap',
    start_verse: 'start_verse',
    end_book: 'end_book',
    end_chap: 'end_chap',
    end_verse: 'end_verse'
  };

  export type BiblesegmentsScalarFieldEnum = (typeof BiblesegmentsScalarFieldEnum)[keyof typeof BiblesegmentsScalarFieldEnum]


  export const Collected_offeringsScalarFieldEnum: {
    id: 'id',
    target_id: 'target_id',
    service_id: 'service_id',
    amount: 'amount'
  };

  export type Collected_offeringsScalarFieldEnum = (typeof Collected_offeringsScalarFieldEnum)[keyof typeof Collected_offeringsScalarFieldEnum]


  export const CommentsScalarFieldEnum: {
    id: 'id',
    service_id: 'service_id',
    reply_to: 'reply_to',
    content: 'content',
    commentator: 'commentator',
    theme: 'theme',
    comment_time: 'comment_time'
  };

  export type CommentsScalarFieldEnum = (typeof CommentsScalarFieldEnum)[keyof typeof CommentsScalarFieldEnum]


  export const EventsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    place_and_time: 'place_and_time',
    description: 'description',
    event_date: 'event_date',
    has_songs: 'has_songs'
  };

  export type EventsScalarFieldEnum = (typeof EventsScalarFieldEnum)[keyof typeof EventsScalarFieldEnum]


  export const HeadersScalarFieldEnum: {
    id: 'id',
    template_name: 'template_name',
    maintext: 'maintext',
    imgname: 'imgname',
    imgposition: 'imgposition',
    is_aside: 'is_aside'
  };

  export type HeadersScalarFieldEnum = (typeof HeadersScalarFieldEnum)[keyof typeof HeadersScalarFieldEnum]


  export const InfosScalarFieldEnum: {
    id: 'id',
    service_id: 'service_id',
    slot_name: 'slot_name',
    content_id: 'content_id',
    addedclass: 'addedclass',
    header_id: 'header_id'
  };

  export type InfosScalarFieldEnum = (typeof InfosScalarFieldEnum)[keyof typeof InfosScalarFieldEnum]


  export const InfosegmentsScalarFieldEnum: {
    id: 'id',
    maintext: 'maintext',
    header: 'header',
    genheader: 'genheader',
    subgenheader: 'subgenheader',
    imgname: 'imgname',
    imgposition: 'imgposition'
  };

  export type InfosegmentsScalarFieldEnum = (typeof InfosegmentsScalarFieldEnum)[keyof typeof InfosegmentsScalarFieldEnum]


  export const LiturgicalsegmentsScalarFieldEnum: {
    id: 'id',
    text_title: 'text_title',
    use_as_header: 'use_as_header'
  };

  export type LiturgicalsegmentsScalarFieldEnum = (typeof LiturgicalsegmentsScalarFieldEnum)[keyof typeof LiturgicalsegmentsScalarFieldEnum]


  export const LtextdataScalarFieldEnum: {
    id: 'id',
    title: 'title'
  };

  export type LtextdataScalarFieldEnum = (typeof LtextdataScalarFieldEnum)[keyof typeof LtextdataScalarFieldEnum]


  export const LtextversedataScalarFieldEnum: {
    id: 'id',
    ltext_id: 'ltext_id',
    verse: 'verse'
  };

  export type LtextversedataScalarFieldEnum = (typeof LtextversedataScalarFieldEnum)[keyof typeof LtextversedataScalarFieldEnum]


  export const Offering_goalsScalarFieldEnum: {
    id: 'id',
    target_id: 'target_id',
    name: 'name',
    description: 'description',
    amount: 'amount',
    is_default: 'is_default'
  };

  export type Offering_goalsScalarFieldEnum = (typeof Offering_goalsScalarFieldEnum)[keyof typeof Offering_goalsScalarFieldEnum]


  export const Offering_targetsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description'
  };

  export type Offering_targetsScalarFieldEnum = (typeof Offering_targetsScalarFieldEnum)[keyof typeof Offering_targetsScalarFieldEnum]


  export const Presentation_contentScalarFieldEnum: {
    id: 'id',
    slot_id: 'slot_id',
    content_type: 'content_type',
    new_slide: 'new_slide',
    content: 'content'
  };

  export type Presentation_contentScalarFieldEnum = (typeof Presentation_contentScalarFieldEnum)[keyof typeof Presentation_contentScalarFieldEnum]


  export const Presentation_structureScalarFieldEnum: {
    id: 'id',
    service_id: 'service_id',
    slot_name: 'slot_name',
    slot_number: 'slot_number',
    slot_type: 'slot_type',
    id_in_type_table: 'id_in_type_table',
    addedclass: 'addedclass',
    header_id: 'header_id',
    content_id: 'content_id',
    instruction: 'instruction'
  };

  export type Presentation_structureScalarFieldEnum = (typeof Presentation_structureScalarFieldEnum)[keyof typeof Presentation_structureScalarFieldEnum]


  export const ResponsibilitiesScalarFieldEnum: {
    id: 'id',
    service_id: 'service_id',
    responsibility: 'responsibility',
    responsible: 'responsible'
  };

  export type ResponsibilitiesScalarFieldEnum = (typeof ResponsibilitiesScalarFieldEnum)[keyof typeof ResponsibilitiesScalarFieldEnum]


  export const Responsibilities_metaScalarFieldEnum: {
    id: 'id',
    responsibility: 'responsibility',
    description: 'description'
  };

  export type Responsibilities_metaScalarFieldEnum = (typeof Responsibilities_metaScalarFieldEnum)[keyof typeof Responsibilities_metaScalarFieldEnum]


  export const SeasonsScalarFieldEnum: {
    id: 'id',
    startdate: 'startdate',
    enddate: 'enddate',
    theme: 'theme',
    comments: 'comments',
    name: 'name'
  };

  export type SeasonsScalarFieldEnum = (typeof SeasonsScalarFieldEnum)[keyof typeof SeasonsScalarFieldEnum]


  export const Service_specific_presentation_structureScalarFieldEnum: {
    id: 'id',
    service_id: 'service_id',
    slot_name: 'slot_name',
    slot_number: 'slot_number',
    slot_type: 'slot_type',
    id_in_type_table: 'id_in_type_table',
    content_id: 'content_id',
    addedclass: 'addedclass',
    header_id: 'header_id',
    instruction: 'instruction'
  };

  export type Service_specific_presentation_structureScalarFieldEnum = (typeof Service_specific_presentation_structureScalarFieldEnum)[keyof typeof Service_specific_presentation_structureScalarFieldEnum]


  export const ServicesScalarFieldEnum: {
    id: 'id',
    servicedate: 'servicedate',
    theme: 'theme'
  };

  export type ServicesScalarFieldEnum = (typeof ServicesScalarFieldEnum)[keyof typeof ServicesScalarFieldEnum]


  export const ServicesongsScalarFieldEnum: {
    id: 'id',
    service_id: 'service_id',
    song_title: 'song_title',
    verses: 'verses',
    is_instrumental: 'is_instrumental',
    song_id: 'song_id',
    songtype: 'songtype',
    position: 'position'
  };

  export type ServicesongsScalarFieldEnum = (typeof ServicesongsScalarFieldEnum)[keyof typeof ServicesongsScalarFieldEnum]


  export const ServiceversesScalarFieldEnum: {
    id: 'id',
    service_id: 'service_id',
    segment_name: 'segment_name',
    testament: 'testament',
    startbook: 'startbook',
    endbook: 'endbook',
    startchapter: 'startchapter',
    endchapter: 'endchapter',
    startverse: 'startverse',
    endverse: 'endverse'
  };

  export type ServiceversesScalarFieldEnum = (typeof ServiceversesScalarFieldEnum)[keyof typeof ServiceversesScalarFieldEnum]


  export const SmallgroupsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    resp_name: 'resp_name',
    day: 'day',
    time_and_place: 'time_and_place',
    is_active: 'is_active'
  };

  export type SmallgroupsScalarFieldEnum = (typeof SmallgroupsScalarFieldEnum)[keyof typeof SmallgroupsScalarFieldEnum]


  export const SongdataScalarFieldEnum: {
    id: 'id',
    title: 'title',
    composer: 'composer',
    lyrics: 'lyrics',
    version_description: 'version_description'
  };

  export type SongdataScalarFieldEnum = (typeof SongdataScalarFieldEnum)[keyof typeof SongdataScalarFieldEnum]


  export const SongsegmentsScalarFieldEnum: {
    id: 'id',
    songdescription: 'songdescription',
    restrictedto: 'restrictedto',
    singlename: 'singlename',
    is_multi: 'is_multi',
    segment_name_is_title: 'segment_name_is_title'
  };

  export type SongsegmentsScalarFieldEnum = (typeof SongsegmentsScalarFieldEnum)[keyof typeof SongsegmentsScalarFieldEnum]


  export const SongtagsScalarFieldEnum: {
    id: 'id',
    song_id: 'song_id',
    tag: 'tag'
  };

  export type SongtagsScalarFieldEnum = (typeof SongtagsScalarFieldEnum)[keyof typeof SongtagsScalarFieldEnum]


  export const StylesScalarFieldEnum: {
    id: 'id',
    classname: 'classname',
    tagname: 'tagname',
    attr: 'attr',
    value: 'value',
    stylesheet: 'stylesheet'
  };

  export type StylesScalarFieldEnum = (typeof StylesScalarFieldEnum)[keyof typeof StylesScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    id: 'id',
    username: 'username',
    password: 'password'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const VersedataScalarFieldEnum: {
    id: 'id',
    song_id: 'song_id',
    verse: 'verse',
    versetype: 'versetype'
  };

  export type VersedataScalarFieldEnum = (typeof VersedataScalarFieldEnum)[keyof typeof VersedataScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Deep Input Types
   */


  export type backgroundsWhereInput = {
    AND?: Enumerable<backgroundsWhereInput>
    OR?: Enumerable<backgroundsWhereInput>
    NOT?: Enumerable<backgroundsWhereInput>
    id?: IntFilter | number
    filename?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
  }

  export type backgroundsOrderByWithRelationInput = {
    id?: SortOrder
    filename?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
  }

  export type backgroundsWhereUniqueInput = {
    id?: number
  }

  export type backgroundsOrderByWithAggregationInput = {
    id?: SortOrder
    filename?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    _count?: backgroundsCountOrderByAggregateInput
    _avg?: backgroundsAvgOrderByAggregateInput
    _max?: backgroundsMaxOrderByAggregateInput
    _min?: backgroundsMinOrderByAggregateInput
    _sum?: backgroundsSumOrderByAggregateInput
  }

  export type backgroundsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<backgroundsScalarWhereWithAggregatesInput>
    OR?: Enumerable<backgroundsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<backgroundsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    filename?: StringNullableWithAggregatesFilter | string | null
    description?: StringNullableWithAggregatesFilter | string | null
  }

  export type biblesegmentsWhereInput = {
    AND?: Enumerable<biblesegmentsWhereInput>
    OR?: Enumerable<biblesegmentsWhereInput>
    NOT?: Enumerable<biblesegmentsWhereInput>
    id?: IntFilter | number
    start_book?: StringNullableFilter | string | null
    start_chap?: IntNullableFilter | number | null
    start_verse?: IntNullableFilter | number | null
    end_book?: StringNullableFilter | string | null
    end_chap?: IntNullableFilter | number | null
    end_verse?: IntNullableFilter | number | null
  }

  export type biblesegmentsOrderByWithRelationInput = {
    id?: SortOrder
    start_book?: SortOrderInput | SortOrder
    start_chap?: SortOrderInput | SortOrder
    start_verse?: SortOrderInput | SortOrder
    end_book?: SortOrderInput | SortOrder
    end_chap?: SortOrderInput | SortOrder
    end_verse?: SortOrderInput | SortOrder
  }

  export type biblesegmentsWhereUniqueInput = {
    id?: number
  }

  export type biblesegmentsOrderByWithAggregationInput = {
    id?: SortOrder
    start_book?: SortOrderInput | SortOrder
    start_chap?: SortOrderInput | SortOrder
    start_verse?: SortOrderInput | SortOrder
    end_book?: SortOrderInput | SortOrder
    end_chap?: SortOrderInput | SortOrder
    end_verse?: SortOrderInput | SortOrder
    _count?: biblesegmentsCountOrderByAggregateInput
    _avg?: biblesegmentsAvgOrderByAggregateInput
    _max?: biblesegmentsMaxOrderByAggregateInput
    _min?: biblesegmentsMinOrderByAggregateInput
    _sum?: biblesegmentsSumOrderByAggregateInput
  }

  export type biblesegmentsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<biblesegmentsScalarWhereWithAggregatesInput>
    OR?: Enumerable<biblesegmentsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<biblesegmentsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    start_book?: StringNullableWithAggregatesFilter | string | null
    start_chap?: IntNullableWithAggregatesFilter | number | null
    start_verse?: IntNullableWithAggregatesFilter | number | null
    end_book?: StringNullableWithAggregatesFilter | string | null
    end_chap?: IntNullableWithAggregatesFilter | number | null
    end_verse?: IntNullableWithAggregatesFilter | number | null
  }

  export type collected_offeringsWhereInput = {
    AND?: Enumerable<collected_offeringsWhereInput>
    OR?: Enumerable<collected_offeringsWhereInput>
    NOT?: Enumerable<collected_offeringsWhereInput>
    id?: IntFilter | number
    target_id?: IntFilter | number
    service_id?: IntFilter | number
    amount?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    offering_goals?: XOR<Offering_goalsRelationFilter, offering_goalsWhereInput>
    services?: XOR<ServicesRelationFilter, servicesWhereInput>
  }

  export type collected_offeringsOrderByWithRelationInput = {
    id?: SortOrder
    target_id?: SortOrder
    service_id?: SortOrder
    amount?: SortOrderInput | SortOrder
    offering_goals?: offering_goalsOrderByWithRelationInput
    services?: servicesOrderByWithRelationInput
  }

  export type collected_offeringsWhereUniqueInput = {
    id?: number
  }

  export type collected_offeringsOrderByWithAggregationInput = {
    id?: SortOrder
    target_id?: SortOrder
    service_id?: SortOrder
    amount?: SortOrderInput | SortOrder
    _count?: collected_offeringsCountOrderByAggregateInput
    _avg?: collected_offeringsAvgOrderByAggregateInput
    _max?: collected_offeringsMaxOrderByAggregateInput
    _min?: collected_offeringsMinOrderByAggregateInput
    _sum?: collected_offeringsSumOrderByAggregateInput
  }

  export type collected_offeringsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<collected_offeringsScalarWhereWithAggregatesInput>
    OR?: Enumerable<collected_offeringsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<collected_offeringsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    target_id?: IntWithAggregatesFilter | number
    service_id?: IntWithAggregatesFilter | number
    amount?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
  }

  export type commentsWhereInput = {
    AND?: Enumerable<commentsWhereInput>
    OR?: Enumerable<commentsWhereInput>
    NOT?: Enumerable<commentsWhereInput>
    id?: IntFilter | number
    service_id?: IntFilter | number
    reply_to?: IntNullableFilter | number | null
    content?: StringNullableFilter | string | null
    commentator?: StringNullableFilter | string | null
    theme?: StringNullableFilter | string | null
    comment_time?: DateTimeNullableFilter | Date | string | null
    services?: XOR<ServicesRelationFilter, servicesWhereInput>
  }

  export type commentsOrderByWithRelationInput = {
    id?: SortOrder
    service_id?: SortOrder
    reply_to?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    commentator?: SortOrderInput | SortOrder
    theme?: SortOrderInput | SortOrder
    comment_time?: SortOrderInput | SortOrder
    services?: servicesOrderByWithRelationInput
  }

  export type commentsWhereUniqueInput = {
    id?: number
  }

  export type commentsOrderByWithAggregationInput = {
    id?: SortOrder
    service_id?: SortOrder
    reply_to?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    commentator?: SortOrderInput | SortOrder
    theme?: SortOrderInput | SortOrder
    comment_time?: SortOrderInput | SortOrder
    _count?: commentsCountOrderByAggregateInput
    _avg?: commentsAvgOrderByAggregateInput
    _max?: commentsMaxOrderByAggregateInput
    _min?: commentsMinOrderByAggregateInput
    _sum?: commentsSumOrderByAggregateInput
  }

  export type commentsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<commentsScalarWhereWithAggregatesInput>
    OR?: Enumerable<commentsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<commentsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    service_id?: IntWithAggregatesFilter | number
    reply_to?: IntNullableWithAggregatesFilter | number | null
    content?: StringNullableWithAggregatesFilter | string | null
    commentator?: StringNullableWithAggregatesFilter | string | null
    theme?: StringNullableWithAggregatesFilter | string | null
    comment_time?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type eventsWhereInput = {
    AND?: Enumerable<eventsWhereInput>
    OR?: Enumerable<eventsWhereInput>
    NOT?: Enumerable<eventsWhereInput>
    id?: IntFilter | number
    name?: StringNullableFilter | string | null
    place_and_time?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    event_date?: DateTimeNullableFilter | Date | string | null
    has_songs?: BoolNullableFilter | boolean | null
  }

  export type eventsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    place_and_time?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    event_date?: SortOrderInput | SortOrder
    has_songs?: SortOrderInput | SortOrder
  }

  export type eventsWhereUniqueInput = {
    id?: number
  }

  export type eventsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    place_and_time?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    event_date?: SortOrderInput | SortOrder
    has_songs?: SortOrderInput | SortOrder
    _count?: eventsCountOrderByAggregateInput
    _avg?: eventsAvgOrderByAggregateInput
    _max?: eventsMaxOrderByAggregateInput
    _min?: eventsMinOrderByAggregateInput
    _sum?: eventsSumOrderByAggregateInput
  }

  export type eventsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<eventsScalarWhereWithAggregatesInput>
    OR?: Enumerable<eventsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<eventsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringNullableWithAggregatesFilter | string | null
    place_and_time?: StringNullableWithAggregatesFilter | string | null
    description?: StringNullableWithAggregatesFilter | string | null
    event_date?: DateTimeNullableWithAggregatesFilter | Date | string | null
    has_songs?: BoolNullableWithAggregatesFilter | boolean | null
  }

  export type headersWhereInput = {
    AND?: Enumerable<headersWhereInput>
    OR?: Enumerable<headersWhereInput>
    NOT?: Enumerable<headersWhereInput>
    id?: IntFilter | number
    template_name?: StringNullableFilter | string | null
    maintext?: StringNullableFilter | string | null
    imgname?: StringNullableFilter | string | null
    imgposition?: StringNullableFilter | string | null
    is_aside?: BoolNullableFilter | boolean | null
  }

  export type headersOrderByWithRelationInput = {
    id?: SortOrder
    template_name?: SortOrderInput | SortOrder
    maintext?: SortOrderInput | SortOrder
    imgname?: SortOrderInput | SortOrder
    imgposition?: SortOrderInput | SortOrder
    is_aside?: SortOrderInput | SortOrder
  }

  export type headersWhereUniqueInput = {
    id?: number
  }

  export type headersOrderByWithAggregationInput = {
    id?: SortOrder
    template_name?: SortOrderInput | SortOrder
    maintext?: SortOrderInput | SortOrder
    imgname?: SortOrderInput | SortOrder
    imgposition?: SortOrderInput | SortOrder
    is_aside?: SortOrderInput | SortOrder
    _count?: headersCountOrderByAggregateInput
    _avg?: headersAvgOrderByAggregateInput
    _max?: headersMaxOrderByAggregateInput
    _min?: headersMinOrderByAggregateInput
    _sum?: headersSumOrderByAggregateInput
  }

  export type headersScalarWhereWithAggregatesInput = {
    AND?: Enumerable<headersScalarWhereWithAggregatesInput>
    OR?: Enumerable<headersScalarWhereWithAggregatesInput>
    NOT?: Enumerable<headersScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    template_name?: StringNullableWithAggregatesFilter | string | null
    maintext?: StringNullableWithAggregatesFilter | string | null
    imgname?: StringNullableWithAggregatesFilter | string | null
    imgposition?: StringNullableWithAggregatesFilter | string | null
    is_aside?: BoolNullableWithAggregatesFilter | boolean | null
  }

  export type infosWhereInput = {
    AND?: Enumerable<infosWhereInput>
    OR?: Enumerable<infosWhereInput>
    NOT?: Enumerable<infosWhereInput>
    id?: IntFilter | number
    service_id?: IntFilter | number
    slot_name?: StringNullableFilter | string | null
    content_id?: IntFilter | number
    addedclass?: StringNullableFilter | string | null
    header_id?: IntNullableFilter | number | null
  }

  export type infosOrderByWithRelationInput = {
    id?: SortOrder
    service_id?: SortOrder
    slot_name?: SortOrderInput | SortOrder
    content_id?: SortOrder
    addedclass?: SortOrderInput | SortOrder
    header_id?: SortOrderInput | SortOrder
  }

  export type infosWhereUniqueInput = {
    id?: number
  }

  export type infosOrderByWithAggregationInput = {
    id?: SortOrder
    service_id?: SortOrder
    slot_name?: SortOrderInput | SortOrder
    content_id?: SortOrder
    addedclass?: SortOrderInput | SortOrder
    header_id?: SortOrderInput | SortOrder
    _count?: infosCountOrderByAggregateInput
    _avg?: infosAvgOrderByAggregateInput
    _max?: infosMaxOrderByAggregateInput
    _min?: infosMinOrderByAggregateInput
    _sum?: infosSumOrderByAggregateInput
  }

  export type infosScalarWhereWithAggregatesInput = {
    AND?: Enumerable<infosScalarWhereWithAggregatesInput>
    OR?: Enumerable<infosScalarWhereWithAggregatesInput>
    NOT?: Enumerable<infosScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    service_id?: IntWithAggregatesFilter | number
    slot_name?: StringNullableWithAggregatesFilter | string | null
    content_id?: IntWithAggregatesFilter | number
    addedclass?: StringNullableWithAggregatesFilter | string | null
    header_id?: IntNullableWithAggregatesFilter | number | null
  }

  export type infosegmentsWhereInput = {
    AND?: Enumerable<infosegmentsWhereInput>
    OR?: Enumerable<infosegmentsWhereInput>
    NOT?: Enumerable<infosegmentsWhereInput>
    id?: IntFilter | number
    maintext?: StringNullableFilter | string | null
    header?: StringNullableFilter | string | null
    genheader?: StringNullableFilter | string | null
    subgenheader?: StringNullableFilter | string | null
    imgname?: StringNullableFilter | string | null
    imgposition?: StringNullableFilter | string | null
  }

  export type infosegmentsOrderByWithRelationInput = {
    id?: SortOrder
    maintext?: SortOrderInput | SortOrder
    header?: SortOrderInput | SortOrder
    genheader?: SortOrderInput | SortOrder
    subgenheader?: SortOrderInput | SortOrder
    imgname?: SortOrderInput | SortOrder
    imgposition?: SortOrderInput | SortOrder
  }

  export type infosegmentsWhereUniqueInput = {
    id?: number
  }

  export type infosegmentsOrderByWithAggregationInput = {
    id?: SortOrder
    maintext?: SortOrderInput | SortOrder
    header?: SortOrderInput | SortOrder
    genheader?: SortOrderInput | SortOrder
    subgenheader?: SortOrderInput | SortOrder
    imgname?: SortOrderInput | SortOrder
    imgposition?: SortOrderInput | SortOrder
    _count?: infosegmentsCountOrderByAggregateInput
    _avg?: infosegmentsAvgOrderByAggregateInput
    _max?: infosegmentsMaxOrderByAggregateInput
    _min?: infosegmentsMinOrderByAggregateInput
    _sum?: infosegmentsSumOrderByAggregateInput
  }

  export type infosegmentsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<infosegmentsScalarWhereWithAggregatesInput>
    OR?: Enumerable<infosegmentsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<infosegmentsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    maintext?: StringNullableWithAggregatesFilter | string | null
    header?: StringNullableWithAggregatesFilter | string | null
    genheader?: StringNullableWithAggregatesFilter | string | null
    subgenheader?: StringNullableWithAggregatesFilter | string | null
    imgname?: StringNullableWithAggregatesFilter | string | null
    imgposition?: StringNullableWithAggregatesFilter | string | null
  }

  export type liturgicalsegmentsWhereInput = {
    AND?: Enumerable<liturgicalsegmentsWhereInput>
    OR?: Enumerable<liturgicalsegmentsWhereInput>
    NOT?: Enumerable<liturgicalsegmentsWhereInput>
    id?: IntFilter | number
    text_title?: StringNullableFilter | string | null
    use_as_header?: BoolNullableFilter | boolean | null
  }

  export type liturgicalsegmentsOrderByWithRelationInput = {
    id?: SortOrder
    text_title?: SortOrderInput | SortOrder
    use_as_header?: SortOrderInput | SortOrder
  }

  export type liturgicalsegmentsWhereUniqueInput = {
    id?: number
  }

  export type liturgicalsegmentsOrderByWithAggregationInput = {
    id?: SortOrder
    text_title?: SortOrderInput | SortOrder
    use_as_header?: SortOrderInput | SortOrder
    _count?: liturgicalsegmentsCountOrderByAggregateInput
    _avg?: liturgicalsegmentsAvgOrderByAggregateInput
    _max?: liturgicalsegmentsMaxOrderByAggregateInput
    _min?: liturgicalsegmentsMinOrderByAggregateInput
    _sum?: liturgicalsegmentsSumOrderByAggregateInput
  }

  export type liturgicalsegmentsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<liturgicalsegmentsScalarWhereWithAggregatesInput>
    OR?: Enumerable<liturgicalsegmentsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<liturgicalsegmentsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    text_title?: StringNullableWithAggregatesFilter | string | null
    use_as_header?: BoolNullableWithAggregatesFilter | boolean | null
  }

  export type ltextdataWhereInput = {
    AND?: Enumerable<ltextdataWhereInput>
    OR?: Enumerable<ltextdataWhereInput>
    NOT?: Enumerable<ltextdataWhereInput>
    id?: IntFilter | number
    title?: StringNullableFilter | string | null
    ltextversedata?: LtextversedataListRelationFilter
  }

  export type ltextdataOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrderInput | SortOrder
    ltextversedata?: ltextversedataOrderByRelationAggregateInput
  }

  export type ltextdataWhereUniqueInput = {
    id?: number
    title?: string
  }

  export type ltextdataOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrderInput | SortOrder
    _count?: ltextdataCountOrderByAggregateInput
    _avg?: ltextdataAvgOrderByAggregateInput
    _max?: ltextdataMaxOrderByAggregateInput
    _min?: ltextdataMinOrderByAggregateInput
    _sum?: ltextdataSumOrderByAggregateInput
  }

  export type ltextdataScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ltextdataScalarWhereWithAggregatesInput>
    OR?: Enumerable<ltextdataScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ltextdataScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    title?: StringNullableWithAggregatesFilter | string | null
  }

  export type ltextversedataWhereInput = {
    AND?: Enumerable<ltextversedataWhereInput>
    OR?: Enumerable<ltextversedataWhereInput>
    NOT?: Enumerable<ltextversedataWhereInput>
    id?: IntFilter | number
    ltext_id?: IntFilter | number
    verse?: StringNullableFilter | string | null
    ltextdata?: XOR<LtextdataRelationFilter, ltextdataWhereInput>
  }

  export type ltextversedataOrderByWithRelationInput = {
    id?: SortOrder
    ltext_id?: SortOrder
    verse?: SortOrderInput | SortOrder
    ltextdata?: ltextdataOrderByWithRelationInput
  }

  export type ltextversedataWhereUniqueInput = {
    id?: number
  }

  export type ltextversedataOrderByWithAggregationInput = {
    id?: SortOrder
    ltext_id?: SortOrder
    verse?: SortOrderInput | SortOrder
    _count?: ltextversedataCountOrderByAggregateInput
    _avg?: ltextversedataAvgOrderByAggregateInput
    _max?: ltextversedataMaxOrderByAggregateInput
    _min?: ltextversedataMinOrderByAggregateInput
    _sum?: ltextversedataSumOrderByAggregateInput
  }

  export type ltextversedataScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ltextversedataScalarWhereWithAggregatesInput>
    OR?: Enumerable<ltextversedataScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ltextversedataScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    ltext_id?: IntWithAggregatesFilter | number
    verse?: StringNullableWithAggregatesFilter | string | null
  }

  export type offering_goalsWhereInput = {
    AND?: Enumerable<offering_goalsWhereInput>
    OR?: Enumerable<offering_goalsWhereInput>
    NOT?: Enumerable<offering_goalsWhereInput>
    id?: IntFilter | number
    target_id?: IntFilter | number
    name?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    amount?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    is_default?: BoolNullableFilter | boolean | null
    collected_offerings?: Collected_offeringsListRelationFilter
    offering_targets?: XOR<Offering_targetsRelationFilter, offering_targetsWhereInput>
  }

  export type offering_goalsOrderByWithRelationInput = {
    id?: SortOrder
    target_id?: SortOrder
    name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    is_default?: SortOrderInput | SortOrder
    collected_offerings?: collected_offeringsOrderByRelationAggregateInput
    offering_targets?: offering_targetsOrderByWithRelationInput
  }

  export type offering_goalsWhereUniqueInput = {
    id?: number
  }

  export type offering_goalsOrderByWithAggregationInput = {
    id?: SortOrder
    target_id?: SortOrder
    name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    is_default?: SortOrderInput | SortOrder
    _count?: offering_goalsCountOrderByAggregateInput
    _avg?: offering_goalsAvgOrderByAggregateInput
    _max?: offering_goalsMaxOrderByAggregateInput
    _min?: offering_goalsMinOrderByAggregateInput
    _sum?: offering_goalsSumOrderByAggregateInput
  }

  export type offering_goalsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<offering_goalsScalarWhereWithAggregatesInput>
    OR?: Enumerable<offering_goalsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<offering_goalsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    target_id?: IntWithAggregatesFilter | number
    name?: StringNullableWithAggregatesFilter | string | null
    description?: StringNullableWithAggregatesFilter | string | null
    amount?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    is_default?: BoolNullableWithAggregatesFilter | boolean | null
  }

  export type offering_targetsWhereInput = {
    AND?: Enumerable<offering_targetsWhereInput>
    OR?: Enumerable<offering_targetsWhereInput>
    NOT?: Enumerable<offering_targetsWhereInput>
    id?: IntFilter | number
    name?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    offering_goals?: Offering_goalsListRelationFilter
  }

  export type offering_targetsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    offering_goals?: offering_goalsOrderByRelationAggregateInput
  }

  export type offering_targetsWhereUniqueInput = {
    id?: number
  }

  export type offering_targetsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    _count?: offering_targetsCountOrderByAggregateInput
    _avg?: offering_targetsAvgOrderByAggregateInput
    _max?: offering_targetsMaxOrderByAggregateInput
    _min?: offering_targetsMinOrderByAggregateInput
    _sum?: offering_targetsSumOrderByAggregateInput
  }

  export type offering_targetsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<offering_targetsScalarWhereWithAggregatesInput>
    OR?: Enumerable<offering_targetsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<offering_targetsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringNullableWithAggregatesFilter | string | null
    description?: StringNullableWithAggregatesFilter | string | null
  }

  export type presentation_contentWhereInput = {
    AND?: Enumerable<presentation_contentWhereInput>
    OR?: Enumerable<presentation_contentWhereInput>
    NOT?: Enumerable<presentation_contentWhereInput>
    id?: IntFilter | number
    slot_id?: IntFilter | number
    content_type?: StringNullableFilter | string | null
    new_slide?: StringNullableFilter | string | null
    content?: StringNullableFilter | string | null
    presentation_structure?: XOR<Presentation_structureRelationFilter, presentation_structureWhereInput>
  }

  export type presentation_contentOrderByWithRelationInput = {
    id?: SortOrder
    slot_id?: SortOrder
    content_type?: SortOrderInput | SortOrder
    new_slide?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    presentation_structure?: presentation_structureOrderByWithRelationInput
  }

  export type presentation_contentWhereUniqueInput = {
    id?: number
  }

  export type presentation_contentOrderByWithAggregationInput = {
    id?: SortOrder
    slot_id?: SortOrder
    content_type?: SortOrderInput | SortOrder
    new_slide?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    _count?: presentation_contentCountOrderByAggregateInput
    _avg?: presentation_contentAvgOrderByAggregateInput
    _max?: presentation_contentMaxOrderByAggregateInput
    _min?: presentation_contentMinOrderByAggregateInput
    _sum?: presentation_contentSumOrderByAggregateInput
  }

  export type presentation_contentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<presentation_contentScalarWhereWithAggregatesInput>
    OR?: Enumerable<presentation_contentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<presentation_contentScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    slot_id?: IntWithAggregatesFilter | number
    content_type?: StringNullableWithAggregatesFilter | string | null
    new_slide?: StringNullableWithAggregatesFilter | string | null
    content?: StringNullableWithAggregatesFilter | string | null
  }

  export type presentation_structureWhereInput = {
    AND?: Enumerable<presentation_structureWhereInput>
    OR?: Enumerable<presentation_structureWhereInput>
    NOT?: Enumerable<presentation_structureWhereInput>
    id?: IntFilter | number
    service_id?: IntNullableFilter | number | null
    slot_name?: StringNullableFilter | string | null
    slot_number?: IntNullableFilter | number | null
    slot_type?: StringNullableFilter | string | null
    id_in_type_table?: StringNullableFilter | string | null
    addedclass?: StringNullableFilter | string | null
    header_id?: IntNullableFilter | number | null
    content_id?: IntFilter | number
    instruction?: StringNullableFilter | string | null
    presentation_content?: Presentation_contentListRelationFilter
  }

  export type presentation_structureOrderByWithRelationInput = {
    id?: SortOrder
    service_id?: SortOrderInput | SortOrder
    slot_name?: SortOrderInput | SortOrder
    slot_number?: SortOrderInput | SortOrder
    slot_type?: SortOrderInput | SortOrder
    id_in_type_table?: SortOrderInput | SortOrder
    addedclass?: SortOrderInput | SortOrder
    header_id?: SortOrderInput | SortOrder
    content_id?: SortOrder
    instruction?: SortOrderInput | SortOrder
    presentation_content?: presentation_contentOrderByRelationAggregateInput
  }

  export type presentation_structureWhereUniqueInput = {
    id?: number
  }

  export type presentation_structureOrderByWithAggregationInput = {
    id?: SortOrder
    service_id?: SortOrderInput | SortOrder
    slot_name?: SortOrderInput | SortOrder
    slot_number?: SortOrderInput | SortOrder
    slot_type?: SortOrderInput | SortOrder
    id_in_type_table?: SortOrderInput | SortOrder
    addedclass?: SortOrderInput | SortOrder
    header_id?: SortOrderInput | SortOrder
    content_id?: SortOrder
    instruction?: SortOrderInput | SortOrder
    _count?: presentation_structureCountOrderByAggregateInput
    _avg?: presentation_structureAvgOrderByAggregateInput
    _max?: presentation_structureMaxOrderByAggregateInput
    _min?: presentation_structureMinOrderByAggregateInput
    _sum?: presentation_structureSumOrderByAggregateInput
  }

  export type presentation_structureScalarWhereWithAggregatesInput = {
    AND?: Enumerable<presentation_structureScalarWhereWithAggregatesInput>
    OR?: Enumerable<presentation_structureScalarWhereWithAggregatesInput>
    NOT?: Enumerable<presentation_structureScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    service_id?: IntNullableWithAggregatesFilter | number | null
    slot_name?: StringNullableWithAggregatesFilter | string | null
    slot_number?: IntNullableWithAggregatesFilter | number | null
    slot_type?: StringNullableWithAggregatesFilter | string | null
    id_in_type_table?: StringNullableWithAggregatesFilter | string | null
    addedclass?: StringNullableWithAggregatesFilter | string | null
    header_id?: IntNullableWithAggregatesFilter | number | null
    content_id?: IntWithAggregatesFilter | number
    instruction?: StringNullableWithAggregatesFilter | string | null
  }

  export type responsibilitiesWhereInput = {
    AND?: Enumerable<responsibilitiesWhereInput>
    OR?: Enumerable<responsibilitiesWhereInput>
    NOT?: Enumerable<responsibilitiesWhereInput>
    id?: IntFilter | number
    service_id?: IntFilter | number
    responsibility?: StringNullableFilter | string | null
    responsible?: StringNullableFilter | string | null
    services?: XOR<ServicesRelationFilter, servicesWhereInput>
  }

  export type responsibilitiesOrderByWithRelationInput = {
    id?: SortOrder
    service_id?: SortOrder
    responsibility?: SortOrderInput | SortOrder
    responsible?: SortOrderInput | SortOrder
    services?: servicesOrderByWithRelationInput
  }

  export type responsibilitiesWhereUniqueInput = {
    id?: number
  }

  export type responsibilitiesOrderByWithAggregationInput = {
    id?: SortOrder
    service_id?: SortOrder
    responsibility?: SortOrderInput | SortOrder
    responsible?: SortOrderInput | SortOrder
    _count?: responsibilitiesCountOrderByAggregateInput
    _avg?: responsibilitiesAvgOrderByAggregateInput
    _max?: responsibilitiesMaxOrderByAggregateInput
    _min?: responsibilitiesMinOrderByAggregateInput
    _sum?: responsibilitiesSumOrderByAggregateInput
  }

  export type responsibilitiesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<responsibilitiesScalarWhereWithAggregatesInput>
    OR?: Enumerable<responsibilitiesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<responsibilitiesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    service_id?: IntWithAggregatesFilter | number
    responsibility?: StringNullableWithAggregatesFilter | string | null
    responsible?: StringNullableWithAggregatesFilter | string | null
  }

  export type responsibilities_metaWhereInput = {
    AND?: Enumerable<responsibilities_metaWhereInput>
    OR?: Enumerable<responsibilities_metaWhereInput>
    NOT?: Enumerable<responsibilities_metaWhereInput>
    id?: IntFilter | number
    responsibility?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
  }

  export type responsibilities_metaOrderByWithRelationInput = {
    id?: SortOrder
    responsibility?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
  }

  export type responsibilities_metaWhereUniqueInput = {
    id?: number
  }

  export type responsibilities_metaOrderByWithAggregationInput = {
    id?: SortOrder
    responsibility?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    _count?: responsibilities_metaCountOrderByAggregateInput
    _avg?: responsibilities_metaAvgOrderByAggregateInput
    _max?: responsibilities_metaMaxOrderByAggregateInput
    _min?: responsibilities_metaMinOrderByAggregateInput
    _sum?: responsibilities_metaSumOrderByAggregateInput
  }

  export type responsibilities_metaScalarWhereWithAggregatesInput = {
    AND?: Enumerable<responsibilities_metaScalarWhereWithAggregatesInput>
    OR?: Enumerable<responsibilities_metaScalarWhereWithAggregatesInput>
    NOT?: Enumerable<responsibilities_metaScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    responsibility?: StringNullableWithAggregatesFilter | string | null
    description?: StringNullableWithAggregatesFilter | string | null
  }

  export type seasonsWhereInput = {
    AND?: Enumerable<seasonsWhereInput>
    OR?: Enumerable<seasonsWhereInput>
    NOT?: Enumerable<seasonsWhereInput>
    id?: IntFilter | number
    startdate?: DateTimeNullableFilter | Date | string | null
    enddate?: DateTimeNullableFilter | Date | string | null
    theme?: StringNullableFilter | string | null
    comments?: StringNullableFilter | string | null
    name?: StringNullableFilter | string | null
  }

  export type seasonsOrderByWithRelationInput = {
    id?: SortOrder
    startdate?: SortOrderInput | SortOrder
    enddate?: SortOrderInput | SortOrder
    theme?: SortOrderInput | SortOrder
    comments?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
  }

  export type seasonsWhereUniqueInput = {
    id?: number
  }

  export type seasonsOrderByWithAggregationInput = {
    id?: SortOrder
    startdate?: SortOrderInput | SortOrder
    enddate?: SortOrderInput | SortOrder
    theme?: SortOrderInput | SortOrder
    comments?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    _count?: seasonsCountOrderByAggregateInput
    _avg?: seasonsAvgOrderByAggregateInput
    _max?: seasonsMaxOrderByAggregateInput
    _min?: seasonsMinOrderByAggregateInput
    _sum?: seasonsSumOrderByAggregateInput
  }

  export type seasonsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<seasonsScalarWhereWithAggregatesInput>
    OR?: Enumerable<seasonsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<seasonsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    startdate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    enddate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    theme?: StringNullableWithAggregatesFilter | string | null
    comments?: StringNullableWithAggregatesFilter | string | null
    name?: StringNullableWithAggregatesFilter | string | null
  }

  export type service_specific_presentation_structureWhereInput = {
    AND?: Enumerable<service_specific_presentation_structureWhereInput>
    OR?: Enumerable<service_specific_presentation_structureWhereInput>
    NOT?: Enumerable<service_specific_presentation_structureWhereInput>
    id?: IntFilter | number
    service_id?: IntFilter | number
    slot_name?: StringNullableFilter | string | null
    slot_number?: IntNullableFilter | number | null
    slot_type?: StringNullableFilter | string | null
    id_in_type_table?: StringNullableFilter | string | null
    content_id?: IntFilter | number
    addedclass?: StringNullableFilter | string | null
    header_id?: IntNullableFilter | number | null
    instruction?: StringNullableFilter | string | null
  }

  export type service_specific_presentation_structureOrderByWithRelationInput = {
    id?: SortOrder
    service_id?: SortOrder
    slot_name?: SortOrderInput | SortOrder
    slot_number?: SortOrderInput | SortOrder
    slot_type?: SortOrderInput | SortOrder
    id_in_type_table?: SortOrderInput | SortOrder
    content_id?: SortOrder
    addedclass?: SortOrderInput | SortOrder
    header_id?: SortOrderInput | SortOrder
    instruction?: SortOrderInput | SortOrder
  }

  export type service_specific_presentation_structureWhereUniqueInput = {
    id?: number
  }

  export type service_specific_presentation_structureOrderByWithAggregationInput = {
    id?: SortOrder
    service_id?: SortOrder
    slot_name?: SortOrderInput | SortOrder
    slot_number?: SortOrderInput | SortOrder
    slot_type?: SortOrderInput | SortOrder
    id_in_type_table?: SortOrderInput | SortOrder
    content_id?: SortOrder
    addedclass?: SortOrderInput | SortOrder
    header_id?: SortOrderInput | SortOrder
    instruction?: SortOrderInput | SortOrder
    _count?: service_specific_presentation_structureCountOrderByAggregateInput
    _avg?: service_specific_presentation_structureAvgOrderByAggregateInput
    _max?: service_specific_presentation_structureMaxOrderByAggregateInput
    _min?: service_specific_presentation_structureMinOrderByAggregateInput
    _sum?: service_specific_presentation_structureSumOrderByAggregateInput
  }

  export type service_specific_presentation_structureScalarWhereWithAggregatesInput = {
    AND?: Enumerable<service_specific_presentation_structureScalarWhereWithAggregatesInput>
    OR?: Enumerable<service_specific_presentation_structureScalarWhereWithAggregatesInput>
    NOT?: Enumerable<service_specific_presentation_structureScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    service_id?: IntWithAggregatesFilter | number
    slot_name?: StringNullableWithAggregatesFilter | string | null
    slot_number?: IntNullableWithAggregatesFilter | number | null
    slot_type?: StringNullableWithAggregatesFilter | string | null
    id_in_type_table?: StringNullableWithAggregatesFilter | string | null
    content_id?: IntWithAggregatesFilter | number
    addedclass?: StringNullableWithAggregatesFilter | string | null
    header_id?: IntNullableWithAggregatesFilter | number | null
    instruction?: StringNullableWithAggregatesFilter | string | null
  }

  export type servicesWhereInput = {
    AND?: Enumerable<servicesWhereInput>
    OR?: Enumerable<servicesWhereInput>
    NOT?: Enumerable<servicesWhereInput>
    id?: IntFilter | number
    servicedate?: DateTimeNullableFilter | Date | string | null
    theme?: StringNullableFilter | string | null
    collected_offerings?: Collected_offeringsListRelationFilter
    comments?: CommentsListRelationFilter
    responsibilities?: ResponsibilitiesListRelationFilter
    servicesongs?: ServicesongsListRelationFilter
    serviceverses?: ServiceversesListRelationFilter
  }

  export type servicesOrderByWithRelationInput = {
    id?: SortOrder
    servicedate?: SortOrderInput | SortOrder
    theme?: SortOrderInput | SortOrder
    collected_offerings?: collected_offeringsOrderByRelationAggregateInput
    comments?: commentsOrderByRelationAggregateInput
    responsibilities?: responsibilitiesOrderByRelationAggregateInput
    servicesongs?: servicesongsOrderByRelationAggregateInput
    serviceverses?: serviceversesOrderByRelationAggregateInput
  }

  export type servicesWhereUniqueInput = {
    id?: number
  }

  export type servicesOrderByWithAggregationInput = {
    id?: SortOrder
    servicedate?: SortOrderInput | SortOrder
    theme?: SortOrderInput | SortOrder
    _count?: servicesCountOrderByAggregateInput
    _avg?: servicesAvgOrderByAggregateInput
    _max?: servicesMaxOrderByAggregateInput
    _min?: servicesMinOrderByAggregateInput
    _sum?: servicesSumOrderByAggregateInput
  }

  export type servicesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<servicesScalarWhereWithAggregatesInput>
    OR?: Enumerable<servicesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<servicesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    servicedate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    theme?: StringNullableWithAggregatesFilter | string | null
  }

  export type servicesongsWhereInput = {
    AND?: Enumerable<servicesongsWhereInput>
    OR?: Enumerable<servicesongsWhereInput>
    NOT?: Enumerable<servicesongsWhereInput>
    id?: BigIntFilter | bigint | number
    service_id?: IntFilter | number
    song_title?: StringNullableFilter | string | null
    verses?: StringNullableFilter | string | null
    is_instrumental?: StringNullableFilter | string | null
    song_id?: IntNullableFilter | number | null
    songtype?: StringFilter | string
    position?: IntNullableFilter | number | null
    services?: XOR<ServicesRelationFilter, servicesWhereInput>
  }

  export type servicesongsOrderByWithRelationInput = {
    id?: SortOrder
    service_id?: SortOrder
    song_title?: SortOrderInput | SortOrder
    verses?: SortOrderInput | SortOrder
    is_instrumental?: SortOrderInput | SortOrder
    song_id?: SortOrderInput | SortOrder
    songtype?: SortOrder
    position?: SortOrderInput | SortOrder
    services?: servicesOrderByWithRelationInput
  }

  export type servicesongsWhereUniqueInput = {
    id?: bigint | number
  }

  export type servicesongsOrderByWithAggregationInput = {
    id?: SortOrder
    service_id?: SortOrder
    song_title?: SortOrderInput | SortOrder
    verses?: SortOrderInput | SortOrder
    is_instrumental?: SortOrderInput | SortOrder
    song_id?: SortOrderInput | SortOrder
    songtype?: SortOrder
    position?: SortOrderInput | SortOrder
    _count?: servicesongsCountOrderByAggregateInput
    _avg?: servicesongsAvgOrderByAggregateInput
    _max?: servicesongsMaxOrderByAggregateInput
    _min?: servicesongsMinOrderByAggregateInput
    _sum?: servicesongsSumOrderByAggregateInput
  }

  export type servicesongsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<servicesongsScalarWhereWithAggregatesInput>
    OR?: Enumerable<servicesongsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<servicesongsScalarWhereWithAggregatesInput>
    id?: BigIntWithAggregatesFilter | bigint | number
    service_id?: IntWithAggregatesFilter | number
    song_title?: StringNullableWithAggregatesFilter | string | null
    verses?: StringNullableWithAggregatesFilter | string | null
    is_instrumental?: StringNullableWithAggregatesFilter | string | null
    song_id?: IntNullableWithAggregatesFilter | number | null
    songtype?: StringWithAggregatesFilter | string
    position?: IntNullableWithAggregatesFilter | number | null
  }

  export type serviceversesWhereInput = {
    AND?: Enumerable<serviceversesWhereInput>
    OR?: Enumerable<serviceversesWhereInput>
    NOT?: Enumerable<serviceversesWhereInput>
    id?: IntFilter | number
    service_id?: IntFilter | number
    segment_name?: StringNullableFilter | string | null
    testament?: StringNullableFilter | string | null
    startbook?: StringNullableFilter | string | null
    endbook?: StringNullableFilter | string | null
    startchapter?: IntNullableFilter | number | null
    endchapter?: IntNullableFilter | number | null
    startverse?: IntNullableFilter | number | null
    endverse?: IntNullableFilter | number | null
    services?: XOR<ServicesRelationFilter, servicesWhereInput>
  }

  export type serviceversesOrderByWithRelationInput = {
    id?: SortOrder
    service_id?: SortOrder
    segment_name?: SortOrderInput | SortOrder
    testament?: SortOrderInput | SortOrder
    startbook?: SortOrderInput | SortOrder
    endbook?: SortOrderInput | SortOrder
    startchapter?: SortOrderInput | SortOrder
    endchapter?: SortOrderInput | SortOrder
    startverse?: SortOrderInput | SortOrder
    endverse?: SortOrderInput | SortOrder
    services?: servicesOrderByWithRelationInput
  }

  export type serviceversesWhereUniqueInput = {
    id?: number
  }

  export type serviceversesOrderByWithAggregationInput = {
    id?: SortOrder
    service_id?: SortOrder
    segment_name?: SortOrderInput | SortOrder
    testament?: SortOrderInput | SortOrder
    startbook?: SortOrderInput | SortOrder
    endbook?: SortOrderInput | SortOrder
    startchapter?: SortOrderInput | SortOrder
    endchapter?: SortOrderInput | SortOrder
    startverse?: SortOrderInput | SortOrder
    endverse?: SortOrderInput | SortOrder
    _count?: serviceversesCountOrderByAggregateInput
    _avg?: serviceversesAvgOrderByAggregateInput
    _max?: serviceversesMaxOrderByAggregateInput
    _min?: serviceversesMinOrderByAggregateInput
    _sum?: serviceversesSumOrderByAggregateInput
  }

  export type serviceversesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<serviceversesScalarWhereWithAggregatesInput>
    OR?: Enumerable<serviceversesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<serviceversesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    service_id?: IntWithAggregatesFilter | number
    segment_name?: StringNullableWithAggregatesFilter | string | null
    testament?: StringNullableWithAggregatesFilter | string | null
    startbook?: StringNullableWithAggregatesFilter | string | null
    endbook?: StringNullableWithAggregatesFilter | string | null
    startchapter?: IntNullableWithAggregatesFilter | number | null
    endchapter?: IntNullableWithAggregatesFilter | number | null
    startverse?: IntNullableWithAggregatesFilter | number | null
    endverse?: IntNullableWithAggregatesFilter | number | null
  }

  export type smallgroupsWhereInput = {
    AND?: Enumerable<smallgroupsWhereInput>
    OR?: Enumerable<smallgroupsWhereInput>
    NOT?: Enumerable<smallgroupsWhereInput>
    id?: IntFilter | number
    name?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    resp_name?: StringNullableFilter | string | null
    day?: StringNullableFilter | string | null
    time_and_place?: StringNullableFilter | string | null
    is_active?: BoolNullableFilter | boolean | null
  }

  export type smallgroupsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    resp_name?: SortOrderInput | SortOrder
    day?: SortOrderInput | SortOrder
    time_and_place?: SortOrderInput | SortOrder
    is_active?: SortOrderInput | SortOrder
  }

  export type smallgroupsWhereUniqueInput = {
    id?: number
  }

  export type smallgroupsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    resp_name?: SortOrderInput | SortOrder
    day?: SortOrderInput | SortOrder
    time_and_place?: SortOrderInput | SortOrder
    is_active?: SortOrderInput | SortOrder
    _count?: smallgroupsCountOrderByAggregateInput
    _avg?: smallgroupsAvgOrderByAggregateInput
    _max?: smallgroupsMaxOrderByAggregateInput
    _min?: smallgroupsMinOrderByAggregateInput
    _sum?: smallgroupsSumOrderByAggregateInput
  }

  export type smallgroupsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<smallgroupsScalarWhereWithAggregatesInput>
    OR?: Enumerable<smallgroupsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<smallgroupsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringNullableWithAggregatesFilter | string | null
    description?: StringNullableWithAggregatesFilter | string | null
    resp_name?: StringNullableWithAggregatesFilter | string | null
    day?: StringNullableWithAggregatesFilter | string | null
    time_and_place?: StringNullableWithAggregatesFilter | string | null
    is_active?: BoolNullableWithAggregatesFilter | boolean | null
  }

  export type songdataWhereInput = {
    AND?: Enumerable<songdataWhereInput>
    OR?: Enumerable<songdataWhereInput>
    NOT?: Enumerable<songdataWhereInput>
    id?: IntFilter | number
    title?: StringNullableFilter | string | null
    composer?: StringNullableFilter | string | null
    lyrics?: StringNullableFilter | string | null
    version_description?: StringNullableFilter | string | null
    songtags?: SongtagsListRelationFilter
    versedata?: VersedataListRelationFilter
  }

  export type songdataOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrderInput | SortOrder
    composer?: SortOrderInput | SortOrder
    lyrics?: SortOrderInput | SortOrder
    version_description?: SortOrderInput | SortOrder
    songtags?: songtagsOrderByRelationAggregateInput
    versedata?: versedataOrderByRelationAggregateInput
  }

  export type songdataWhereUniqueInput = {
    id?: number
  }

  export type songdataOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrderInput | SortOrder
    composer?: SortOrderInput | SortOrder
    lyrics?: SortOrderInput | SortOrder
    version_description?: SortOrderInput | SortOrder
    _count?: songdataCountOrderByAggregateInput
    _avg?: songdataAvgOrderByAggregateInput
    _max?: songdataMaxOrderByAggregateInput
    _min?: songdataMinOrderByAggregateInput
    _sum?: songdataSumOrderByAggregateInput
  }

  export type songdataScalarWhereWithAggregatesInput = {
    AND?: Enumerable<songdataScalarWhereWithAggregatesInput>
    OR?: Enumerable<songdataScalarWhereWithAggregatesInput>
    NOT?: Enumerable<songdataScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    title?: StringNullableWithAggregatesFilter | string | null
    composer?: StringNullableWithAggregatesFilter | string | null
    lyrics?: StringNullableWithAggregatesFilter | string | null
    version_description?: StringNullableWithAggregatesFilter | string | null
  }

  export type songsegmentsWhereInput = {
    AND?: Enumerable<songsegmentsWhereInput>
    OR?: Enumerable<songsegmentsWhereInput>
    NOT?: Enumerable<songsegmentsWhereInput>
    id?: IntFilter | number
    songdescription?: StringNullableFilter | string | null
    restrictedto?: StringNullableFilter | string | null
    singlename?: StringNullableFilter | string | null
    is_multi?: BoolNullableFilter | boolean | null
    segment_name_is_title?: BoolNullableFilter | boolean | null
  }

  export type songsegmentsOrderByWithRelationInput = {
    id?: SortOrder
    songdescription?: SortOrderInput | SortOrder
    restrictedto?: SortOrderInput | SortOrder
    singlename?: SortOrderInput | SortOrder
    is_multi?: SortOrderInput | SortOrder
    segment_name_is_title?: SortOrderInput | SortOrder
  }

  export type songsegmentsWhereUniqueInput = {
    id?: number
  }

  export type songsegmentsOrderByWithAggregationInput = {
    id?: SortOrder
    songdescription?: SortOrderInput | SortOrder
    restrictedto?: SortOrderInput | SortOrder
    singlename?: SortOrderInput | SortOrder
    is_multi?: SortOrderInput | SortOrder
    segment_name_is_title?: SortOrderInput | SortOrder
    _count?: songsegmentsCountOrderByAggregateInput
    _avg?: songsegmentsAvgOrderByAggregateInput
    _max?: songsegmentsMaxOrderByAggregateInput
    _min?: songsegmentsMinOrderByAggregateInput
    _sum?: songsegmentsSumOrderByAggregateInput
  }

  export type songsegmentsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<songsegmentsScalarWhereWithAggregatesInput>
    OR?: Enumerable<songsegmentsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<songsegmentsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    songdescription?: StringNullableWithAggregatesFilter | string | null
    restrictedto?: StringNullableWithAggregatesFilter | string | null
    singlename?: StringNullableWithAggregatesFilter | string | null
    is_multi?: BoolNullableWithAggregatesFilter | boolean | null
    segment_name_is_title?: BoolNullableWithAggregatesFilter | boolean | null
  }

  export type songtagsWhereInput = {
    AND?: Enumerable<songtagsWhereInput>
    OR?: Enumerable<songtagsWhereInput>
    NOT?: Enumerable<songtagsWhereInput>
    id?: IntFilter | number
    song_id?: IntFilter | number
    tag?: StringNullableFilter | string | null
    songdata?: XOR<SongdataRelationFilter, songdataWhereInput>
  }

  export type songtagsOrderByWithRelationInput = {
    id?: SortOrder
    song_id?: SortOrder
    tag?: SortOrderInput | SortOrder
    songdata?: songdataOrderByWithRelationInput
  }

  export type songtagsWhereUniqueInput = {
    id?: number
  }

  export type songtagsOrderByWithAggregationInput = {
    id?: SortOrder
    song_id?: SortOrder
    tag?: SortOrderInput | SortOrder
    _count?: songtagsCountOrderByAggregateInput
    _avg?: songtagsAvgOrderByAggregateInput
    _max?: songtagsMaxOrderByAggregateInput
    _min?: songtagsMinOrderByAggregateInput
    _sum?: songtagsSumOrderByAggregateInput
  }

  export type songtagsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<songtagsScalarWhereWithAggregatesInput>
    OR?: Enumerable<songtagsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<songtagsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    song_id?: IntWithAggregatesFilter | number
    tag?: StringNullableWithAggregatesFilter | string | null
  }

  export type stylesWhereInput = {
    AND?: Enumerable<stylesWhereInput>
    OR?: Enumerable<stylesWhereInput>
    NOT?: Enumerable<stylesWhereInput>
    id?: IntFilter | number
    classname?: StringNullableFilter | string | null
    tagname?: StringNullableFilter | string | null
    attr?: StringNullableFilter | string | null
    value?: StringNullableFilter | string | null
    stylesheet?: StringNullableFilter | string | null
  }

  export type stylesOrderByWithRelationInput = {
    id?: SortOrder
    classname?: SortOrderInput | SortOrder
    tagname?: SortOrderInput | SortOrder
    attr?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    stylesheet?: SortOrderInput | SortOrder
  }

  export type stylesWhereUniqueInput = {
    id?: number
  }

  export type stylesOrderByWithAggregationInput = {
    id?: SortOrder
    classname?: SortOrderInput | SortOrder
    tagname?: SortOrderInput | SortOrder
    attr?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    stylesheet?: SortOrderInput | SortOrder
    _count?: stylesCountOrderByAggregateInput
    _avg?: stylesAvgOrderByAggregateInput
    _max?: stylesMaxOrderByAggregateInput
    _min?: stylesMinOrderByAggregateInput
    _sum?: stylesSumOrderByAggregateInput
  }

  export type stylesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<stylesScalarWhereWithAggregatesInput>
    OR?: Enumerable<stylesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<stylesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    classname?: StringNullableWithAggregatesFilter | string | null
    tagname?: StringNullableWithAggregatesFilter | string | null
    attr?: StringNullableWithAggregatesFilter | string | null
    value?: StringNullableWithAggregatesFilter | string | null
    stylesheet?: StringNullableWithAggregatesFilter | string | null
  }

  export type usersWhereInput = {
    AND?: Enumerable<usersWhereInput>
    OR?: Enumerable<usersWhereInput>
    NOT?: Enumerable<usersWhereInput>
    id?: IntFilter | number
    username?: StringNullableFilter | string | null
    password?: StringNullableFilter | string | null
  }

  export type usersOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
  }

  export type usersWhereUniqueInput = {
    id?: number
    username?: string
  }

  export type usersOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    _count?: usersCountOrderByAggregateInput
    _avg?: usersAvgOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
    _sum?: usersSumOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: Enumerable<usersScalarWhereWithAggregatesInput>
    OR?: Enumerable<usersScalarWhereWithAggregatesInput>
    NOT?: Enumerable<usersScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    username?: StringNullableWithAggregatesFilter | string | null
    password?: StringNullableWithAggregatesFilter | string | null
  }

  export type versedataWhereInput = {
    AND?: Enumerable<versedataWhereInput>
    OR?: Enumerable<versedataWhereInput>
    NOT?: Enumerable<versedataWhereInput>
    id?: IntFilter | number
    song_id?: IntFilter | number
    verse?: StringNullableFilter | string | null
    versetype?: StringNullableFilter | string | null
    songdata?: XOR<SongdataRelationFilter, songdataWhereInput>
  }

  export type versedataOrderByWithRelationInput = {
    id?: SortOrder
    song_id?: SortOrder
    verse?: SortOrderInput | SortOrder
    versetype?: SortOrderInput | SortOrder
    songdata?: songdataOrderByWithRelationInput
  }

  export type versedataWhereUniqueInput = {
    id?: number
  }

  export type versedataOrderByWithAggregationInput = {
    id?: SortOrder
    song_id?: SortOrder
    verse?: SortOrderInput | SortOrder
    versetype?: SortOrderInput | SortOrder
    _count?: versedataCountOrderByAggregateInput
    _avg?: versedataAvgOrderByAggregateInput
    _max?: versedataMaxOrderByAggregateInput
    _min?: versedataMinOrderByAggregateInput
    _sum?: versedataSumOrderByAggregateInput
  }

  export type versedataScalarWhereWithAggregatesInput = {
    AND?: Enumerable<versedataScalarWhereWithAggregatesInput>
    OR?: Enumerable<versedataScalarWhereWithAggregatesInput>
    NOT?: Enumerable<versedataScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    song_id?: IntWithAggregatesFilter | number
    verse?: StringNullableWithAggregatesFilter | string | null
    versetype?: StringNullableWithAggregatesFilter | string | null
  }

  export type backgroundsCreateInput = {
    filename?: string | null
    description?: string | null
  }

  export type backgroundsUncheckedCreateInput = {
    id?: number
    filename?: string | null
    description?: string | null
  }

  export type backgroundsUpdateInput = {
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type backgroundsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type backgroundsCreateManyInput = {
    id?: number
    filename?: string | null
    description?: string | null
  }

  export type backgroundsUpdateManyMutationInput = {
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type backgroundsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type biblesegmentsCreateInput = {
    start_book?: string | null
    start_chap?: number | null
    start_verse?: number | null
    end_book?: string | null
    end_chap?: number | null
    end_verse?: number | null
  }

  export type biblesegmentsUncheckedCreateInput = {
    id?: number
    start_book?: string | null
    start_chap?: number | null
    start_verse?: number | null
    end_book?: string | null
    end_chap?: number | null
    end_verse?: number | null
  }

  export type biblesegmentsUpdateInput = {
    start_book?: NullableStringFieldUpdateOperationsInput | string | null
    start_chap?: NullableIntFieldUpdateOperationsInput | number | null
    start_verse?: NullableIntFieldUpdateOperationsInput | number | null
    end_book?: NullableStringFieldUpdateOperationsInput | string | null
    end_chap?: NullableIntFieldUpdateOperationsInput | number | null
    end_verse?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type biblesegmentsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    start_book?: NullableStringFieldUpdateOperationsInput | string | null
    start_chap?: NullableIntFieldUpdateOperationsInput | number | null
    start_verse?: NullableIntFieldUpdateOperationsInput | number | null
    end_book?: NullableStringFieldUpdateOperationsInput | string | null
    end_chap?: NullableIntFieldUpdateOperationsInput | number | null
    end_verse?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type biblesegmentsCreateManyInput = {
    id?: number
    start_book?: string | null
    start_chap?: number | null
    start_verse?: number | null
    end_book?: string | null
    end_chap?: number | null
    end_verse?: number | null
  }

  export type biblesegmentsUpdateManyMutationInput = {
    start_book?: NullableStringFieldUpdateOperationsInput | string | null
    start_chap?: NullableIntFieldUpdateOperationsInput | number | null
    start_verse?: NullableIntFieldUpdateOperationsInput | number | null
    end_book?: NullableStringFieldUpdateOperationsInput | string | null
    end_chap?: NullableIntFieldUpdateOperationsInput | number | null
    end_verse?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type biblesegmentsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    start_book?: NullableStringFieldUpdateOperationsInput | string | null
    start_chap?: NullableIntFieldUpdateOperationsInput | number | null
    start_verse?: NullableIntFieldUpdateOperationsInput | number | null
    end_book?: NullableStringFieldUpdateOperationsInput | string | null
    end_chap?: NullableIntFieldUpdateOperationsInput | number | null
    end_verse?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type collected_offeringsCreateInput = {
    amount?: Decimal | DecimalJsLike | number | string | null
    offering_goals: offering_goalsCreateNestedOneWithoutCollected_offeringsInput
    services: servicesCreateNestedOneWithoutCollected_offeringsInput
  }

  export type collected_offeringsUncheckedCreateInput = {
    id?: number
    target_id: number
    service_id: number
    amount?: Decimal | DecimalJsLike | number | string | null
  }

  export type collected_offeringsUpdateInput = {
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    offering_goals?: offering_goalsUpdateOneRequiredWithoutCollected_offeringsNestedInput
    services?: servicesUpdateOneRequiredWithoutCollected_offeringsNestedInput
  }

  export type collected_offeringsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    target_id?: IntFieldUpdateOperationsInput | number
    service_id?: IntFieldUpdateOperationsInput | number
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type collected_offeringsCreateManyInput = {
    id?: number
    target_id: number
    service_id: number
    amount?: Decimal | DecimalJsLike | number | string | null
  }

  export type collected_offeringsUpdateManyMutationInput = {
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type collected_offeringsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    target_id?: IntFieldUpdateOperationsInput | number
    service_id?: IntFieldUpdateOperationsInput | number
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type commentsCreateInput = {
    reply_to?: number | null
    content?: string | null
    commentator?: string | null
    theme?: string | null
    comment_time?: Date | string | null
    services: servicesCreateNestedOneWithoutCommentsInput
  }

  export type commentsUncheckedCreateInput = {
    id?: number
    service_id: number
    reply_to?: number | null
    content?: string | null
    commentator?: string | null
    theme?: string | null
    comment_time?: Date | string | null
  }

  export type commentsUpdateInput = {
    reply_to?: NullableIntFieldUpdateOperationsInput | number | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    commentator?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    comment_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    services?: servicesUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type commentsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    service_id?: IntFieldUpdateOperationsInput | number
    reply_to?: NullableIntFieldUpdateOperationsInput | number | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    commentator?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    comment_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type commentsCreateManyInput = {
    id?: number
    service_id: number
    reply_to?: number | null
    content?: string | null
    commentator?: string | null
    theme?: string | null
    comment_time?: Date | string | null
  }

  export type commentsUpdateManyMutationInput = {
    reply_to?: NullableIntFieldUpdateOperationsInput | number | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    commentator?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    comment_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type commentsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    service_id?: IntFieldUpdateOperationsInput | number
    reply_to?: NullableIntFieldUpdateOperationsInput | number | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    commentator?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    comment_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type eventsCreateInput = {
    name?: string | null
    place_and_time?: string | null
    description?: string | null
    event_date?: Date | string | null
    has_songs?: boolean | null
  }

  export type eventsUncheckedCreateInput = {
    id?: number
    name?: string | null
    place_and_time?: string | null
    description?: string | null
    event_date?: Date | string | null
    has_songs?: boolean | null
  }

  export type eventsUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    place_and_time?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    event_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    has_songs?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type eventsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    place_and_time?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    event_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    has_songs?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type eventsCreateManyInput = {
    id?: number
    name?: string | null
    place_and_time?: string | null
    description?: string | null
    event_date?: Date | string | null
    has_songs?: boolean | null
  }

  export type eventsUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    place_and_time?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    event_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    has_songs?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type eventsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    place_and_time?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    event_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    has_songs?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type headersCreateInput = {
    template_name?: string | null
    maintext?: string | null
    imgname?: string | null
    imgposition?: string | null
    is_aside?: boolean | null
  }

  export type headersUncheckedCreateInput = {
    id?: number
    template_name?: string | null
    maintext?: string | null
    imgname?: string | null
    imgposition?: string | null
    is_aside?: boolean | null
  }

  export type headersUpdateInput = {
    template_name?: NullableStringFieldUpdateOperationsInput | string | null
    maintext?: NullableStringFieldUpdateOperationsInput | string | null
    imgname?: NullableStringFieldUpdateOperationsInput | string | null
    imgposition?: NullableStringFieldUpdateOperationsInput | string | null
    is_aside?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type headersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    template_name?: NullableStringFieldUpdateOperationsInput | string | null
    maintext?: NullableStringFieldUpdateOperationsInput | string | null
    imgname?: NullableStringFieldUpdateOperationsInput | string | null
    imgposition?: NullableStringFieldUpdateOperationsInput | string | null
    is_aside?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type headersCreateManyInput = {
    id?: number
    template_name?: string | null
    maintext?: string | null
    imgname?: string | null
    imgposition?: string | null
    is_aside?: boolean | null
  }

  export type headersUpdateManyMutationInput = {
    template_name?: NullableStringFieldUpdateOperationsInput | string | null
    maintext?: NullableStringFieldUpdateOperationsInput | string | null
    imgname?: NullableStringFieldUpdateOperationsInput | string | null
    imgposition?: NullableStringFieldUpdateOperationsInput | string | null
    is_aside?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type headersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    template_name?: NullableStringFieldUpdateOperationsInput | string | null
    maintext?: NullableStringFieldUpdateOperationsInput | string | null
    imgname?: NullableStringFieldUpdateOperationsInput | string | null
    imgposition?: NullableStringFieldUpdateOperationsInput | string | null
    is_aside?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type infosCreateInput = {
    service_id: number
    slot_name?: string | null
    content_id: number
    addedclass?: string | null
    header_id?: number | null
  }

  export type infosUncheckedCreateInput = {
    id?: number
    service_id: number
    slot_name?: string | null
    content_id: number
    addedclass?: string | null
    header_id?: number | null
  }

  export type infosUpdateInput = {
    service_id?: IntFieldUpdateOperationsInput | number
    slot_name?: NullableStringFieldUpdateOperationsInput | string | null
    content_id?: IntFieldUpdateOperationsInput | number
    addedclass?: NullableStringFieldUpdateOperationsInput | string | null
    header_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type infosUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    service_id?: IntFieldUpdateOperationsInput | number
    slot_name?: NullableStringFieldUpdateOperationsInput | string | null
    content_id?: IntFieldUpdateOperationsInput | number
    addedclass?: NullableStringFieldUpdateOperationsInput | string | null
    header_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type infosCreateManyInput = {
    id?: number
    service_id: number
    slot_name?: string | null
    content_id: number
    addedclass?: string | null
    header_id?: number | null
  }

  export type infosUpdateManyMutationInput = {
    service_id?: IntFieldUpdateOperationsInput | number
    slot_name?: NullableStringFieldUpdateOperationsInput | string | null
    content_id?: IntFieldUpdateOperationsInput | number
    addedclass?: NullableStringFieldUpdateOperationsInput | string | null
    header_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type infosUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    service_id?: IntFieldUpdateOperationsInput | number
    slot_name?: NullableStringFieldUpdateOperationsInput | string | null
    content_id?: IntFieldUpdateOperationsInput | number
    addedclass?: NullableStringFieldUpdateOperationsInput | string | null
    header_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type infosegmentsCreateInput = {
    maintext?: string | null
    header?: string | null
    genheader?: string | null
    subgenheader?: string | null
    imgname?: string | null
    imgposition?: string | null
  }

  export type infosegmentsUncheckedCreateInput = {
    id?: number
    maintext?: string | null
    header?: string | null
    genheader?: string | null
    subgenheader?: string | null
    imgname?: string | null
    imgposition?: string | null
  }

  export type infosegmentsUpdateInput = {
    maintext?: NullableStringFieldUpdateOperationsInput | string | null
    header?: NullableStringFieldUpdateOperationsInput | string | null
    genheader?: NullableStringFieldUpdateOperationsInput | string | null
    subgenheader?: NullableStringFieldUpdateOperationsInput | string | null
    imgname?: NullableStringFieldUpdateOperationsInput | string | null
    imgposition?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type infosegmentsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    maintext?: NullableStringFieldUpdateOperationsInput | string | null
    header?: NullableStringFieldUpdateOperationsInput | string | null
    genheader?: NullableStringFieldUpdateOperationsInput | string | null
    subgenheader?: NullableStringFieldUpdateOperationsInput | string | null
    imgname?: NullableStringFieldUpdateOperationsInput | string | null
    imgposition?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type infosegmentsCreateManyInput = {
    id?: number
    maintext?: string | null
    header?: string | null
    genheader?: string | null
    subgenheader?: string | null
    imgname?: string | null
    imgposition?: string | null
  }

  export type infosegmentsUpdateManyMutationInput = {
    maintext?: NullableStringFieldUpdateOperationsInput | string | null
    header?: NullableStringFieldUpdateOperationsInput | string | null
    genheader?: NullableStringFieldUpdateOperationsInput | string | null
    subgenheader?: NullableStringFieldUpdateOperationsInput | string | null
    imgname?: NullableStringFieldUpdateOperationsInput | string | null
    imgposition?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type infosegmentsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    maintext?: NullableStringFieldUpdateOperationsInput | string | null
    header?: NullableStringFieldUpdateOperationsInput | string | null
    genheader?: NullableStringFieldUpdateOperationsInput | string | null
    subgenheader?: NullableStringFieldUpdateOperationsInput | string | null
    imgname?: NullableStringFieldUpdateOperationsInput | string | null
    imgposition?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type liturgicalsegmentsCreateInput = {
    text_title?: string | null
    use_as_header?: boolean | null
  }

  export type liturgicalsegmentsUncheckedCreateInput = {
    id?: number
    text_title?: string | null
    use_as_header?: boolean | null
  }

  export type liturgicalsegmentsUpdateInput = {
    text_title?: NullableStringFieldUpdateOperationsInput | string | null
    use_as_header?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type liturgicalsegmentsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    text_title?: NullableStringFieldUpdateOperationsInput | string | null
    use_as_header?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type liturgicalsegmentsCreateManyInput = {
    id?: number
    text_title?: string | null
    use_as_header?: boolean | null
  }

  export type liturgicalsegmentsUpdateManyMutationInput = {
    text_title?: NullableStringFieldUpdateOperationsInput | string | null
    use_as_header?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type liturgicalsegmentsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    text_title?: NullableStringFieldUpdateOperationsInput | string | null
    use_as_header?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ltextdataCreateInput = {
    title?: string | null
    ltextversedata?: ltextversedataCreateNestedManyWithoutLtextdataInput
  }

  export type ltextdataUncheckedCreateInput = {
    id?: number
    title?: string | null
    ltextversedata?: ltextversedataUncheckedCreateNestedManyWithoutLtextdataInput
  }

  export type ltextdataUpdateInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    ltextversedata?: ltextversedataUpdateManyWithoutLtextdataNestedInput
  }

  export type ltextdataUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    ltextversedata?: ltextversedataUncheckedUpdateManyWithoutLtextdataNestedInput
  }

  export type ltextdataCreateManyInput = {
    id?: number
    title?: string | null
  }

  export type ltextdataUpdateManyMutationInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ltextdataUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ltextversedataCreateInput = {
    verse?: string | null
    ltextdata: ltextdataCreateNestedOneWithoutLtextversedataInput
  }

  export type ltextversedataUncheckedCreateInput = {
    id?: number
    ltext_id: number
    verse?: string | null
  }

  export type ltextversedataUpdateInput = {
    verse?: NullableStringFieldUpdateOperationsInput | string | null
    ltextdata?: ltextdataUpdateOneRequiredWithoutLtextversedataNestedInput
  }

  export type ltextversedataUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ltext_id?: IntFieldUpdateOperationsInput | number
    verse?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ltextversedataCreateManyInput = {
    id?: number
    ltext_id: number
    verse?: string | null
  }

  export type ltextversedataUpdateManyMutationInput = {
    verse?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ltextversedataUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ltext_id?: IntFieldUpdateOperationsInput | number
    verse?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type offering_goalsCreateInput = {
    name?: string | null
    description?: string | null
    amount?: Decimal | DecimalJsLike | number | string | null
    is_default?: boolean | null
    collected_offerings?: collected_offeringsCreateNestedManyWithoutOffering_goalsInput
    offering_targets: offering_targetsCreateNestedOneWithoutOffering_goalsInput
  }

  export type offering_goalsUncheckedCreateInput = {
    id?: number
    target_id: number
    name?: string | null
    description?: string | null
    amount?: Decimal | DecimalJsLike | number | string | null
    is_default?: boolean | null
    collected_offerings?: collected_offeringsUncheckedCreateNestedManyWithoutOffering_goalsInput
  }

  export type offering_goalsUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_default?: NullableBoolFieldUpdateOperationsInput | boolean | null
    collected_offerings?: collected_offeringsUpdateManyWithoutOffering_goalsNestedInput
    offering_targets?: offering_targetsUpdateOneRequiredWithoutOffering_goalsNestedInput
  }

  export type offering_goalsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    target_id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_default?: NullableBoolFieldUpdateOperationsInput | boolean | null
    collected_offerings?: collected_offeringsUncheckedUpdateManyWithoutOffering_goalsNestedInput
  }

  export type offering_goalsCreateManyInput = {
    id?: number
    target_id: number
    name?: string | null
    description?: string | null
    amount?: Decimal | DecimalJsLike | number | string | null
    is_default?: boolean | null
  }

  export type offering_goalsUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_default?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type offering_goalsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    target_id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_default?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type offering_targetsCreateInput = {
    name?: string | null
    description?: string | null
    offering_goals?: offering_goalsCreateNestedManyWithoutOffering_targetsInput
  }

  export type offering_targetsUncheckedCreateInput = {
    id?: number
    name?: string | null
    description?: string | null
    offering_goals?: offering_goalsUncheckedCreateNestedManyWithoutOffering_targetsInput
  }

  export type offering_targetsUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    offering_goals?: offering_goalsUpdateManyWithoutOffering_targetsNestedInput
  }

  export type offering_targetsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    offering_goals?: offering_goalsUncheckedUpdateManyWithoutOffering_targetsNestedInput
  }

  export type offering_targetsCreateManyInput = {
    id?: number
    name?: string | null
    description?: string | null
  }

  export type offering_targetsUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type offering_targetsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type presentation_contentCreateInput = {
    content_type?: string | null
    new_slide?: string | null
    content?: string | null
    presentation_structure: presentation_structureCreateNestedOneWithoutPresentation_contentInput
  }

  export type presentation_contentUncheckedCreateInput = {
    id?: number
    slot_id: number
    content_type?: string | null
    new_slide?: string | null
    content?: string | null
  }

  export type presentation_contentUpdateInput = {
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    new_slide?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    presentation_structure?: presentation_structureUpdateOneRequiredWithoutPresentation_contentNestedInput
  }

  export type presentation_contentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    slot_id?: IntFieldUpdateOperationsInput | number
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    new_slide?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type presentation_contentCreateManyInput = {
    id?: number
    slot_id: number
    content_type?: string | null
    new_slide?: string | null
    content?: string | null
  }

  export type presentation_contentUpdateManyMutationInput = {
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    new_slide?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type presentation_contentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    slot_id?: IntFieldUpdateOperationsInput | number
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    new_slide?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type presentation_structureCreateInput = {
    service_id?: number | null
    slot_name?: string | null
    slot_number?: number | null
    slot_type?: string | null
    id_in_type_table?: string | null
    addedclass?: string | null
    header_id?: number | null
    content_id: number
    instruction?: string | null
    presentation_content?: presentation_contentCreateNestedManyWithoutPresentation_structureInput
  }

  export type presentation_structureUncheckedCreateInput = {
    id?: number
    service_id?: number | null
    slot_name?: string | null
    slot_number?: number | null
    slot_type?: string | null
    id_in_type_table?: string | null
    addedclass?: string | null
    header_id?: number | null
    content_id: number
    instruction?: string | null
    presentation_content?: presentation_contentUncheckedCreateNestedManyWithoutPresentation_structureInput
  }

  export type presentation_structureUpdateInput = {
    service_id?: NullableIntFieldUpdateOperationsInput | number | null
    slot_name?: NullableStringFieldUpdateOperationsInput | string | null
    slot_number?: NullableIntFieldUpdateOperationsInput | number | null
    slot_type?: NullableStringFieldUpdateOperationsInput | string | null
    id_in_type_table?: NullableStringFieldUpdateOperationsInput | string | null
    addedclass?: NullableStringFieldUpdateOperationsInput | string | null
    header_id?: NullableIntFieldUpdateOperationsInput | number | null
    content_id?: IntFieldUpdateOperationsInput | number
    instruction?: NullableStringFieldUpdateOperationsInput | string | null
    presentation_content?: presentation_contentUpdateManyWithoutPresentation_structureNestedInput
  }

  export type presentation_structureUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    service_id?: NullableIntFieldUpdateOperationsInput | number | null
    slot_name?: NullableStringFieldUpdateOperationsInput | string | null
    slot_number?: NullableIntFieldUpdateOperationsInput | number | null
    slot_type?: NullableStringFieldUpdateOperationsInput | string | null
    id_in_type_table?: NullableStringFieldUpdateOperationsInput | string | null
    addedclass?: NullableStringFieldUpdateOperationsInput | string | null
    header_id?: NullableIntFieldUpdateOperationsInput | number | null
    content_id?: IntFieldUpdateOperationsInput | number
    instruction?: NullableStringFieldUpdateOperationsInput | string | null
    presentation_content?: presentation_contentUncheckedUpdateManyWithoutPresentation_structureNestedInput
  }

  export type presentation_structureCreateManyInput = {
    id?: number
    service_id?: number | null
    slot_name?: string | null
    slot_number?: number | null
    slot_type?: string | null
    id_in_type_table?: string | null
    addedclass?: string | null
    header_id?: number | null
    content_id: number
    instruction?: string | null
  }

  export type presentation_structureUpdateManyMutationInput = {
    service_id?: NullableIntFieldUpdateOperationsInput | number | null
    slot_name?: NullableStringFieldUpdateOperationsInput | string | null
    slot_number?: NullableIntFieldUpdateOperationsInput | number | null
    slot_type?: NullableStringFieldUpdateOperationsInput | string | null
    id_in_type_table?: NullableStringFieldUpdateOperationsInput | string | null
    addedclass?: NullableStringFieldUpdateOperationsInput | string | null
    header_id?: NullableIntFieldUpdateOperationsInput | number | null
    content_id?: IntFieldUpdateOperationsInput | number
    instruction?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type presentation_structureUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    service_id?: NullableIntFieldUpdateOperationsInput | number | null
    slot_name?: NullableStringFieldUpdateOperationsInput | string | null
    slot_number?: NullableIntFieldUpdateOperationsInput | number | null
    slot_type?: NullableStringFieldUpdateOperationsInput | string | null
    id_in_type_table?: NullableStringFieldUpdateOperationsInput | string | null
    addedclass?: NullableStringFieldUpdateOperationsInput | string | null
    header_id?: NullableIntFieldUpdateOperationsInput | number | null
    content_id?: IntFieldUpdateOperationsInput | number
    instruction?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type responsibilitiesCreateInput = {
    responsibility?: string | null
    responsible?: string | null
    services: servicesCreateNestedOneWithoutResponsibilitiesInput
  }

  export type responsibilitiesUncheckedCreateInput = {
    id?: number
    service_id: number
    responsibility?: string | null
    responsible?: string | null
  }

  export type responsibilitiesUpdateInput = {
    responsibility?: NullableStringFieldUpdateOperationsInput | string | null
    responsible?: NullableStringFieldUpdateOperationsInput | string | null
    services?: servicesUpdateOneRequiredWithoutResponsibilitiesNestedInput
  }

  export type responsibilitiesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    service_id?: IntFieldUpdateOperationsInput | number
    responsibility?: NullableStringFieldUpdateOperationsInput | string | null
    responsible?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type responsibilitiesCreateManyInput = {
    id?: number
    service_id: number
    responsibility?: string | null
    responsible?: string | null
  }

  export type responsibilitiesUpdateManyMutationInput = {
    responsibility?: NullableStringFieldUpdateOperationsInput | string | null
    responsible?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type responsibilitiesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    service_id?: IntFieldUpdateOperationsInput | number
    responsibility?: NullableStringFieldUpdateOperationsInput | string | null
    responsible?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type responsibilities_metaCreateInput = {
    responsibility?: string | null
    description?: string | null
  }

  export type responsibilities_metaUncheckedCreateInput = {
    id?: number
    responsibility?: string | null
    description?: string | null
  }

  export type responsibilities_metaUpdateInput = {
    responsibility?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type responsibilities_metaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    responsibility?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type responsibilities_metaCreateManyInput = {
    id?: number
    responsibility?: string | null
    description?: string | null
  }

  export type responsibilities_metaUpdateManyMutationInput = {
    responsibility?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type responsibilities_metaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    responsibility?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type seasonsCreateInput = {
    startdate?: Date | string | null
    enddate?: Date | string | null
    theme?: string | null
    comments?: string | null
    name?: string | null
  }

  export type seasonsUncheckedCreateInput = {
    id?: number
    startdate?: Date | string | null
    enddate?: Date | string | null
    theme?: string | null
    comments?: string | null
    name?: string | null
  }

  export type seasonsUpdateInput = {
    startdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enddate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type seasonsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    startdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enddate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type seasonsCreateManyInput = {
    id?: number
    startdate?: Date | string | null
    enddate?: Date | string | null
    theme?: string | null
    comments?: string | null
    name?: string | null
  }

  export type seasonsUpdateManyMutationInput = {
    startdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enddate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type seasonsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    startdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enddate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type service_specific_presentation_structureCreateInput = {
    service_id: number
    slot_name?: string | null
    slot_number?: number | null
    slot_type?: string | null
    id_in_type_table?: string | null
    content_id: number
    addedclass?: string | null
    header_id?: number | null
    instruction?: string | null
  }

  export type service_specific_presentation_structureUncheckedCreateInput = {
    id?: number
    service_id: number
    slot_name?: string | null
    slot_number?: number | null
    slot_type?: string | null
    id_in_type_table?: string | null
    content_id: number
    addedclass?: string | null
    header_id?: number | null
    instruction?: string | null
  }

  export type service_specific_presentation_structureUpdateInput = {
    service_id?: IntFieldUpdateOperationsInput | number
    slot_name?: NullableStringFieldUpdateOperationsInput | string | null
    slot_number?: NullableIntFieldUpdateOperationsInput | number | null
    slot_type?: NullableStringFieldUpdateOperationsInput | string | null
    id_in_type_table?: NullableStringFieldUpdateOperationsInput | string | null
    content_id?: IntFieldUpdateOperationsInput | number
    addedclass?: NullableStringFieldUpdateOperationsInput | string | null
    header_id?: NullableIntFieldUpdateOperationsInput | number | null
    instruction?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type service_specific_presentation_structureUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    service_id?: IntFieldUpdateOperationsInput | number
    slot_name?: NullableStringFieldUpdateOperationsInput | string | null
    slot_number?: NullableIntFieldUpdateOperationsInput | number | null
    slot_type?: NullableStringFieldUpdateOperationsInput | string | null
    id_in_type_table?: NullableStringFieldUpdateOperationsInput | string | null
    content_id?: IntFieldUpdateOperationsInput | number
    addedclass?: NullableStringFieldUpdateOperationsInput | string | null
    header_id?: NullableIntFieldUpdateOperationsInput | number | null
    instruction?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type service_specific_presentation_structureCreateManyInput = {
    id?: number
    service_id: number
    slot_name?: string | null
    slot_number?: number | null
    slot_type?: string | null
    id_in_type_table?: string | null
    content_id: number
    addedclass?: string | null
    header_id?: number | null
    instruction?: string | null
  }

  export type service_specific_presentation_structureUpdateManyMutationInput = {
    service_id?: IntFieldUpdateOperationsInput | number
    slot_name?: NullableStringFieldUpdateOperationsInput | string | null
    slot_number?: NullableIntFieldUpdateOperationsInput | number | null
    slot_type?: NullableStringFieldUpdateOperationsInput | string | null
    id_in_type_table?: NullableStringFieldUpdateOperationsInput | string | null
    content_id?: IntFieldUpdateOperationsInput | number
    addedclass?: NullableStringFieldUpdateOperationsInput | string | null
    header_id?: NullableIntFieldUpdateOperationsInput | number | null
    instruction?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type service_specific_presentation_structureUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    service_id?: IntFieldUpdateOperationsInput | number
    slot_name?: NullableStringFieldUpdateOperationsInput | string | null
    slot_number?: NullableIntFieldUpdateOperationsInput | number | null
    slot_type?: NullableStringFieldUpdateOperationsInput | string | null
    id_in_type_table?: NullableStringFieldUpdateOperationsInput | string | null
    content_id?: IntFieldUpdateOperationsInput | number
    addedclass?: NullableStringFieldUpdateOperationsInput | string | null
    header_id?: NullableIntFieldUpdateOperationsInput | number | null
    instruction?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type servicesCreateInput = {
    servicedate?: Date | string | null
    theme?: string | null
    collected_offerings?: collected_offeringsCreateNestedManyWithoutServicesInput
    comments?: commentsCreateNestedManyWithoutServicesInput
    responsibilities?: responsibilitiesCreateNestedManyWithoutServicesInput
    servicesongs?: servicesongsCreateNestedManyWithoutServicesInput
    serviceverses?: serviceversesCreateNestedManyWithoutServicesInput
  }

  export type servicesUncheckedCreateInput = {
    id?: number
    servicedate?: Date | string | null
    theme?: string | null
    collected_offerings?: collected_offeringsUncheckedCreateNestedManyWithoutServicesInput
    comments?: commentsUncheckedCreateNestedManyWithoutServicesInput
    responsibilities?: responsibilitiesUncheckedCreateNestedManyWithoutServicesInput
    servicesongs?: servicesongsUncheckedCreateNestedManyWithoutServicesInput
    serviceverses?: serviceversesUncheckedCreateNestedManyWithoutServicesInput
  }

  export type servicesUpdateInput = {
    servicedate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    collected_offerings?: collected_offeringsUpdateManyWithoutServicesNestedInput
    comments?: commentsUpdateManyWithoutServicesNestedInput
    responsibilities?: responsibilitiesUpdateManyWithoutServicesNestedInput
    servicesongs?: servicesongsUpdateManyWithoutServicesNestedInput
    serviceverses?: serviceversesUpdateManyWithoutServicesNestedInput
  }

  export type servicesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    servicedate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    collected_offerings?: collected_offeringsUncheckedUpdateManyWithoutServicesNestedInput
    comments?: commentsUncheckedUpdateManyWithoutServicesNestedInput
    responsibilities?: responsibilitiesUncheckedUpdateManyWithoutServicesNestedInput
    servicesongs?: servicesongsUncheckedUpdateManyWithoutServicesNestedInput
    serviceverses?: serviceversesUncheckedUpdateManyWithoutServicesNestedInput
  }

  export type servicesCreateManyInput = {
    id?: number
    servicedate?: Date | string | null
    theme?: string | null
  }

  export type servicesUpdateManyMutationInput = {
    servicedate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    theme?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type servicesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    servicedate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    theme?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type servicesongsCreateInput = {
    id?: bigint | number
    song_title?: string | null
    verses?: string | null
    is_instrumental?: string | null
    song_id?: number | null
    songtype: string
    position?: number | null
    services: servicesCreateNestedOneWithoutServicesongsInput
  }

  export type servicesongsUncheckedCreateInput = {
    id?: bigint | number
    service_id: number
    song_title?: string | null
    verses?: string | null
    is_instrumental?: string | null
    song_id?: number | null
    songtype: string
    position?: number | null
  }

  export type servicesongsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    song_title?: NullableStringFieldUpdateOperationsInput | string | null
    verses?: NullableStringFieldUpdateOperationsInput | string | null
    is_instrumental?: NullableStringFieldUpdateOperationsInput | string | null
    song_id?: NullableIntFieldUpdateOperationsInput | number | null
    songtype?: StringFieldUpdateOperationsInput | string
    position?: NullableIntFieldUpdateOperationsInput | number | null
    services?: servicesUpdateOneRequiredWithoutServicesongsNestedInput
  }

  export type servicesongsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    service_id?: IntFieldUpdateOperationsInput | number
    song_title?: NullableStringFieldUpdateOperationsInput | string | null
    verses?: NullableStringFieldUpdateOperationsInput | string | null
    is_instrumental?: NullableStringFieldUpdateOperationsInput | string | null
    song_id?: NullableIntFieldUpdateOperationsInput | number | null
    songtype?: StringFieldUpdateOperationsInput | string
    position?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type servicesongsCreateManyInput = {
    id?: bigint | number
    service_id: number
    song_title?: string | null
    verses?: string | null
    is_instrumental?: string | null
    song_id?: number | null
    songtype: string
    position?: number | null
  }

  export type servicesongsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    song_title?: NullableStringFieldUpdateOperationsInput | string | null
    verses?: NullableStringFieldUpdateOperationsInput | string | null
    is_instrumental?: NullableStringFieldUpdateOperationsInput | string | null
    song_id?: NullableIntFieldUpdateOperationsInput | number | null
    songtype?: StringFieldUpdateOperationsInput | string
    position?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type servicesongsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    service_id?: IntFieldUpdateOperationsInput | number
    song_title?: NullableStringFieldUpdateOperationsInput | string | null
    verses?: NullableStringFieldUpdateOperationsInput | string | null
    is_instrumental?: NullableStringFieldUpdateOperationsInput | string | null
    song_id?: NullableIntFieldUpdateOperationsInput | number | null
    songtype?: StringFieldUpdateOperationsInput | string
    position?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type serviceversesCreateInput = {
    segment_name?: string | null
    testament?: string | null
    startbook?: string | null
    endbook?: string | null
    startchapter?: number | null
    endchapter?: number | null
    startverse?: number | null
    endverse?: number | null
    services: servicesCreateNestedOneWithoutServiceversesInput
  }

  export type serviceversesUncheckedCreateInput = {
    id?: number
    service_id: number
    segment_name?: string | null
    testament?: string | null
    startbook?: string | null
    endbook?: string | null
    startchapter?: number | null
    endchapter?: number | null
    startverse?: number | null
    endverse?: number | null
  }

  export type serviceversesUpdateInput = {
    segment_name?: NullableStringFieldUpdateOperationsInput | string | null
    testament?: NullableStringFieldUpdateOperationsInput | string | null
    startbook?: NullableStringFieldUpdateOperationsInput | string | null
    endbook?: NullableStringFieldUpdateOperationsInput | string | null
    startchapter?: NullableIntFieldUpdateOperationsInput | number | null
    endchapter?: NullableIntFieldUpdateOperationsInput | number | null
    startverse?: NullableIntFieldUpdateOperationsInput | number | null
    endverse?: NullableIntFieldUpdateOperationsInput | number | null
    services?: servicesUpdateOneRequiredWithoutServiceversesNestedInput
  }

  export type serviceversesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    service_id?: IntFieldUpdateOperationsInput | number
    segment_name?: NullableStringFieldUpdateOperationsInput | string | null
    testament?: NullableStringFieldUpdateOperationsInput | string | null
    startbook?: NullableStringFieldUpdateOperationsInput | string | null
    endbook?: NullableStringFieldUpdateOperationsInput | string | null
    startchapter?: NullableIntFieldUpdateOperationsInput | number | null
    endchapter?: NullableIntFieldUpdateOperationsInput | number | null
    startverse?: NullableIntFieldUpdateOperationsInput | number | null
    endverse?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type serviceversesCreateManyInput = {
    id?: number
    service_id: number
    segment_name?: string | null
    testament?: string | null
    startbook?: string | null
    endbook?: string | null
    startchapter?: number | null
    endchapter?: number | null
    startverse?: number | null
    endverse?: number | null
  }

  export type serviceversesUpdateManyMutationInput = {
    segment_name?: NullableStringFieldUpdateOperationsInput | string | null
    testament?: NullableStringFieldUpdateOperationsInput | string | null
    startbook?: NullableStringFieldUpdateOperationsInput | string | null
    endbook?: NullableStringFieldUpdateOperationsInput | string | null
    startchapter?: NullableIntFieldUpdateOperationsInput | number | null
    endchapter?: NullableIntFieldUpdateOperationsInput | number | null
    startverse?: NullableIntFieldUpdateOperationsInput | number | null
    endverse?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type serviceversesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    service_id?: IntFieldUpdateOperationsInput | number
    segment_name?: NullableStringFieldUpdateOperationsInput | string | null
    testament?: NullableStringFieldUpdateOperationsInput | string | null
    startbook?: NullableStringFieldUpdateOperationsInput | string | null
    endbook?: NullableStringFieldUpdateOperationsInput | string | null
    startchapter?: NullableIntFieldUpdateOperationsInput | number | null
    endchapter?: NullableIntFieldUpdateOperationsInput | number | null
    startverse?: NullableIntFieldUpdateOperationsInput | number | null
    endverse?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type smallgroupsCreateInput = {
    name?: string | null
    description?: string | null
    resp_name?: string | null
    day?: string | null
    time_and_place?: string | null
    is_active?: boolean | null
  }

  export type smallgroupsUncheckedCreateInput = {
    id?: number
    name?: string | null
    description?: string | null
    resp_name?: string | null
    day?: string | null
    time_and_place?: string | null
    is_active?: boolean | null
  }

  export type smallgroupsUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resp_name?: NullableStringFieldUpdateOperationsInput | string | null
    day?: NullableStringFieldUpdateOperationsInput | string | null
    time_and_place?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type smallgroupsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resp_name?: NullableStringFieldUpdateOperationsInput | string | null
    day?: NullableStringFieldUpdateOperationsInput | string | null
    time_and_place?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type smallgroupsCreateManyInput = {
    id?: number
    name?: string | null
    description?: string | null
    resp_name?: string | null
    day?: string | null
    time_and_place?: string | null
    is_active?: boolean | null
  }

  export type smallgroupsUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resp_name?: NullableStringFieldUpdateOperationsInput | string | null
    day?: NullableStringFieldUpdateOperationsInput | string | null
    time_and_place?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type smallgroupsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resp_name?: NullableStringFieldUpdateOperationsInput | string | null
    day?: NullableStringFieldUpdateOperationsInput | string | null
    time_and_place?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type songdataCreateInput = {
    title?: string | null
    composer?: string | null
    lyrics?: string | null
    version_description?: string | null
    songtags?: songtagsCreateNestedManyWithoutSongdataInput
    versedata?: versedataCreateNestedManyWithoutSongdataInput
  }

  export type songdataUncheckedCreateInput = {
    id?: number
    title?: string | null
    composer?: string | null
    lyrics?: string | null
    version_description?: string | null
    songtags?: songtagsUncheckedCreateNestedManyWithoutSongdataInput
    versedata?: versedataUncheckedCreateNestedManyWithoutSongdataInput
  }

  export type songdataUpdateInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    composer?: NullableStringFieldUpdateOperationsInput | string | null
    lyrics?: NullableStringFieldUpdateOperationsInput | string | null
    version_description?: NullableStringFieldUpdateOperationsInput | string | null
    songtags?: songtagsUpdateManyWithoutSongdataNestedInput
    versedata?: versedataUpdateManyWithoutSongdataNestedInput
  }

  export type songdataUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    composer?: NullableStringFieldUpdateOperationsInput | string | null
    lyrics?: NullableStringFieldUpdateOperationsInput | string | null
    version_description?: NullableStringFieldUpdateOperationsInput | string | null
    songtags?: songtagsUncheckedUpdateManyWithoutSongdataNestedInput
    versedata?: versedataUncheckedUpdateManyWithoutSongdataNestedInput
  }

  export type songdataCreateManyInput = {
    id?: number
    title?: string | null
    composer?: string | null
    lyrics?: string | null
    version_description?: string | null
  }

  export type songdataUpdateManyMutationInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    composer?: NullableStringFieldUpdateOperationsInput | string | null
    lyrics?: NullableStringFieldUpdateOperationsInput | string | null
    version_description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type songdataUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    composer?: NullableStringFieldUpdateOperationsInput | string | null
    lyrics?: NullableStringFieldUpdateOperationsInput | string | null
    version_description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type songsegmentsCreateInput = {
    songdescription?: string | null
    restrictedto?: string | null
    singlename?: string | null
    is_multi?: boolean | null
    segment_name_is_title?: boolean | null
  }

  export type songsegmentsUncheckedCreateInput = {
    id?: number
    songdescription?: string | null
    restrictedto?: string | null
    singlename?: string | null
    is_multi?: boolean | null
    segment_name_is_title?: boolean | null
  }

  export type songsegmentsUpdateInput = {
    songdescription?: NullableStringFieldUpdateOperationsInput | string | null
    restrictedto?: NullableStringFieldUpdateOperationsInput | string | null
    singlename?: NullableStringFieldUpdateOperationsInput | string | null
    is_multi?: NullableBoolFieldUpdateOperationsInput | boolean | null
    segment_name_is_title?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type songsegmentsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    songdescription?: NullableStringFieldUpdateOperationsInput | string | null
    restrictedto?: NullableStringFieldUpdateOperationsInput | string | null
    singlename?: NullableStringFieldUpdateOperationsInput | string | null
    is_multi?: NullableBoolFieldUpdateOperationsInput | boolean | null
    segment_name_is_title?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type songsegmentsCreateManyInput = {
    id?: number
    songdescription?: string | null
    restrictedto?: string | null
    singlename?: string | null
    is_multi?: boolean | null
    segment_name_is_title?: boolean | null
  }

  export type songsegmentsUpdateManyMutationInput = {
    songdescription?: NullableStringFieldUpdateOperationsInput | string | null
    restrictedto?: NullableStringFieldUpdateOperationsInput | string | null
    singlename?: NullableStringFieldUpdateOperationsInput | string | null
    is_multi?: NullableBoolFieldUpdateOperationsInput | boolean | null
    segment_name_is_title?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type songsegmentsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    songdescription?: NullableStringFieldUpdateOperationsInput | string | null
    restrictedto?: NullableStringFieldUpdateOperationsInput | string | null
    singlename?: NullableStringFieldUpdateOperationsInput | string | null
    is_multi?: NullableBoolFieldUpdateOperationsInput | boolean | null
    segment_name_is_title?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type songtagsCreateInput = {
    tag?: string | null
    songdata: songdataCreateNestedOneWithoutSongtagsInput
  }

  export type songtagsUncheckedCreateInput = {
    id?: number
    song_id: number
    tag?: string | null
  }

  export type songtagsUpdateInput = {
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    songdata?: songdataUpdateOneRequiredWithoutSongtagsNestedInput
  }

  export type songtagsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    song_id?: IntFieldUpdateOperationsInput | number
    tag?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type songtagsCreateManyInput = {
    id?: number
    song_id: number
    tag?: string | null
  }

  export type songtagsUpdateManyMutationInput = {
    tag?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type songtagsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    song_id?: IntFieldUpdateOperationsInput | number
    tag?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type stylesCreateInput = {
    classname?: string | null
    tagname?: string | null
    attr?: string | null
    value?: string | null
    stylesheet?: string | null
  }

  export type stylesUncheckedCreateInput = {
    id?: number
    classname?: string | null
    tagname?: string | null
    attr?: string | null
    value?: string | null
    stylesheet?: string | null
  }

  export type stylesUpdateInput = {
    classname?: NullableStringFieldUpdateOperationsInput | string | null
    tagname?: NullableStringFieldUpdateOperationsInput | string | null
    attr?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    stylesheet?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type stylesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    classname?: NullableStringFieldUpdateOperationsInput | string | null
    tagname?: NullableStringFieldUpdateOperationsInput | string | null
    attr?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    stylesheet?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type stylesCreateManyInput = {
    id?: number
    classname?: string | null
    tagname?: string | null
    attr?: string | null
    value?: string | null
    stylesheet?: string | null
  }

  export type stylesUpdateManyMutationInput = {
    classname?: NullableStringFieldUpdateOperationsInput | string | null
    tagname?: NullableStringFieldUpdateOperationsInput | string | null
    attr?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    stylesheet?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type stylesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    classname?: NullableStringFieldUpdateOperationsInput | string | null
    tagname?: NullableStringFieldUpdateOperationsInput | string | null
    attr?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    stylesheet?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type usersCreateInput = {
    username?: string | null
    password?: string | null
  }

  export type usersUncheckedCreateInput = {
    id?: number
    username?: string | null
    password?: string | null
  }

  export type usersUpdateInput = {
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type usersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type usersCreateManyInput = {
    id?: number
    username?: string | null
    password?: string | null
  }

  export type usersUpdateManyMutationInput = {
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type usersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type versedataCreateInput = {
    verse?: string | null
    versetype?: string | null
    songdata: songdataCreateNestedOneWithoutVersedataInput
  }

  export type versedataUncheckedCreateInput = {
    id?: number
    song_id: number
    verse?: string | null
    versetype?: string | null
  }

  export type versedataUpdateInput = {
    verse?: NullableStringFieldUpdateOperationsInput | string | null
    versetype?: NullableStringFieldUpdateOperationsInput | string | null
    songdata?: songdataUpdateOneRequiredWithoutVersedataNestedInput
  }

  export type versedataUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    song_id?: IntFieldUpdateOperationsInput | number
    verse?: NullableStringFieldUpdateOperationsInput | string | null
    versetype?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type versedataCreateManyInput = {
    id?: number
    song_id: number
    verse?: string | null
    versetype?: string | null
  }

  export type versedataUpdateManyMutationInput = {
    verse?: NullableStringFieldUpdateOperationsInput | string | null
    versetype?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type versedataUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    song_id?: IntFieldUpdateOperationsInput | number
    verse?: NullableStringFieldUpdateOperationsInput | string | null
    versetype?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type backgroundsCountOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    description?: SortOrder
  }

  export type backgroundsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type backgroundsMaxOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    description?: SortOrder
  }

  export type backgroundsMinOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    description?: SortOrder
  }

  export type backgroundsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type biblesegmentsCountOrderByAggregateInput = {
    id?: SortOrder
    start_book?: SortOrder
    start_chap?: SortOrder
    start_verse?: SortOrder
    end_book?: SortOrder
    end_chap?: SortOrder
    end_verse?: SortOrder
  }

  export type biblesegmentsAvgOrderByAggregateInput = {
    id?: SortOrder
    start_chap?: SortOrder
    start_verse?: SortOrder
    end_chap?: SortOrder
    end_verse?: SortOrder
  }

  export type biblesegmentsMaxOrderByAggregateInput = {
    id?: SortOrder
    start_book?: SortOrder
    start_chap?: SortOrder
    start_verse?: SortOrder
    end_book?: SortOrder
    end_chap?: SortOrder
    end_verse?: SortOrder
  }

  export type biblesegmentsMinOrderByAggregateInput = {
    id?: SortOrder
    start_book?: SortOrder
    start_chap?: SortOrder
    start_verse?: SortOrder
    end_book?: SortOrder
    end_chap?: SortOrder
    end_verse?: SortOrder
  }

  export type biblesegmentsSumOrderByAggregateInput = {
    id?: SortOrder
    start_chap?: SortOrder
    start_verse?: SortOrder
    end_chap?: SortOrder
    end_verse?: SortOrder
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type DecimalNullableFilter = {
    equals?: Decimal | DecimalJsLike | number | string | null
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | Decimal | DecimalJsLike | number | string | null
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | Decimal | DecimalJsLike | number | string | null
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
  }

  export type Offering_goalsRelationFilter = {
    is?: offering_goalsWhereInput | null
    isNot?: offering_goalsWhereInput | null
  }

  export type ServicesRelationFilter = {
    is?: servicesWhereInput | null
    isNot?: servicesWhereInput | null
  }

  export type collected_offeringsCountOrderByAggregateInput = {
    id?: SortOrder
    target_id?: SortOrder
    service_id?: SortOrder
    amount?: SortOrder
  }

  export type collected_offeringsAvgOrderByAggregateInput = {
    id?: SortOrder
    target_id?: SortOrder
    service_id?: SortOrder
    amount?: SortOrder
  }

  export type collected_offeringsMaxOrderByAggregateInput = {
    id?: SortOrder
    target_id?: SortOrder
    service_id?: SortOrder
    amount?: SortOrder
  }

  export type collected_offeringsMinOrderByAggregateInput = {
    id?: SortOrder
    target_id?: SortOrder
    service_id?: SortOrder
    amount?: SortOrder
  }

  export type collected_offeringsSumOrderByAggregateInput = {
    id?: SortOrder
    target_id?: SortOrder
    service_id?: SortOrder
    amount?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter = {
    equals?: Decimal | DecimalJsLike | number | string | null
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | Decimal | DecimalJsLike | number | string | null
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | Decimal | DecimalJsLike | number | string | null
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter
    _avg?: NestedDecimalNullableFilter
    _sum?: NestedDecimalNullableFilter
    _min?: NestedDecimalNullableFilter
    _max?: NestedDecimalNullableFilter
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type commentsCountOrderByAggregateInput = {
    id?: SortOrder
    service_id?: SortOrder
    reply_to?: SortOrder
    content?: SortOrder
    commentator?: SortOrder
    theme?: SortOrder
    comment_time?: SortOrder
  }

  export type commentsAvgOrderByAggregateInput = {
    id?: SortOrder
    service_id?: SortOrder
    reply_to?: SortOrder
  }

  export type commentsMaxOrderByAggregateInput = {
    id?: SortOrder
    service_id?: SortOrder
    reply_to?: SortOrder
    content?: SortOrder
    commentator?: SortOrder
    theme?: SortOrder
    comment_time?: SortOrder
  }

  export type commentsMinOrderByAggregateInput = {
    id?: SortOrder
    service_id?: SortOrder
    reply_to?: SortOrder
    content?: SortOrder
    commentator?: SortOrder
    theme?: SortOrder
    comment_time?: SortOrder
  }

  export type commentsSumOrderByAggregateInput = {
    id?: SortOrder
    service_id?: SortOrder
    reply_to?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type BoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type eventsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    place_and_time?: SortOrder
    description?: SortOrder
    event_date?: SortOrder
    has_songs?: SortOrder
  }

  export type eventsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type eventsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    place_and_time?: SortOrder
    description?: SortOrder
    event_date?: SortOrder
    has_songs?: SortOrder
  }

  export type eventsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    place_and_time?: SortOrder
    description?: SortOrder
    event_date?: SortOrder
    has_songs?: SortOrder
  }

  export type eventsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
  }

  export type headersCountOrderByAggregateInput = {
    id?: SortOrder
    template_name?: SortOrder
    maintext?: SortOrder
    imgname?: SortOrder
    imgposition?: SortOrder
    is_aside?: SortOrder
  }

  export type headersAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type headersMaxOrderByAggregateInput = {
    id?: SortOrder
    template_name?: SortOrder
    maintext?: SortOrder
    imgname?: SortOrder
    imgposition?: SortOrder
    is_aside?: SortOrder
  }

  export type headersMinOrderByAggregateInput = {
    id?: SortOrder
    template_name?: SortOrder
    maintext?: SortOrder
    imgname?: SortOrder
    imgposition?: SortOrder
    is_aside?: SortOrder
  }

  export type headersSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type infosCountOrderByAggregateInput = {
    id?: SortOrder
    service_id?: SortOrder
    slot_name?: SortOrder
    content_id?: SortOrder
    addedclass?: SortOrder
    header_id?: SortOrder
  }

  export type infosAvgOrderByAggregateInput = {
    id?: SortOrder
    service_id?: SortOrder
    content_id?: SortOrder
    header_id?: SortOrder
  }

  export type infosMaxOrderByAggregateInput = {
    id?: SortOrder
    service_id?: SortOrder
    slot_name?: SortOrder
    content_id?: SortOrder
    addedclass?: SortOrder
    header_id?: SortOrder
  }

  export type infosMinOrderByAggregateInput = {
    id?: SortOrder
    service_id?: SortOrder
    slot_name?: SortOrder
    content_id?: SortOrder
    addedclass?: SortOrder
    header_id?: SortOrder
  }

  export type infosSumOrderByAggregateInput = {
    id?: SortOrder
    service_id?: SortOrder
    content_id?: SortOrder
    header_id?: SortOrder
  }

  export type infosegmentsCountOrderByAggregateInput = {
    id?: SortOrder
    maintext?: SortOrder
    header?: SortOrder
    genheader?: SortOrder
    subgenheader?: SortOrder
    imgname?: SortOrder
    imgposition?: SortOrder
  }

  export type infosegmentsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type infosegmentsMaxOrderByAggregateInput = {
    id?: SortOrder
    maintext?: SortOrder
    header?: SortOrder
    genheader?: SortOrder
    subgenheader?: SortOrder
    imgname?: SortOrder
    imgposition?: SortOrder
  }

  export type infosegmentsMinOrderByAggregateInput = {
    id?: SortOrder
    maintext?: SortOrder
    header?: SortOrder
    genheader?: SortOrder
    subgenheader?: SortOrder
    imgname?: SortOrder
    imgposition?: SortOrder
  }

  export type infosegmentsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type liturgicalsegmentsCountOrderByAggregateInput = {
    id?: SortOrder
    text_title?: SortOrder
    use_as_header?: SortOrder
  }

  export type liturgicalsegmentsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type liturgicalsegmentsMaxOrderByAggregateInput = {
    id?: SortOrder
    text_title?: SortOrder
    use_as_header?: SortOrder
  }

  export type liturgicalsegmentsMinOrderByAggregateInput = {
    id?: SortOrder
    text_title?: SortOrder
    use_as_header?: SortOrder
  }

  export type liturgicalsegmentsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type LtextversedataListRelationFilter = {
    every?: ltextversedataWhereInput
    some?: ltextversedataWhereInput
    none?: ltextversedataWhereInput
  }

  export type ltextversedataOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ltextdataCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
  }

  export type ltextdataAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ltextdataMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
  }

  export type ltextdataMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
  }

  export type ltextdataSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type LtextdataRelationFilter = {
    is?: ltextdataWhereInput | null
    isNot?: ltextdataWhereInput | null
  }

  export type ltextversedataCountOrderByAggregateInput = {
    id?: SortOrder
    ltext_id?: SortOrder
    verse?: SortOrder
  }

  export type ltextversedataAvgOrderByAggregateInput = {
    id?: SortOrder
    ltext_id?: SortOrder
  }

  export type ltextversedataMaxOrderByAggregateInput = {
    id?: SortOrder
    ltext_id?: SortOrder
    verse?: SortOrder
  }

  export type ltextversedataMinOrderByAggregateInput = {
    id?: SortOrder
    ltext_id?: SortOrder
    verse?: SortOrder
  }

  export type ltextversedataSumOrderByAggregateInput = {
    id?: SortOrder
    ltext_id?: SortOrder
  }

  export type Collected_offeringsListRelationFilter = {
    every?: collected_offeringsWhereInput
    some?: collected_offeringsWhereInput
    none?: collected_offeringsWhereInput
  }

  export type Offering_targetsRelationFilter = {
    is?: offering_targetsWhereInput | null
    isNot?: offering_targetsWhereInput | null
  }

  export type collected_offeringsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type offering_goalsCountOrderByAggregateInput = {
    id?: SortOrder
    target_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    is_default?: SortOrder
  }

  export type offering_goalsAvgOrderByAggregateInput = {
    id?: SortOrder
    target_id?: SortOrder
    amount?: SortOrder
  }

  export type offering_goalsMaxOrderByAggregateInput = {
    id?: SortOrder
    target_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    is_default?: SortOrder
  }

  export type offering_goalsMinOrderByAggregateInput = {
    id?: SortOrder
    target_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    is_default?: SortOrder
  }

  export type offering_goalsSumOrderByAggregateInput = {
    id?: SortOrder
    target_id?: SortOrder
    amount?: SortOrder
  }

  export type Offering_goalsListRelationFilter = {
    every?: offering_goalsWhereInput
    some?: offering_goalsWhereInput
    none?: offering_goalsWhereInput
  }

  export type offering_goalsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type offering_targetsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type offering_targetsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type offering_targetsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type offering_targetsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type offering_targetsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Presentation_structureRelationFilter = {
    is?: presentation_structureWhereInput | null
    isNot?: presentation_structureWhereInput | null
  }

  export type presentation_contentCountOrderByAggregateInput = {
    id?: SortOrder
    slot_id?: SortOrder
    content_type?: SortOrder
    new_slide?: SortOrder
    content?: SortOrder
  }

  export type presentation_contentAvgOrderByAggregateInput = {
    id?: SortOrder
    slot_id?: SortOrder
  }

  export type presentation_contentMaxOrderByAggregateInput = {
    id?: SortOrder
    slot_id?: SortOrder
    content_type?: SortOrder
    new_slide?: SortOrder
    content?: SortOrder
  }

  export type presentation_contentMinOrderByAggregateInput = {
    id?: SortOrder
    slot_id?: SortOrder
    content_type?: SortOrder
    new_slide?: SortOrder
    content?: SortOrder
  }

  export type presentation_contentSumOrderByAggregateInput = {
    id?: SortOrder
    slot_id?: SortOrder
  }

  export type Presentation_contentListRelationFilter = {
    every?: presentation_contentWhereInput
    some?: presentation_contentWhereInput
    none?: presentation_contentWhereInput
  }

  export type presentation_contentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type presentation_structureCountOrderByAggregateInput = {
    id?: SortOrder
    service_id?: SortOrder
    slot_name?: SortOrder
    slot_number?: SortOrder
    slot_type?: SortOrder
    id_in_type_table?: SortOrder
    addedclass?: SortOrder
    header_id?: SortOrder
    content_id?: SortOrder
    instruction?: SortOrder
  }

  export type presentation_structureAvgOrderByAggregateInput = {
    id?: SortOrder
    service_id?: SortOrder
    slot_number?: SortOrder
    header_id?: SortOrder
    content_id?: SortOrder
  }

  export type presentation_structureMaxOrderByAggregateInput = {
    id?: SortOrder
    service_id?: SortOrder
    slot_name?: SortOrder
    slot_number?: SortOrder
    slot_type?: SortOrder
    id_in_type_table?: SortOrder
    addedclass?: SortOrder
    header_id?: SortOrder
    content_id?: SortOrder
    instruction?: SortOrder
  }

  export type presentation_structureMinOrderByAggregateInput = {
    id?: SortOrder
    service_id?: SortOrder
    slot_name?: SortOrder
    slot_number?: SortOrder
    slot_type?: SortOrder
    id_in_type_table?: SortOrder
    addedclass?: SortOrder
    header_id?: SortOrder
    content_id?: SortOrder
    instruction?: SortOrder
  }

  export type presentation_structureSumOrderByAggregateInput = {
    id?: SortOrder
    service_id?: SortOrder
    slot_number?: SortOrder
    header_id?: SortOrder
    content_id?: SortOrder
  }

  export type responsibilitiesCountOrderByAggregateInput = {
    id?: SortOrder
    service_id?: SortOrder
    responsibility?: SortOrder
    responsible?: SortOrder
  }

  export type responsibilitiesAvgOrderByAggregateInput = {
    id?: SortOrder
    service_id?: SortOrder
  }

  export type responsibilitiesMaxOrderByAggregateInput = {
    id?: SortOrder
    service_id?: SortOrder
    responsibility?: SortOrder
    responsible?: SortOrder
  }

  export type responsibilitiesMinOrderByAggregateInput = {
    id?: SortOrder
    service_id?: SortOrder
    responsibility?: SortOrder
    responsible?: SortOrder
  }

  export type responsibilitiesSumOrderByAggregateInput = {
    id?: SortOrder
    service_id?: SortOrder
  }

  export type responsibilities_metaCountOrderByAggregateInput = {
    id?: SortOrder
    responsibility?: SortOrder
    description?: SortOrder
  }

  export type responsibilities_metaAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type responsibilities_metaMaxOrderByAggregateInput = {
    id?: SortOrder
    responsibility?: SortOrder
    description?: SortOrder
  }

  export type responsibilities_metaMinOrderByAggregateInput = {
    id?: SortOrder
    responsibility?: SortOrder
    description?: SortOrder
  }

  export type responsibilities_metaSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type seasonsCountOrderByAggregateInput = {
    id?: SortOrder
    startdate?: SortOrder
    enddate?: SortOrder
    theme?: SortOrder
    comments?: SortOrder
    name?: SortOrder
  }

  export type seasonsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type seasonsMaxOrderByAggregateInput = {
    id?: SortOrder
    startdate?: SortOrder
    enddate?: SortOrder
    theme?: SortOrder
    comments?: SortOrder
    name?: SortOrder
  }

  export type seasonsMinOrderByAggregateInput = {
    id?: SortOrder
    startdate?: SortOrder
    enddate?: SortOrder
    theme?: SortOrder
    comments?: SortOrder
    name?: SortOrder
  }

  export type seasonsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type service_specific_presentation_structureCountOrderByAggregateInput = {
    id?: SortOrder
    service_id?: SortOrder
    slot_name?: SortOrder
    slot_number?: SortOrder
    slot_type?: SortOrder
    id_in_type_table?: SortOrder
    content_id?: SortOrder
    addedclass?: SortOrder
    header_id?: SortOrder
    instruction?: SortOrder
  }

  export type service_specific_presentation_structureAvgOrderByAggregateInput = {
    id?: SortOrder
    service_id?: SortOrder
    slot_number?: SortOrder
    content_id?: SortOrder
    header_id?: SortOrder
  }

  export type service_specific_presentation_structureMaxOrderByAggregateInput = {
    id?: SortOrder
    service_id?: SortOrder
    slot_name?: SortOrder
    slot_number?: SortOrder
    slot_type?: SortOrder
    id_in_type_table?: SortOrder
    content_id?: SortOrder
    addedclass?: SortOrder
    header_id?: SortOrder
    instruction?: SortOrder
  }

  export type service_specific_presentation_structureMinOrderByAggregateInput = {
    id?: SortOrder
    service_id?: SortOrder
    slot_name?: SortOrder
    slot_number?: SortOrder
    slot_type?: SortOrder
    id_in_type_table?: SortOrder
    content_id?: SortOrder
    addedclass?: SortOrder
    header_id?: SortOrder
    instruction?: SortOrder
  }

  export type service_specific_presentation_structureSumOrderByAggregateInput = {
    id?: SortOrder
    service_id?: SortOrder
    slot_number?: SortOrder
    content_id?: SortOrder
    header_id?: SortOrder
  }

  export type CommentsListRelationFilter = {
    every?: commentsWhereInput
    some?: commentsWhereInput
    none?: commentsWhereInput
  }

  export type ResponsibilitiesListRelationFilter = {
    every?: responsibilitiesWhereInput
    some?: responsibilitiesWhereInput
    none?: responsibilitiesWhereInput
  }

  export type ServicesongsListRelationFilter = {
    every?: servicesongsWhereInput
    some?: servicesongsWhereInput
    none?: servicesongsWhereInput
  }

  export type ServiceversesListRelationFilter = {
    every?: serviceversesWhereInput
    some?: serviceversesWhereInput
    none?: serviceversesWhereInput
  }

  export type commentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type responsibilitiesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type servicesongsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type serviceversesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type servicesCountOrderByAggregateInput = {
    id?: SortOrder
    servicedate?: SortOrder
    theme?: SortOrder
  }

  export type servicesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type servicesMaxOrderByAggregateInput = {
    id?: SortOrder
    servicedate?: SortOrder
    theme?: SortOrder
  }

  export type servicesMinOrderByAggregateInput = {
    id?: SortOrder
    servicedate?: SortOrder
    theme?: SortOrder
  }

  export type servicesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BigIntFilter = {
    equals?: bigint | number
    in?: Enumerable<bigint> | Enumerable<number> | bigint | number
    notIn?: Enumerable<bigint> | Enumerable<number> | bigint | number
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntFilter | bigint | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type servicesongsCountOrderByAggregateInput = {
    id?: SortOrder
    service_id?: SortOrder
    song_title?: SortOrder
    verses?: SortOrder
    is_instrumental?: SortOrder
    song_id?: SortOrder
    songtype?: SortOrder
    position?: SortOrder
  }

  export type servicesongsAvgOrderByAggregateInput = {
    id?: SortOrder
    service_id?: SortOrder
    song_id?: SortOrder
    position?: SortOrder
  }

  export type servicesongsMaxOrderByAggregateInput = {
    id?: SortOrder
    service_id?: SortOrder
    song_title?: SortOrder
    verses?: SortOrder
    is_instrumental?: SortOrder
    song_id?: SortOrder
    songtype?: SortOrder
    position?: SortOrder
  }

  export type servicesongsMinOrderByAggregateInput = {
    id?: SortOrder
    service_id?: SortOrder
    song_title?: SortOrder
    verses?: SortOrder
    is_instrumental?: SortOrder
    song_id?: SortOrder
    songtype?: SortOrder
    position?: SortOrder
  }

  export type servicesongsSumOrderByAggregateInput = {
    id?: SortOrder
    service_id?: SortOrder
    song_id?: SortOrder
    position?: SortOrder
  }

  export type BigIntWithAggregatesFilter = {
    equals?: bigint | number
    in?: Enumerable<bigint> | Enumerable<number> | bigint | number
    notIn?: Enumerable<bigint> | Enumerable<number> | bigint | number
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntWithAggregatesFilter | bigint | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedBigIntFilter
    _min?: NestedBigIntFilter
    _max?: NestedBigIntFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type serviceversesCountOrderByAggregateInput = {
    id?: SortOrder
    service_id?: SortOrder
    segment_name?: SortOrder
    testament?: SortOrder
    startbook?: SortOrder
    endbook?: SortOrder
    startchapter?: SortOrder
    endchapter?: SortOrder
    startverse?: SortOrder
    endverse?: SortOrder
  }

  export type serviceversesAvgOrderByAggregateInput = {
    id?: SortOrder
    service_id?: SortOrder
    startchapter?: SortOrder
    endchapter?: SortOrder
    startverse?: SortOrder
    endverse?: SortOrder
  }

  export type serviceversesMaxOrderByAggregateInput = {
    id?: SortOrder
    service_id?: SortOrder
    segment_name?: SortOrder
    testament?: SortOrder
    startbook?: SortOrder
    endbook?: SortOrder
    startchapter?: SortOrder
    endchapter?: SortOrder
    startverse?: SortOrder
    endverse?: SortOrder
  }

  export type serviceversesMinOrderByAggregateInput = {
    id?: SortOrder
    service_id?: SortOrder
    segment_name?: SortOrder
    testament?: SortOrder
    startbook?: SortOrder
    endbook?: SortOrder
    startchapter?: SortOrder
    endchapter?: SortOrder
    startverse?: SortOrder
    endverse?: SortOrder
  }

  export type serviceversesSumOrderByAggregateInput = {
    id?: SortOrder
    service_id?: SortOrder
    startchapter?: SortOrder
    endchapter?: SortOrder
    startverse?: SortOrder
    endverse?: SortOrder
  }

  export type smallgroupsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    resp_name?: SortOrder
    day?: SortOrder
    time_and_place?: SortOrder
    is_active?: SortOrder
  }

  export type smallgroupsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type smallgroupsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    resp_name?: SortOrder
    day?: SortOrder
    time_and_place?: SortOrder
    is_active?: SortOrder
  }

  export type smallgroupsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    resp_name?: SortOrder
    day?: SortOrder
    time_and_place?: SortOrder
    is_active?: SortOrder
  }

  export type smallgroupsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SongtagsListRelationFilter = {
    every?: songtagsWhereInput
    some?: songtagsWhereInput
    none?: songtagsWhereInput
  }

  export type VersedataListRelationFilter = {
    every?: versedataWhereInput
    some?: versedataWhereInput
    none?: versedataWhereInput
  }

  export type songtagsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type versedataOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type songdataCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    composer?: SortOrder
    lyrics?: SortOrder
    version_description?: SortOrder
  }

  export type songdataAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type songdataMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    composer?: SortOrder
    lyrics?: SortOrder
    version_description?: SortOrder
  }

  export type songdataMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    composer?: SortOrder
    lyrics?: SortOrder
    version_description?: SortOrder
  }

  export type songdataSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type songsegmentsCountOrderByAggregateInput = {
    id?: SortOrder
    songdescription?: SortOrder
    restrictedto?: SortOrder
    singlename?: SortOrder
    is_multi?: SortOrder
    segment_name_is_title?: SortOrder
  }

  export type songsegmentsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type songsegmentsMaxOrderByAggregateInput = {
    id?: SortOrder
    songdescription?: SortOrder
    restrictedto?: SortOrder
    singlename?: SortOrder
    is_multi?: SortOrder
    segment_name_is_title?: SortOrder
  }

  export type songsegmentsMinOrderByAggregateInput = {
    id?: SortOrder
    songdescription?: SortOrder
    restrictedto?: SortOrder
    singlename?: SortOrder
    is_multi?: SortOrder
    segment_name_is_title?: SortOrder
  }

  export type songsegmentsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SongdataRelationFilter = {
    is?: songdataWhereInput | null
    isNot?: songdataWhereInput | null
  }

  export type songtagsCountOrderByAggregateInput = {
    id?: SortOrder
    song_id?: SortOrder
    tag?: SortOrder
  }

  export type songtagsAvgOrderByAggregateInput = {
    id?: SortOrder
    song_id?: SortOrder
  }

  export type songtagsMaxOrderByAggregateInput = {
    id?: SortOrder
    song_id?: SortOrder
    tag?: SortOrder
  }

  export type songtagsMinOrderByAggregateInput = {
    id?: SortOrder
    song_id?: SortOrder
    tag?: SortOrder
  }

  export type songtagsSumOrderByAggregateInput = {
    id?: SortOrder
    song_id?: SortOrder
  }

  export type stylesCountOrderByAggregateInput = {
    id?: SortOrder
    classname?: SortOrder
    tagname?: SortOrder
    attr?: SortOrder
    value?: SortOrder
    stylesheet?: SortOrder
  }

  export type stylesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type stylesMaxOrderByAggregateInput = {
    id?: SortOrder
    classname?: SortOrder
    tagname?: SortOrder
    attr?: SortOrder
    value?: SortOrder
    stylesheet?: SortOrder
  }

  export type stylesMinOrderByAggregateInput = {
    id?: SortOrder
    classname?: SortOrder
    tagname?: SortOrder
    attr?: SortOrder
    value?: SortOrder
    stylesheet?: SortOrder
  }

  export type stylesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type usersCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
  }

  export type usersAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
  }

  export type usersSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type versedataCountOrderByAggregateInput = {
    id?: SortOrder
    song_id?: SortOrder
    verse?: SortOrder
    versetype?: SortOrder
  }

  export type versedataAvgOrderByAggregateInput = {
    id?: SortOrder
    song_id?: SortOrder
  }

  export type versedataMaxOrderByAggregateInput = {
    id?: SortOrder
    song_id?: SortOrder
    verse?: SortOrder
    versetype?: SortOrder
  }

  export type versedataMinOrderByAggregateInput = {
    id?: SortOrder
    song_id?: SortOrder
    verse?: SortOrder
    versetype?: SortOrder
  }

  export type versedataSumOrderByAggregateInput = {
    id?: SortOrder
    song_id?: SortOrder
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type offering_goalsCreateNestedOneWithoutCollected_offeringsInput = {
    create?: XOR<offering_goalsCreateWithoutCollected_offeringsInput, offering_goalsUncheckedCreateWithoutCollected_offeringsInput>
    connectOrCreate?: offering_goalsCreateOrConnectWithoutCollected_offeringsInput
    connect?: offering_goalsWhereUniqueInput
  }

  export type servicesCreateNestedOneWithoutCollected_offeringsInput = {
    create?: XOR<servicesCreateWithoutCollected_offeringsInput, servicesUncheckedCreateWithoutCollected_offeringsInput>
    connectOrCreate?: servicesCreateOrConnectWithoutCollected_offeringsInput
    connect?: servicesWhereUniqueInput
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type offering_goalsUpdateOneRequiredWithoutCollected_offeringsNestedInput = {
    create?: XOR<offering_goalsCreateWithoutCollected_offeringsInput, offering_goalsUncheckedCreateWithoutCollected_offeringsInput>
    connectOrCreate?: offering_goalsCreateOrConnectWithoutCollected_offeringsInput
    upsert?: offering_goalsUpsertWithoutCollected_offeringsInput
    connect?: offering_goalsWhereUniqueInput
    update?: XOR<offering_goalsUpdateWithoutCollected_offeringsInput, offering_goalsUncheckedUpdateWithoutCollected_offeringsInput>
  }

  export type servicesUpdateOneRequiredWithoutCollected_offeringsNestedInput = {
    create?: XOR<servicesCreateWithoutCollected_offeringsInput, servicesUncheckedCreateWithoutCollected_offeringsInput>
    connectOrCreate?: servicesCreateOrConnectWithoutCollected_offeringsInput
    upsert?: servicesUpsertWithoutCollected_offeringsInput
    connect?: servicesWhereUniqueInput
    update?: XOR<servicesUpdateWithoutCollected_offeringsInput, servicesUncheckedUpdateWithoutCollected_offeringsInput>
  }

  export type servicesCreateNestedOneWithoutCommentsInput = {
    create?: XOR<servicesCreateWithoutCommentsInput, servicesUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: servicesCreateOrConnectWithoutCommentsInput
    connect?: servicesWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type servicesUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<servicesCreateWithoutCommentsInput, servicesUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: servicesCreateOrConnectWithoutCommentsInput
    upsert?: servicesUpsertWithoutCommentsInput
    connect?: servicesWhereUniqueInput
    update?: XOR<servicesUpdateWithoutCommentsInput, servicesUncheckedUpdateWithoutCommentsInput>
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type ltextversedataCreateNestedManyWithoutLtextdataInput = {
    create?: XOR<Enumerable<ltextversedataCreateWithoutLtextdataInput>, Enumerable<ltextversedataUncheckedCreateWithoutLtextdataInput>>
    connectOrCreate?: Enumerable<ltextversedataCreateOrConnectWithoutLtextdataInput>
    createMany?: ltextversedataCreateManyLtextdataInputEnvelope
    connect?: Enumerable<ltextversedataWhereUniqueInput>
  }

  export type ltextversedataUncheckedCreateNestedManyWithoutLtextdataInput = {
    create?: XOR<Enumerable<ltextversedataCreateWithoutLtextdataInput>, Enumerable<ltextversedataUncheckedCreateWithoutLtextdataInput>>
    connectOrCreate?: Enumerable<ltextversedataCreateOrConnectWithoutLtextdataInput>
    createMany?: ltextversedataCreateManyLtextdataInputEnvelope
    connect?: Enumerable<ltextversedataWhereUniqueInput>
  }

  export type ltextversedataUpdateManyWithoutLtextdataNestedInput = {
    create?: XOR<Enumerable<ltextversedataCreateWithoutLtextdataInput>, Enumerable<ltextversedataUncheckedCreateWithoutLtextdataInput>>
    connectOrCreate?: Enumerable<ltextversedataCreateOrConnectWithoutLtextdataInput>
    upsert?: Enumerable<ltextversedataUpsertWithWhereUniqueWithoutLtextdataInput>
    createMany?: ltextversedataCreateManyLtextdataInputEnvelope
    set?: Enumerable<ltextversedataWhereUniqueInput>
    disconnect?: Enumerable<ltextversedataWhereUniqueInput>
    delete?: Enumerable<ltextversedataWhereUniqueInput>
    connect?: Enumerable<ltextversedataWhereUniqueInput>
    update?: Enumerable<ltextversedataUpdateWithWhereUniqueWithoutLtextdataInput>
    updateMany?: Enumerable<ltextversedataUpdateManyWithWhereWithoutLtextdataInput>
    deleteMany?: Enumerable<ltextversedataScalarWhereInput>
  }

  export type ltextversedataUncheckedUpdateManyWithoutLtextdataNestedInput = {
    create?: XOR<Enumerable<ltextversedataCreateWithoutLtextdataInput>, Enumerable<ltextversedataUncheckedCreateWithoutLtextdataInput>>
    connectOrCreate?: Enumerable<ltextversedataCreateOrConnectWithoutLtextdataInput>
    upsert?: Enumerable<ltextversedataUpsertWithWhereUniqueWithoutLtextdataInput>
    createMany?: ltextversedataCreateManyLtextdataInputEnvelope
    set?: Enumerable<ltextversedataWhereUniqueInput>
    disconnect?: Enumerable<ltextversedataWhereUniqueInput>
    delete?: Enumerable<ltextversedataWhereUniqueInput>
    connect?: Enumerable<ltextversedataWhereUniqueInput>
    update?: Enumerable<ltextversedataUpdateWithWhereUniqueWithoutLtextdataInput>
    updateMany?: Enumerable<ltextversedataUpdateManyWithWhereWithoutLtextdataInput>
    deleteMany?: Enumerable<ltextversedataScalarWhereInput>
  }

  export type ltextdataCreateNestedOneWithoutLtextversedataInput = {
    create?: XOR<ltextdataCreateWithoutLtextversedataInput, ltextdataUncheckedCreateWithoutLtextversedataInput>
    connectOrCreate?: ltextdataCreateOrConnectWithoutLtextversedataInput
    connect?: ltextdataWhereUniqueInput
  }

  export type ltextdataUpdateOneRequiredWithoutLtextversedataNestedInput = {
    create?: XOR<ltextdataCreateWithoutLtextversedataInput, ltextdataUncheckedCreateWithoutLtextversedataInput>
    connectOrCreate?: ltextdataCreateOrConnectWithoutLtextversedataInput
    upsert?: ltextdataUpsertWithoutLtextversedataInput
    connect?: ltextdataWhereUniqueInput
    update?: XOR<ltextdataUpdateWithoutLtextversedataInput, ltextdataUncheckedUpdateWithoutLtextversedataInput>
  }

  export type collected_offeringsCreateNestedManyWithoutOffering_goalsInput = {
    create?: XOR<Enumerable<collected_offeringsCreateWithoutOffering_goalsInput>, Enumerable<collected_offeringsUncheckedCreateWithoutOffering_goalsInput>>
    connectOrCreate?: Enumerable<collected_offeringsCreateOrConnectWithoutOffering_goalsInput>
    createMany?: collected_offeringsCreateManyOffering_goalsInputEnvelope
    connect?: Enumerable<collected_offeringsWhereUniqueInput>
  }

  export type offering_targetsCreateNestedOneWithoutOffering_goalsInput = {
    create?: XOR<offering_targetsCreateWithoutOffering_goalsInput, offering_targetsUncheckedCreateWithoutOffering_goalsInput>
    connectOrCreate?: offering_targetsCreateOrConnectWithoutOffering_goalsInput
    connect?: offering_targetsWhereUniqueInput
  }

  export type collected_offeringsUncheckedCreateNestedManyWithoutOffering_goalsInput = {
    create?: XOR<Enumerable<collected_offeringsCreateWithoutOffering_goalsInput>, Enumerable<collected_offeringsUncheckedCreateWithoutOffering_goalsInput>>
    connectOrCreate?: Enumerable<collected_offeringsCreateOrConnectWithoutOffering_goalsInput>
    createMany?: collected_offeringsCreateManyOffering_goalsInputEnvelope
    connect?: Enumerable<collected_offeringsWhereUniqueInput>
  }

  export type collected_offeringsUpdateManyWithoutOffering_goalsNestedInput = {
    create?: XOR<Enumerable<collected_offeringsCreateWithoutOffering_goalsInput>, Enumerable<collected_offeringsUncheckedCreateWithoutOffering_goalsInput>>
    connectOrCreate?: Enumerable<collected_offeringsCreateOrConnectWithoutOffering_goalsInput>
    upsert?: Enumerable<collected_offeringsUpsertWithWhereUniqueWithoutOffering_goalsInput>
    createMany?: collected_offeringsCreateManyOffering_goalsInputEnvelope
    set?: Enumerable<collected_offeringsWhereUniqueInput>
    disconnect?: Enumerable<collected_offeringsWhereUniqueInput>
    delete?: Enumerable<collected_offeringsWhereUniqueInput>
    connect?: Enumerable<collected_offeringsWhereUniqueInput>
    update?: Enumerable<collected_offeringsUpdateWithWhereUniqueWithoutOffering_goalsInput>
    updateMany?: Enumerable<collected_offeringsUpdateManyWithWhereWithoutOffering_goalsInput>
    deleteMany?: Enumerable<collected_offeringsScalarWhereInput>
  }

  export type offering_targetsUpdateOneRequiredWithoutOffering_goalsNestedInput = {
    create?: XOR<offering_targetsCreateWithoutOffering_goalsInput, offering_targetsUncheckedCreateWithoutOffering_goalsInput>
    connectOrCreate?: offering_targetsCreateOrConnectWithoutOffering_goalsInput
    upsert?: offering_targetsUpsertWithoutOffering_goalsInput
    connect?: offering_targetsWhereUniqueInput
    update?: XOR<offering_targetsUpdateWithoutOffering_goalsInput, offering_targetsUncheckedUpdateWithoutOffering_goalsInput>
  }

  export type collected_offeringsUncheckedUpdateManyWithoutOffering_goalsNestedInput = {
    create?: XOR<Enumerable<collected_offeringsCreateWithoutOffering_goalsInput>, Enumerable<collected_offeringsUncheckedCreateWithoutOffering_goalsInput>>
    connectOrCreate?: Enumerable<collected_offeringsCreateOrConnectWithoutOffering_goalsInput>
    upsert?: Enumerable<collected_offeringsUpsertWithWhereUniqueWithoutOffering_goalsInput>
    createMany?: collected_offeringsCreateManyOffering_goalsInputEnvelope
    set?: Enumerable<collected_offeringsWhereUniqueInput>
    disconnect?: Enumerable<collected_offeringsWhereUniqueInput>
    delete?: Enumerable<collected_offeringsWhereUniqueInput>
    connect?: Enumerable<collected_offeringsWhereUniqueInput>
    update?: Enumerable<collected_offeringsUpdateWithWhereUniqueWithoutOffering_goalsInput>
    updateMany?: Enumerable<collected_offeringsUpdateManyWithWhereWithoutOffering_goalsInput>
    deleteMany?: Enumerable<collected_offeringsScalarWhereInput>
  }

  export type offering_goalsCreateNestedManyWithoutOffering_targetsInput = {
    create?: XOR<Enumerable<offering_goalsCreateWithoutOffering_targetsInput>, Enumerable<offering_goalsUncheckedCreateWithoutOffering_targetsInput>>
    connectOrCreate?: Enumerable<offering_goalsCreateOrConnectWithoutOffering_targetsInput>
    createMany?: offering_goalsCreateManyOffering_targetsInputEnvelope
    connect?: Enumerable<offering_goalsWhereUniqueInput>
  }

  export type offering_goalsUncheckedCreateNestedManyWithoutOffering_targetsInput = {
    create?: XOR<Enumerable<offering_goalsCreateWithoutOffering_targetsInput>, Enumerable<offering_goalsUncheckedCreateWithoutOffering_targetsInput>>
    connectOrCreate?: Enumerable<offering_goalsCreateOrConnectWithoutOffering_targetsInput>
    createMany?: offering_goalsCreateManyOffering_targetsInputEnvelope
    connect?: Enumerable<offering_goalsWhereUniqueInput>
  }

  export type offering_goalsUpdateManyWithoutOffering_targetsNestedInput = {
    create?: XOR<Enumerable<offering_goalsCreateWithoutOffering_targetsInput>, Enumerable<offering_goalsUncheckedCreateWithoutOffering_targetsInput>>
    connectOrCreate?: Enumerable<offering_goalsCreateOrConnectWithoutOffering_targetsInput>
    upsert?: Enumerable<offering_goalsUpsertWithWhereUniqueWithoutOffering_targetsInput>
    createMany?: offering_goalsCreateManyOffering_targetsInputEnvelope
    set?: Enumerable<offering_goalsWhereUniqueInput>
    disconnect?: Enumerable<offering_goalsWhereUniqueInput>
    delete?: Enumerable<offering_goalsWhereUniqueInput>
    connect?: Enumerable<offering_goalsWhereUniqueInput>
    update?: Enumerable<offering_goalsUpdateWithWhereUniqueWithoutOffering_targetsInput>
    updateMany?: Enumerable<offering_goalsUpdateManyWithWhereWithoutOffering_targetsInput>
    deleteMany?: Enumerable<offering_goalsScalarWhereInput>
  }

  export type offering_goalsUncheckedUpdateManyWithoutOffering_targetsNestedInput = {
    create?: XOR<Enumerable<offering_goalsCreateWithoutOffering_targetsInput>, Enumerable<offering_goalsUncheckedCreateWithoutOffering_targetsInput>>
    connectOrCreate?: Enumerable<offering_goalsCreateOrConnectWithoutOffering_targetsInput>
    upsert?: Enumerable<offering_goalsUpsertWithWhereUniqueWithoutOffering_targetsInput>
    createMany?: offering_goalsCreateManyOffering_targetsInputEnvelope
    set?: Enumerable<offering_goalsWhereUniqueInput>
    disconnect?: Enumerable<offering_goalsWhereUniqueInput>
    delete?: Enumerable<offering_goalsWhereUniqueInput>
    connect?: Enumerable<offering_goalsWhereUniqueInput>
    update?: Enumerable<offering_goalsUpdateWithWhereUniqueWithoutOffering_targetsInput>
    updateMany?: Enumerable<offering_goalsUpdateManyWithWhereWithoutOffering_targetsInput>
    deleteMany?: Enumerable<offering_goalsScalarWhereInput>
  }

  export type presentation_structureCreateNestedOneWithoutPresentation_contentInput = {
    create?: XOR<presentation_structureCreateWithoutPresentation_contentInput, presentation_structureUncheckedCreateWithoutPresentation_contentInput>
    connectOrCreate?: presentation_structureCreateOrConnectWithoutPresentation_contentInput
    connect?: presentation_structureWhereUniqueInput
  }

  export type presentation_structureUpdateOneRequiredWithoutPresentation_contentNestedInput = {
    create?: XOR<presentation_structureCreateWithoutPresentation_contentInput, presentation_structureUncheckedCreateWithoutPresentation_contentInput>
    connectOrCreate?: presentation_structureCreateOrConnectWithoutPresentation_contentInput
    upsert?: presentation_structureUpsertWithoutPresentation_contentInput
    connect?: presentation_structureWhereUniqueInput
    update?: XOR<presentation_structureUpdateWithoutPresentation_contentInput, presentation_structureUncheckedUpdateWithoutPresentation_contentInput>
  }

  export type presentation_contentCreateNestedManyWithoutPresentation_structureInput = {
    create?: XOR<Enumerable<presentation_contentCreateWithoutPresentation_structureInput>, Enumerable<presentation_contentUncheckedCreateWithoutPresentation_structureInput>>
    connectOrCreate?: Enumerable<presentation_contentCreateOrConnectWithoutPresentation_structureInput>
    createMany?: presentation_contentCreateManyPresentation_structureInputEnvelope
    connect?: Enumerable<presentation_contentWhereUniqueInput>
  }

  export type presentation_contentUncheckedCreateNestedManyWithoutPresentation_structureInput = {
    create?: XOR<Enumerable<presentation_contentCreateWithoutPresentation_structureInput>, Enumerable<presentation_contentUncheckedCreateWithoutPresentation_structureInput>>
    connectOrCreate?: Enumerable<presentation_contentCreateOrConnectWithoutPresentation_structureInput>
    createMany?: presentation_contentCreateManyPresentation_structureInputEnvelope
    connect?: Enumerable<presentation_contentWhereUniqueInput>
  }

  export type presentation_contentUpdateManyWithoutPresentation_structureNestedInput = {
    create?: XOR<Enumerable<presentation_contentCreateWithoutPresentation_structureInput>, Enumerable<presentation_contentUncheckedCreateWithoutPresentation_structureInput>>
    connectOrCreate?: Enumerable<presentation_contentCreateOrConnectWithoutPresentation_structureInput>
    upsert?: Enumerable<presentation_contentUpsertWithWhereUniqueWithoutPresentation_structureInput>
    createMany?: presentation_contentCreateManyPresentation_structureInputEnvelope
    set?: Enumerable<presentation_contentWhereUniqueInput>
    disconnect?: Enumerable<presentation_contentWhereUniqueInput>
    delete?: Enumerable<presentation_contentWhereUniqueInput>
    connect?: Enumerable<presentation_contentWhereUniqueInput>
    update?: Enumerable<presentation_contentUpdateWithWhereUniqueWithoutPresentation_structureInput>
    updateMany?: Enumerable<presentation_contentUpdateManyWithWhereWithoutPresentation_structureInput>
    deleteMany?: Enumerable<presentation_contentScalarWhereInput>
  }

  export type presentation_contentUncheckedUpdateManyWithoutPresentation_structureNestedInput = {
    create?: XOR<Enumerable<presentation_contentCreateWithoutPresentation_structureInput>, Enumerable<presentation_contentUncheckedCreateWithoutPresentation_structureInput>>
    connectOrCreate?: Enumerable<presentation_contentCreateOrConnectWithoutPresentation_structureInput>
    upsert?: Enumerable<presentation_contentUpsertWithWhereUniqueWithoutPresentation_structureInput>
    createMany?: presentation_contentCreateManyPresentation_structureInputEnvelope
    set?: Enumerable<presentation_contentWhereUniqueInput>
    disconnect?: Enumerable<presentation_contentWhereUniqueInput>
    delete?: Enumerable<presentation_contentWhereUniqueInput>
    connect?: Enumerable<presentation_contentWhereUniqueInput>
    update?: Enumerable<presentation_contentUpdateWithWhereUniqueWithoutPresentation_structureInput>
    updateMany?: Enumerable<presentation_contentUpdateManyWithWhereWithoutPresentation_structureInput>
    deleteMany?: Enumerable<presentation_contentScalarWhereInput>
  }

  export type servicesCreateNestedOneWithoutResponsibilitiesInput = {
    create?: XOR<servicesCreateWithoutResponsibilitiesInput, servicesUncheckedCreateWithoutResponsibilitiesInput>
    connectOrCreate?: servicesCreateOrConnectWithoutResponsibilitiesInput
    connect?: servicesWhereUniqueInput
  }

  export type servicesUpdateOneRequiredWithoutResponsibilitiesNestedInput = {
    create?: XOR<servicesCreateWithoutResponsibilitiesInput, servicesUncheckedCreateWithoutResponsibilitiesInput>
    connectOrCreate?: servicesCreateOrConnectWithoutResponsibilitiesInput
    upsert?: servicesUpsertWithoutResponsibilitiesInput
    connect?: servicesWhereUniqueInput
    update?: XOR<servicesUpdateWithoutResponsibilitiesInput, servicesUncheckedUpdateWithoutResponsibilitiesInput>
  }

  export type collected_offeringsCreateNestedManyWithoutServicesInput = {
    create?: XOR<Enumerable<collected_offeringsCreateWithoutServicesInput>, Enumerable<collected_offeringsUncheckedCreateWithoutServicesInput>>
    connectOrCreate?: Enumerable<collected_offeringsCreateOrConnectWithoutServicesInput>
    createMany?: collected_offeringsCreateManyServicesInputEnvelope
    connect?: Enumerable<collected_offeringsWhereUniqueInput>
  }

  export type commentsCreateNestedManyWithoutServicesInput = {
    create?: XOR<Enumerable<commentsCreateWithoutServicesInput>, Enumerable<commentsUncheckedCreateWithoutServicesInput>>
    connectOrCreate?: Enumerable<commentsCreateOrConnectWithoutServicesInput>
    createMany?: commentsCreateManyServicesInputEnvelope
    connect?: Enumerable<commentsWhereUniqueInput>
  }

  export type responsibilitiesCreateNestedManyWithoutServicesInput = {
    create?: XOR<Enumerable<responsibilitiesCreateWithoutServicesInput>, Enumerable<responsibilitiesUncheckedCreateWithoutServicesInput>>
    connectOrCreate?: Enumerable<responsibilitiesCreateOrConnectWithoutServicesInput>
    createMany?: responsibilitiesCreateManyServicesInputEnvelope
    connect?: Enumerable<responsibilitiesWhereUniqueInput>
  }

  export type servicesongsCreateNestedManyWithoutServicesInput = {
    create?: XOR<Enumerable<servicesongsCreateWithoutServicesInput>, Enumerable<servicesongsUncheckedCreateWithoutServicesInput>>
    connectOrCreate?: Enumerable<servicesongsCreateOrConnectWithoutServicesInput>
    createMany?: servicesongsCreateManyServicesInputEnvelope
    connect?: Enumerable<servicesongsWhereUniqueInput>
  }

  export type serviceversesCreateNestedManyWithoutServicesInput = {
    create?: XOR<Enumerable<serviceversesCreateWithoutServicesInput>, Enumerable<serviceversesUncheckedCreateWithoutServicesInput>>
    connectOrCreate?: Enumerable<serviceversesCreateOrConnectWithoutServicesInput>
    createMany?: serviceversesCreateManyServicesInputEnvelope
    connect?: Enumerable<serviceversesWhereUniqueInput>
  }

  export type collected_offeringsUncheckedCreateNestedManyWithoutServicesInput = {
    create?: XOR<Enumerable<collected_offeringsCreateWithoutServicesInput>, Enumerable<collected_offeringsUncheckedCreateWithoutServicesInput>>
    connectOrCreate?: Enumerable<collected_offeringsCreateOrConnectWithoutServicesInput>
    createMany?: collected_offeringsCreateManyServicesInputEnvelope
    connect?: Enumerable<collected_offeringsWhereUniqueInput>
  }

  export type commentsUncheckedCreateNestedManyWithoutServicesInput = {
    create?: XOR<Enumerable<commentsCreateWithoutServicesInput>, Enumerable<commentsUncheckedCreateWithoutServicesInput>>
    connectOrCreate?: Enumerable<commentsCreateOrConnectWithoutServicesInput>
    createMany?: commentsCreateManyServicesInputEnvelope
    connect?: Enumerable<commentsWhereUniqueInput>
  }

  export type responsibilitiesUncheckedCreateNestedManyWithoutServicesInput = {
    create?: XOR<Enumerable<responsibilitiesCreateWithoutServicesInput>, Enumerable<responsibilitiesUncheckedCreateWithoutServicesInput>>
    connectOrCreate?: Enumerable<responsibilitiesCreateOrConnectWithoutServicesInput>
    createMany?: responsibilitiesCreateManyServicesInputEnvelope
    connect?: Enumerable<responsibilitiesWhereUniqueInput>
  }

  export type servicesongsUncheckedCreateNestedManyWithoutServicesInput = {
    create?: XOR<Enumerable<servicesongsCreateWithoutServicesInput>, Enumerable<servicesongsUncheckedCreateWithoutServicesInput>>
    connectOrCreate?: Enumerable<servicesongsCreateOrConnectWithoutServicesInput>
    createMany?: servicesongsCreateManyServicesInputEnvelope
    connect?: Enumerable<servicesongsWhereUniqueInput>
  }

  export type serviceversesUncheckedCreateNestedManyWithoutServicesInput = {
    create?: XOR<Enumerable<serviceversesCreateWithoutServicesInput>, Enumerable<serviceversesUncheckedCreateWithoutServicesInput>>
    connectOrCreate?: Enumerable<serviceversesCreateOrConnectWithoutServicesInput>
    createMany?: serviceversesCreateManyServicesInputEnvelope
    connect?: Enumerable<serviceversesWhereUniqueInput>
  }

  export type collected_offeringsUpdateManyWithoutServicesNestedInput = {
    create?: XOR<Enumerable<collected_offeringsCreateWithoutServicesInput>, Enumerable<collected_offeringsUncheckedCreateWithoutServicesInput>>
    connectOrCreate?: Enumerable<collected_offeringsCreateOrConnectWithoutServicesInput>
    upsert?: Enumerable<collected_offeringsUpsertWithWhereUniqueWithoutServicesInput>
    createMany?: collected_offeringsCreateManyServicesInputEnvelope
    set?: Enumerable<collected_offeringsWhereUniqueInput>
    disconnect?: Enumerable<collected_offeringsWhereUniqueInput>
    delete?: Enumerable<collected_offeringsWhereUniqueInput>
    connect?: Enumerable<collected_offeringsWhereUniqueInput>
    update?: Enumerable<collected_offeringsUpdateWithWhereUniqueWithoutServicesInput>
    updateMany?: Enumerable<collected_offeringsUpdateManyWithWhereWithoutServicesInput>
    deleteMany?: Enumerable<collected_offeringsScalarWhereInput>
  }

  export type commentsUpdateManyWithoutServicesNestedInput = {
    create?: XOR<Enumerable<commentsCreateWithoutServicesInput>, Enumerable<commentsUncheckedCreateWithoutServicesInput>>
    connectOrCreate?: Enumerable<commentsCreateOrConnectWithoutServicesInput>
    upsert?: Enumerable<commentsUpsertWithWhereUniqueWithoutServicesInput>
    createMany?: commentsCreateManyServicesInputEnvelope
    set?: Enumerable<commentsWhereUniqueInput>
    disconnect?: Enumerable<commentsWhereUniqueInput>
    delete?: Enumerable<commentsWhereUniqueInput>
    connect?: Enumerable<commentsWhereUniqueInput>
    update?: Enumerable<commentsUpdateWithWhereUniqueWithoutServicesInput>
    updateMany?: Enumerable<commentsUpdateManyWithWhereWithoutServicesInput>
    deleteMany?: Enumerable<commentsScalarWhereInput>
  }

  export type responsibilitiesUpdateManyWithoutServicesNestedInput = {
    create?: XOR<Enumerable<responsibilitiesCreateWithoutServicesInput>, Enumerable<responsibilitiesUncheckedCreateWithoutServicesInput>>
    connectOrCreate?: Enumerable<responsibilitiesCreateOrConnectWithoutServicesInput>
    upsert?: Enumerable<responsibilitiesUpsertWithWhereUniqueWithoutServicesInput>
    createMany?: responsibilitiesCreateManyServicesInputEnvelope
    set?: Enumerable<responsibilitiesWhereUniqueInput>
    disconnect?: Enumerable<responsibilitiesWhereUniqueInput>
    delete?: Enumerable<responsibilitiesWhereUniqueInput>
    connect?: Enumerable<responsibilitiesWhereUniqueInput>
    update?: Enumerable<responsibilitiesUpdateWithWhereUniqueWithoutServicesInput>
    updateMany?: Enumerable<responsibilitiesUpdateManyWithWhereWithoutServicesInput>
    deleteMany?: Enumerable<responsibilitiesScalarWhereInput>
  }

  export type servicesongsUpdateManyWithoutServicesNestedInput = {
    create?: XOR<Enumerable<servicesongsCreateWithoutServicesInput>, Enumerable<servicesongsUncheckedCreateWithoutServicesInput>>
    connectOrCreate?: Enumerable<servicesongsCreateOrConnectWithoutServicesInput>
    upsert?: Enumerable<servicesongsUpsertWithWhereUniqueWithoutServicesInput>
    createMany?: servicesongsCreateManyServicesInputEnvelope
    set?: Enumerable<servicesongsWhereUniqueInput>
    disconnect?: Enumerable<servicesongsWhereUniqueInput>
    delete?: Enumerable<servicesongsWhereUniqueInput>
    connect?: Enumerable<servicesongsWhereUniqueInput>
    update?: Enumerable<servicesongsUpdateWithWhereUniqueWithoutServicesInput>
    updateMany?: Enumerable<servicesongsUpdateManyWithWhereWithoutServicesInput>
    deleteMany?: Enumerable<servicesongsScalarWhereInput>
  }

  export type serviceversesUpdateManyWithoutServicesNestedInput = {
    create?: XOR<Enumerable<serviceversesCreateWithoutServicesInput>, Enumerable<serviceversesUncheckedCreateWithoutServicesInput>>
    connectOrCreate?: Enumerable<serviceversesCreateOrConnectWithoutServicesInput>
    upsert?: Enumerable<serviceversesUpsertWithWhereUniqueWithoutServicesInput>
    createMany?: serviceversesCreateManyServicesInputEnvelope
    set?: Enumerable<serviceversesWhereUniqueInput>
    disconnect?: Enumerable<serviceversesWhereUniqueInput>
    delete?: Enumerable<serviceversesWhereUniqueInput>
    connect?: Enumerable<serviceversesWhereUniqueInput>
    update?: Enumerable<serviceversesUpdateWithWhereUniqueWithoutServicesInput>
    updateMany?: Enumerable<serviceversesUpdateManyWithWhereWithoutServicesInput>
    deleteMany?: Enumerable<serviceversesScalarWhereInput>
  }

  export type collected_offeringsUncheckedUpdateManyWithoutServicesNestedInput = {
    create?: XOR<Enumerable<collected_offeringsCreateWithoutServicesInput>, Enumerable<collected_offeringsUncheckedCreateWithoutServicesInput>>
    connectOrCreate?: Enumerable<collected_offeringsCreateOrConnectWithoutServicesInput>
    upsert?: Enumerable<collected_offeringsUpsertWithWhereUniqueWithoutServicesInput>
    createMany?: collected_offeringsCreateManyServicesInputEnvelope
    set?: Enumerable<collected_offeringsWhereUniqueInput>
    disconnect?: Enumerable<collected_offeringsWhereUniqueInput>
    delete?: Enumerable<collected_offeringsWhereUniqueInput>
    connect?: Enumerable<collected_offeringsWhereUniqueInput>
    update?: Enumerable<collected_offeringsUpdateWithWhereUniqueWithoutServicesInput>
    updateMany?: Enumerable<collected_offeringsUpdateManyWithWhereWithoutServicesInput>
    deleteMany?: Enumerable<collected_offeringsScalarWhereInput>
  }

  export type commentsUncheckedUpdateManyWithoutServicesNestedInput = {
    create?: XOR<Enumerable<commentsCreateWithoutServicesInput>, Enumerable<commentsUncheckedCreateWithoutServicesInput>>
    connectOrCreate?: Enumerable<commentsCreateOrConnectWithoutServicesInput>
    upsert?: Enumerable<commentsUpsertWithWhereUniqueWithoutServicesInput>
    createMany?: commentsCreateManyServicesInputEnvelope
    set?: Enumerable<commentsWhereUniqueInput>
    disconnect?: Enumerable<commentsWhereUniqueInput>
    delete?: Enumerable<commentsWhereUniqueInput>
    connect?: Enumerable<commentsWhereUniqueInput>
    update?: Enumerable<commentsUpdateWithWhereUniqueWithoutServicesInput>
    updateMany?: Enumerable<commentsUpdateManyWithWhereWithoutServicesInput>
    deleteMany?: Enumerable<commentsScalarWhereInput>
  }

  export type responsibilitiesUncheckedUpdateManyWithoutServicesNestedInput = {
    create?: XOR<Enumerable<responsibilitiesCreateWithoutServicesInput>, Enumerable<responsibilitiesUncheckedCreateWithoutServicesInput>>
    connectOrCreate?: Enumerable<responsibilitiesCreateOrConnectWithoutServicesInput>
    upsert?: Enumerable<responsibilitiesUpsertWithWhereUniqueWithoutServicesInput>
    createMany?: responsibilitiesCreateManyServicesInputEnvelope
    set?: Enumerable<responsibilitiesWhereUniqueInput>
    disconnect?: Enumerable<responsibilitiesWhereUniqueInput>
    delete?: Enumerable<responsibilitiesWhereUniqueInput>
    connect?: Enumerable<responsibilitiesWhereUniqueInput>
    update?: Enumerable<responsibilitiesUpdateWithWhereUniqueWithoutServicesInput>
    updateMany?: Enumerable<responsibilitiesUpdateManyWithWhereWithoutServicesInput>
    deleteMany?: Enumerable<responsibilitiesScalarWhereInput>
  }

  export type servicesongsUncheckedUpdateManyWithoutServicesNestedInput = {
    create?: XOR<Enumerable<servicesongsCreateWithoutServicesInput>, Enumerable<servicesongsUncheckedCreateWithoutServicesInput>>
    connectOrCreate?: Enumerable<servicesongsCreateOrConnectWithoutServicesInput>
    upsert?: Enumerable<servicesongsUpsertWithWhereUniqueWithoutServicesInput>
    createMany?: servicesongsCreateManyServicesInputEnvelope
    set?: Enumerable<servicesongsWhereUniqueInput>
    disconnect?: Enumerable<servicesongsWhereUniqueInput>
    delete?: Enumerable<servicesongsWhereUniqueInput>
    connect?: Enumerable<servicesongsWhereUniqueInput>
    update?: Enumerable<servicesongsUpdateWithWhereUniqueWithoutServicesInput>
    updateMany?: Enumerable<servicesongsUpdateManyWithWhereWithoutServicesInput>
    deleteMany?: Enumerable<servicesongsScalarWhereInput>
  }

  export type serviceversesUncheckedUpdateManyWithoutServicesNestedInput = {
    create?: XOR<Enumerable<serviceversesCreateWithoutServicesInput>, Enumerable<serviceversesUncheckedCreateWithoutServicesInput>>
    connectOrCreate?: Enumerable<serviceversesCreateOrConnectWithoutServicesInput>
    upsert?: Enumerable<serviceversesUpsertWithWhereUniqueWithoutServicesInput>
    createMany?: serviceversesCreateManyServicesInputEnvelope
    set?: Enumerable<serviceversesWhereUniqueInput>
    disconnect?: Enumerable<serviceversesWhereUniqueInput>
    delete?: Enumerable<serviceversesWhereUniqueInput>
    connect?: Enumerable<serviceversesWhereUniqueInput>
    update?: Enumerable<serviceversesUpdateWithWhereUniqueWithoutServicesInput>
    updateMany?: Enumerable<serviceversesUpdateManyWithWhereWithoutServicesInput>
    deleteMany?: Enumerable<serviceversesScalarWhereInput>
  }

  export type servicesCreateNestedOneWithoutServicesongsInput = {
    create?: XOR<servicesCreateWithoutServicesongsInput, servicesUncheckedCreateWithoutServicesongsInput>
    connectOrCreate?: servicesCreateOrConnectWithoutServicesongsInput
    connect?: servicesWhereUniqueInput
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type servicesUpdateOneRequiredWithoutServicesongsNestedInput = {
    create?: XOR<servicesCreateWithoutServicesongsInput, servicesUncheckedCreateWithoutServicesongsInput>
    connectOrCreate?: servicesCreateOrConnectWithoutServicesongsInput
    upsert?: servicesUpsertWithoutServicesongsInput
    connect?: servicesWhereUniqueInput
    update?: XOR<servicesUpdateWithoutServicesongsInput, servicesUncheckedUpdateWithoutServicesongsInput>
  }

  export type servicesCreateNestedOneWithoutServiceversesInput = {
    create?: XOR<servicesCreateWithoutServiceversesInput, servicesUncheckedCreateWithoutServiceversesInput>
    connectOrCreate?: servicesCreateOrConnectWithoutServiceversesInput
    connect?: servicesWhereUniqueInput
  }

  export type servicesUpdateOneRequiredWithoutServiceversesNestedInput = {
    create?: XOR<servicesCreateWithoutServiceversesInput, servicesUncheckedCreateWithoutServiceversesInput>
    connectOrCreate?: servicesCreateOrConnectWithoutServiceversesInput
    upsert?: servicesUpsertWithoutServiceversesInput
    connect?: servicesWhereUniqueInput
    update?: XOR<servicesUpdateWithoutServiceversesInput, servicesUncheckedUpdateWithoutServiceversesInput>
  }

  export type songtagsCreateNestedManyWithoutSongdataInput = {
    create?: XOR<Enumerable<songtagsCreateWithoutSongdataInput>, Enumerable<songtagsUncheckedCreateWithoutSongdataInput>>
    connectOrCreate?: Enumerable<songtagsCreateOrConnectWithoutSongdataInput>
    createMany?: songtagsCreateManySongdataInputEnvelope
    connect?: Enumerable<songtagsWhereUniqueInput>
  }

  export type versedataCreateNestedManyWithoutSongdataInput = {
    create?: XOR<Enumerable<versedataCreateWithoutSongdataInput>, Enumerable<versedataUncheckedCreateWithoutSongdataInput>>
    connectOrCreate?: Enumerable<versedataCreateOrConnectWithoutSongdataInput>
    createMany?: versedataCreateManySongdataInputEnvelope
    connect?: Enumerable<versedataWhereUniqueInput>
  }

  export type songtagsUncheckedCreateNestedManyWithoutSongdataInput = {
    create?: XOR<Enumerable<songtagsCreateWithoutSongdataInput>, Enumerable<songtagsUncheckedCreateWithoutSongdataInput>>
    connectOrCreate?: Enumerable<songtagsCreateOrConnectWithoutSongdataInput>
    createMany?: songtagsCreateManySongdataInputEnvelope
    connect?: Enumerable<songtagsWhereUniqueInput>
  }

  export type versedataUncheckedCreateNestedManyWithoutSongdataInput = {
    create?: XOR<Enumerable<versedataCreateWithoutSongdataInput>, Enumerable<versedataUncheckedCreateWithoutSongdataInput>>
    connectOrCreate?: Enumerable<versedataCreateOrConnectWithoutSongdataInput>
    createMany?: versedataCreateManySongdataInputEnvelope
    connect?: Enumerable<versedataWhereUniqueInput>
  }

  export type songtagsUpdateManyWithoutSongdataNestedInput = {
    create?: XOR<Enumerable<songtagsCreateWithoutSongdataInput>, Enumerable<songtagsUncheckedCreateWithoutSongdataInput>>
    connectOrCreate?: Enumerable<songtagsCreateOrConnectWithoutSongdataInput>
    upsert?: Enumerable<songtagsUpsertWithWhereUniqueWithoutSongdataInput>
    createMany?: songtagsCreateManySongdataInputEnvelope
    set?: Enumerable<songtagsWhereUniqueInput>
    disconnect?: Enumerable<songtagsWhereUniqueInput>
    delete?: Enumerable<songtagsWhereUniqueInput>
    connect?: Enumerable<songtagsWhereUniqueInput>
    update?: Enumerable<songtagsUpdateWithWhereUniqueWithoutSongdataInput>
    updateMany?: Enumerable<songtagsUpdateManyWithWhereWithoutSongdataInput>
    deleteMany?: Enumerable<songtagsScalarWhereInput>
  }

  export type versedataUpdateManyWithoutSongdataNestedInput = {
    create?: XOR<Enumerable<versedataCreateWithoutSongdataInput>, Enumerable<versedataUncheckedCreateWithoutSongdataInput>>
    connectOrCreate?: Enumerable<versedataCreateOrConnectWithoutSongdataInput>
    upsert?: Enumerable<versedataUpsertWithWhereUniqueWithoutSongdataInput>
    createMany?: versedataCreateManySongdataInputEnvelope
    set?: Enumerable<versedataWhereUniqueInput>
    disconnect?: Enumerable<versedataWhereUniqueInput>
    delete?: Enumerable<versedataWhereUniqueInput>
    connect?: Enumerable<versedataWhereUniqueInput>
    update?: Enumerable<versedataUpdateWithWhereUniqueWithoutSongdataInput>
    updateMany?: Enumerable<versedataUpdateManyWithWhereWithoutSongdataInput>
    deleteMany?: Enumerable<versedataScalarWhereInput>
  }

  export type songtagsUncheckedUpdateManyWithoutSongdataNestedInput = {
    create?: XOR<Enumerable<songtagsCreateWithoutSongdataInput>, Enumerable<songtagsUncheckedCreateWithoutSongdataInput>>
    connectOrCreate?: Enumerable<songtagsCreateOrConnectWithoutSongdataInput>
    upsert?: Enumerable<songtagsUpsertWithWhereUniqueWithoutSongdataInput>
    createMany?: songtagsCreateManySongdataInputEnvelope
    set?: Enumerable<songtagsWhereUniqueInput>
    disconnect?: Enumerable<songtagsWhereUniqueInput>
    delete?: Enumerable<songtagsWhereUniqueInput>
    connect?: Enumerable<songtagsWhereUniqueInput>
    update?: Enumerable<songtagsUpdateWithWhereUniqueWithoutSongdataInput>
    updateMany?: Enumerable<songtagsUpdateManyWithWhereWithoutSongdataInput>
    deleteMany?: Enumerable<songtagsScalarWhereInput>
  }

  export type versedataUncheckedUpdateManyWithoutSongdataNestedInput = {
    create?: XOR<Enumerable<versedataCreateWithoutSongdataInput>, Enumerable<versedataUncheckedCreateWithoutSongdataInput>>
    connectOrCreate?: Enumerable<versedataCreateOrConnectWithoutSongdataInput>
    upsert?: Enumerable<versedataUpsertWithWhereUniqueWithoutSongdataInput>
    createMany?: versedataCreateManySongdataInputEnvelope
    set?: Enumerable<versedataWhereUniqueInput>
    disconnect?: Enumerable<versedataWhereUniqueInput>
    delete?: Enumerable<versedataWhereUniqueInput>
    connect?: Enumerable<versedataWhereUniqueInput>
    update?: Enumerable<versedataUpdateWithWhereUniqueWithoutSongdataInput>
    updateMany?: Enumerable<versedataUpdateManyWithWhereWithoutSongdataInput>
    deleteMany?: Enumerable<versedataScalarWhereInput>
  }

  export type songdataCreateNestedOneWithoutSongtagsInput = {
    create?: XOR<songdataCreateWithoutSongtagsInput, songdataUncheckedCreateWithoutSongtagsInput>
    connectOrCreate?: songdataCreateOrConnectWithoutSongtagsInput
    connect?: songdataWhereUniqueInput
  }

  export type songdataUpdateOneRequiredWithoutSongtagsNestedInput = {
    create?: XOR<songdataCreateWithoutSongtagsInput, songdataUncheckedCreateWithoutSongtagsInput>
    connectOrCreate?: songdataCreateOrConnectWithoutSongtagsInput
    upsert?: songdataUpsertWithoutSongtagsInput
    connect?: songdataWhereUniqueInput
    update?: XOR<songdataUpdateWithoutSongtagsInput, songdataUncheckedUpdateWithoutSongtagsInput>
  }

  export type songdataCreateNestedOneWithoutVersedataInput = {
    create?: XOR<songdataCreateWithoutVersedataInput, songdataUncheckedCreateWithoutVersedataInput>
    connectOrCreate?: songdataCreateOrConnectWithoutVersedataInput
    connect?: songdataWhereUniqueInput
  }

  export type songdataUpdateOneRequiredWithoutVersedataNestedInput = {
    create?: XOR<songdataCreateWithoutVersedataInput, songdataUncheckedCreateWithoutVersedataInput>
    connectOrCreate?: songdataCreateOrConnectWithoutVersedataInput
    upsert?: songdataUpsertWithoutVersedataInput
    connect?: songdataWhereUniqueInput
    update?: XOR<songdataUpdateWithoutVersedataInput, songdataUncheckedUpdateWithoutVersedataInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedDecimalNullableFilter = {
    equals?: Decimal | DecimalJsLike | number | string | null
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | Decimal | DecimalJsLike | number | string | null
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | Decimal | DecimalJsLike | number | string | null
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter = {
    equals?: Decimal | DecimalJsLike | number | string | null
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | Decimal | DecimalJsLike | number | string | null
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | Decimal | DecimalJsLike | number | string | null
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter
    _avg?: NestedDecimalNullableFilter
    _sum?: NestedDecimalNullableFilter
    _min?: NestedDecimalNullableFilter
    _max?: NestedDecimalNullableFilter
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type NestedBoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
  }

  export type NestedBigIntFilter = {
    equals?: bigint | number
    in?: Enumerable<bigint> | Enumerable<number> | bigint | number
    notIn?: Enumerable<bigint> | Enumerable<number> | bigint | number
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntFilter | bigint | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedBigIntWithAggregatesFilter = {
    equals?: bigint | number
    in?: Enumerable<bigint> | Enumerable<number> | bigint | number
    notIn?: Enumerable<bigint> | Enumerable<number> | bigint | number
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntWithAggregatesFilter | bigint | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedBigIntFilter
    _min?: NestedBigIntFilter
    _max?: NestedBigIntFilter
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type offering_goalsCreateWithoutCollected_offeringsInput = {
    name?: string | null
    description?: string | null
    amount?: Decimal | DecimalJsLike | number | string | null
    is_default?: boolean | null
    offering_targets: offering_targetsCreateNestedOneWithoutOffering_goalsInput
  }

  export type offering_goalsUncheckedCreateWithoutCollected_offeringsInput = {
    id?: number
    target_id: number
    name?: string | null
    description?: string | null
    amount?: Decimal | DecimalJsLike | number | string | null
    is_default?: boolean | null
  }

  export type offering_goalsCreateOrConnectWithoutCollected_offeringsInput = {
    where: offering_goalsWhereUniqueInput
    create: XOR<offering_goalsCreateWithoutCollected_offeringsInput, offering_goalsUncheckedCreateWithoutCollected_offeringsInput>
  }

  export type servicesCreateWithoutCollected_offeringsInput = {
    servicedate?: Date | string | null
    theme?: string | null
    comments?: commentsCreateNestedManyWithoutServicesInput
    responsibilities?: responsibilitiesCreateNestedManyWithoutServicesInput
    servicesongs?: servicesongsCreateNestedManyWithoutServicesInput
    serviceverses?: serviceversesCreateNestedManyWithoutServicesInput
  }

  export type servicesUncheckedCreateWithoutCollected_offeringsInput = {
    id?: number
    servicedate?: Date | string | null
    theme?: string | null
    comments?: commentsUncheckedCreateNestedManyWithoutServicesInput
    responsibilities?: responsibilitiesUncheckedCreateNestedManyWithoutServicesInput
    servicesongs?: servicesongsUncheckedCreateNestedManyWithoutServicesInput
    serviceverses?: serviceversesUncheckedCreateNestedManyWithoutServicesInput
  }

  export type servicesCreateOrConnectWithoutCollected_offeringsInput = {
    where: servicesWhereUniqueInput
    create: XOR<servicesCreateWithoutCollected_offeringsInput, servicesUncheckedCreateWithoutCollected_offeringsInput>
  }

  export type offering_goalsUpsertWithoutCollected_offeringsInput = {
    update: XOR<offering_goalsUpdateWithoutCollected_offeringsInput, offering_goalsUncheckedUpdateWithoutCollected_offeringsInput>
    create: XOR<offering_goalsCreateWithoutCollected_offeringsInput, offering_goalsUncheckedCreateWithoutCollected_offeringsInput>
  }

  export type offering_goalsUpdateWithoutCollected_offeringsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_default?: NullableBoolFieldUpdateOperationsInput | boolean | null
    offering_targets?: offering_targetsUpdateOneRequiredWithoutOffering_goalsNestedInput
  }

  export type offering_goalsUncheckedUpdateWithoutCollected_offeringsInput = {
    id?: IntFieldUpdateOperationsInput | number
    target_id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_default?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type servicesUpsertWithoutCollected_offeringsInput = {
    update: XOR<servicesUpdateWithoutCollected_offeringsInput, servicesUncheckedUpdateWithoutCollected_offeringsInput>
    create: XOR<servicesCreateWithoutCollected_offeringsInput, servicesUncheckedCreateWithoutCollected_offeringsInput>
  }

  export type servicesUpdateWithoutCollected_offeringsInput = {
    servicedate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: commentsUpdateManyWithoutServicesNestedInput
    responsibilities?: responsibilitiesUpdateManyWithoutServicesNestedInput
    servicesongs?: servicesongsUpdateManyWithoutServicesNestedInput
    serviceverses?: serviceversesUpdateManyWithoutServicesNestedInput
  }

  export type servicesUncheckedUpdateWithoutCollected_offeringsInput = {
    id?: IntFieldUpdateOperationsInput | number
    servicedate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: commentsUncheckedUpdateManyWithoutServicesNestedInput
    responsibilities?: responsibilitiesUncheckedUpdateManyWithoutServicesNestedInput
    servicesongs?: servicesongsUncheckedUpdateManyWithoutServicesNestedInput
    serviceverses?: serviceversesUncheckedUpdateManyWithoutServicesNestedInput
  }

  export type servicesCreateWithoutCommentsInput = {
    servicedate?: Date | string | null
    theme?: string | null
    collected_offerings?: collected_offeringsCreateNestedManyWithoutServicesInput
    responsibilities?: responsibilitiesCreateNestedManyWithoutServicesInput
    servicesongs?: servicesongsCreateNestedManyWithoutServicesInput
    serviceverses?: serviceversesCreateNestedManyWithoutServicesInput
  }

  export type servicesUncheckedCreateWithoutCommentsInput = {
    id?: number
    servicedate?: Date | string | null
    theme?: string | null
    collected_offerings?: collected_offeringsUncheckedCreateNestedManyWithoutServicesInput
    responsibilities?: responsibilitiesUncheckedCreateNestedManyWithoutServicesInput
    servicesongs?: servicesongsUncheckedCreateNestedManyWithoutServicesInput
    serviceverses?: serviceversesUncheckedCreateNestedManyWithoutServicesInput
  }

  export type servicesCreateOrConnectWithoutCommentsInput = {
    where: servicesWhereUniqueInput
    create: XOR<servicesCreateWithoutCommentsInput, servicesUncheckedCreateWithoutCommentsInput>
  }

  export type servicesUpsertWithoutCommentsInput = {
    update: XOR<servicesUpdateWithoutCommentsInput, servicesUncheckedUpdateWithoutCommentsInput>
    create: XOR<servicesCreateWithoutCommentsInput, servicesUncheckedCreateWithoutCommentsInput>
  }

  export type servicesUpdateWithoutCommentsInput = {
    servicedate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    collected_offerings?: collected_offeringsUpdateManyWithoutServicesNestedInput
    responsibilities?: responsibilitiesUpdateManyWithoutServicesNestedInput
    servicesongs?: servicesongsUpdateManyWithoutServicesNestedInput
    serviceverses?: serviceversesUpdateManyWithoutServicesNestedInput
  }

  export type servicesUncheckedUpdateWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    servicedate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    collected_offerings?: collected_offeringsUncheckedUpdateManyWithoutServicesNestedInput
    responsibilities?: responsibilitiesUncheckedUpdateManyWithoutServicesNestedInput
    servicesongs?: servicesongsUncheckedUpdateManyWithoutServicesNestedInput
    serviceverses?: serviceversesUncheckedUpdateManyWithoutServicesNestedInput
  }

  export type ltextversedataCreateWithoutLtextdataInput = {
    verse?: string | null
  }

  export type ltextversedataUncheckedCreateWithoutLtextdataInput = {
    id?: number
    verse?: string | null
  }

  export type ltextversedataCreateOrConnectWithoutLtextdataInput = {
    where: ltextversedataWhereUniqueInput
    create: XOR<ltextversedataCreateWithoutLtextdataInput, ltextversedataUncheckedCreateWithoutLtextdataInput>
  }

  export type ltextversedataCreateManyLtextdataInputEnvelope = {
    data: Enumerable<ltextversedataCreateManyLtextdataInput>
    skipDuplicates?: boolean
  }

  export type ltextversedataUpsertWithWhereUniqueWithoutLtextdataInput = {
    where: ltextversedataWhereUniqueInput
    update: XOR<ltextversedataUpdateWithoutLtextdataInput, ltextversedataUncheckedUpdateWithoutLtextdataInput>
    create: XOR<ltextversedataCreateWithoutLtextdataInput, ltextversedataUncheckedCreateWithoutLtextdataInput>
  }

  export type ltextversedataUpdateWithWhereUniqueWithoutLtextdataInput = {
    where: ltextversedataWhereUniqueInput
    data: XOR<ltextversedataUpdateWithoutLtextdataInput, ltextversedataUncheckedUpdateWithoutLtextdataInput>
  }

  export type ltextversedataUpdateManyWithWhereWithoutLtextdataInput = {
    where: ltextversedataScalarWhereInput
    data: XOR<ltextversedataUpdateManyMutationInput, ltextversedataUncheckedUpdateManyWithoutLtextversedataInput>
  }

  export type ltextversedataScalarWhereInput = {
    AND?: Enumerable<ltextversedataScalarWhereInput>
    OR?: Enumerable<ltextversedataScalarWhereInput>
    NOT?: Enumerable<ltextversedataScalarWhereInput>
    id?: IntFilter | number
    ltext_id?: IntFilter | number
    verse?: StringNullableFilter | string | null
  }

  export type ltextdataCreateWithoutLtextversedataInput = {
    title?: string | null
  }

  export type ltextdataUncheckedCreateWithoutLtextversedataInput = {
    id?: number
    title?: string | null
  }

  export type ltextdataCreateOrConnectWithoutLtextversedataInput = {
    where: ltextdataWhereUniqueInput
    create: XOR<ltextdataCreateWithoutLtextversedataInput, ltextdataUncheckedCreateWithoutLtextversedataInput>
  }

  export type ltextdataUpsertWithoutLtextversedataInput = {
    update: XOR<ltextdataUpdateWithoutLtextversedataInput, ltextdataUncheckedUpdateWithoutLtextversedataInput>
    create: XOR<ltextdataCreateWithoutLtextversedataInput, ltextdataUncheckedCreateWithoutLtextversedataInput>
  }

  export type ltextdataUpdateWithoutLtextversedataInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ltextdataUncheckedUpdateWithoutLtextversedataInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type collected_offeringsCreateWithoutOffering_goalsInput = {
    amount?: Decimal | DecimalJsLike | number | string | null
    services: servicesCreateNestedOneWithoutCollected_offeringsInput
  }

  export type collected_offeringsUncheckedCreateWithoutOffering_goalsInput = {
    id?: number
    service_id: number
    amount?: Decimal | DecimalJsLike | number | string | null
  }

  export type collected_offeringsCreateOrConnectWithoutOffering_goalsInput = {
    where: collected_offeringsWhereUniqueInput
    create: XOR<collected_offeringsCreateWithoutOffering_goalsInput, collected_offeringsUncheckedCreateWithoutOffering_goalsInput>
  }

  export type collected_offeringsCreateManyOffering_goalsInputEnvelope = {
    data: Enumerable<collected_offeringsCreateManyOffering_goalsInput>
    skipDuplicates?: boolean
  }

  export type offering_targetsCreateWithoutOffering_goalsInput = {
    name?: string | null
    description?: string | null
  }

  export type offering_targetsUncheckedCreateWithoutOffering_goalsInput = {
    id?: number
    name?: string | null
    description?: string | null
  }

  export type offering_targetsCreateOrConnectWithoutOffering_goalsInput = {
    where: offering_targetsWhereUniqueInput
    create: XOR<offering_targetsCreateWithoutOffering_goalsInput, offering_targetsUncheckedCreateWithoutOffering_goalsInput>
  }

  export type collected_offeringsUpsertWithWhereUniqueWithoutOffering_goalsInput = {
    where: collected_offeringsWhereUniqueInput
    update: XOR<collected_offeringsUpdateWithoutOffering_goalsInput, collected_offeringsUncheckedUpdateWithoutOffering_goalsInput>
    create: XOR<collected_offeringsCreateWithoutOffering_goalsInput, collected_offeringsUncheckedCreateWithoutOffering_goalsInput>
  }

  export type collected_offeringsUpdateWithWhereUniqueWithoutOffering_goalsInput = {
    where: collected_offeringsWhereUniqueInput
    data: XOR<collected_offeringsUpdateWithoutOffering_goalsInput, collected_offeringsUncheckedUpdateWithoutOffering_goalsInput>
  }

  export type collected_offeringsUpdateManyWithWhereWithoutOffering_goalsInput = {
    where: collected_offeringsScalarWhereInput
    data: XOR<collected_offeringsUpdateManyMutationInput, collected_offeringsUncheckedUpdateManyWithoutCollected_offeringsInput>
  }

  export type collected_offeringsScalarWhereInput = {
    AND?: Enumerable<collected_offeringsScalarWhereInput>
    OR?: Enumerable<collected_offeringsScalarWhereInput>
    NOT?: Enumerable<collected_offeringsScalarWhereInput>
    id?: IntFilter | number
    target_id?: IntFilter | number
    service_id?: IntFilter | number
    amount?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
  }

  export type offering_targetsUpsertWithoutOffering_goalsInput = {
    update: XOR<offering_targetsUpdateWithoutOffering_goalsInput, offering_targetsUncheckedUpdateWithoutOffering_goalsInput>
    create: XOR<offering_targetsCreateWithoutOffering_goalsInput, offering_targetsUncheckedCreateWithoutOffering_goalsInput>
  }

  export type offering_targetsUpdateWithoutOffering_goalsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type offering_targetsUncheckedUpdateWithoutOffering_goalsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type offering_goalsCreateWithoutOffering_targetsInput = {
    name?: string | null
    description?: string | null
    amount?: Decimal | DecimalJsLike | number | string | null
    is_default?: boolean | null
    collected_offerings?: collected_offeringsCreateNestedManyWithoutOffering_goalsInput
  }

  export type offering_goalsUncheckedCreateWithoutOffering_targetsInput = {
    id?: number
    name?: string | null
    description?: string | null
    amount?: Decimal | DecimalJsLike | number | string | null
    is_default?: boolean | null
    collected_offerings?: collected_offeringsUncheckedCreateNestedManyWithoutOffering_goalsInput
  }

  export type offering_goalsCreateOrConnectWithoutOffering_targetsInput = {
    where: offering_goalsWhereUniqueInput
    create: XOR<offering_goalsCreateWithoutOffering_targetsInput, offering_goalsUncheckedCreateWithoutOffering_targetsInput>
  }

  export type offering_goalsCreateManyOffering_targetsInputEnvelope = {
    data: Enumerable<offering_goalsCreateManyOffering_targetsInput>
    skipDuplicates?: boolean
  }

  export type offering_goalsUpsertWithWhereUniqueWithoutOffering_targetsInput = {
    where: offering_goalsWhereUniqueInput
    update: XOR<offering_goalsUpdateWithoutOffering_targetsInput, offering_goalsUncheckedUpdateWithoutOffering_targetsInput>
    create: XOR<offering_goalsCreateWithoutOffering_targetsInput, offering_goalsUncheckedCreateWithoutOffering_targetsInput>
  }

  export type offering_goalsUpdateWithWhereUniqueWithoutOffering_targetsInput = {
    where: offering_goalsWhereUniqueInput
    data: XOR<offering_goalsUpdateWithoutOffering_targetsInput, offering_goalsUncheckedUpdateWithoutOffering_targetsInput>
  }

  export type offering_goalsUpdateManyWithWhereWithoutOffering_targetsInput = {
    where: offering_goalsScalarWhereInput
    data: XOR<offering_goalsUpdateManyMutationInput, offering_goalsUncheckedUpdateManyWithoutOffering_goalsInput>
  }

  export type offering_goalsScalarWhereInput = {
    AND?: Enumerable<offering_goalsScalarWhereInput>
    OR?: Enumerable<offering_goalsScalarWhereInput>
    NOT?: Enumerable<offering_goalsScalarWhereInput>
    id?: IntFilter | number
    target_id?: IntFilter | number
    name?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    amount?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    is_default?: BoolNullableFilter | boolean | null
  }

  export type presentation_structureCreateWithoutPresentation_contentInput = {
    service_id?: number | null
    slot_name?: string | null
    slot_number?: number | null
    slot_type?: string | null
    id_in_type_table?: string | null
    addedclass?: string | null
    header_id?: number | null
    content_id: number
    instruction?: string | null
  }

  export type presentation_structureUncheckedCreateWithoutPresentation_contentInput = {
    id?: number
    service_id?: number | null
    slot_name?: string | null
    slot_number?: number | null
    slot_type?: string | null
    id_in_type_table?: string | null
    addedclass?: string | null
    header_id?: number | null
    content_id: number
    instruction?: string | null
  }

  export type presentation_structureCreateOrConnectWithoutPresentation_contentInput = {
    where: presentation_structureWhereUniqueInput
    create: XOR<presentation_structureCreateWithoutPresentation_contentInput, presentation_structureUncheckedCreateWithoutPresentation_contentInput>
  }

  export type presentation_structureUpsertWithoutPresentation_contentInput = {
    update: XOR<presentation_structureUpdateWithoutPresentation_contentInput, presentation_structureUncheckedUpdateWithoutPresentation_contentInput>
    create: XOR<presentation_structureCreateWithoutPresentation_contentInput, presentation_structureUncheckedCreateWithoutPresentation_contentInput>
  }

  export type presentation_structureUpdateWithoutPresentation_contentInput = {
    service_id?: NullableIntFieldUpdateOperationsInput | number | null
    slot_name?: NullableStringFieldUpdateOperationsInput | string | null
    slot_number?: NullableIntFieldUpdateOperationsInput | number | null
    slot_type?: NullableStringFieldUpdateOperationsInput | string | null
    id_in_type_table?: NullableStringFieldUpdateOperationsInput | string | null
    addedclass?: NullableStringFieldUpdateOperationsInput | string | null
    header_id?: NullableIntFieldUpdateOperationsInput | number | null
    content_id?: IntFieldUpdateOperationsInput | number
    instruction?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type presentation_structureUncheckedUpdateWithoutPresentation_contentInput = {
    id?: IntFieldUpdateOperationsInput | number
    service_id?: NullableIntFieldUpdateOperationsInput | number | null
    slot_name?: NullableStringFieldUpdateOperationsInput | string | null
    slot_number?: NullableIntFieldUpdateOperationsInput | number | null
    slot_type?: NullableStringFieldUpdateOperationsInput | string | null
    id_in_type_table?: NullableStringFieldUpdateOperationsInput | string | null
    addedclass?: NullableStringFieldUpdateOperationsInput | string | null
    header_id?: NullableIntFieldUpdateOperationsInput | number | null
    content_id?: IntFieldUpdateOperationsInput | number
    instruction?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type presentation_contentCreateWithoutPresentation_structureInput = {
    content_type?: string | null
    new_slide?: string | null
    content?: string | null
  }

  export type presentation_contentUncheckedCreateWithoutPresentation_structureInput = {
    id?: number
    content_type?: string | null
    new_slide?: string | null
    content?: string | null
  }

  export type presentation_contentCreateOrConnectWithoutPresentation_structureInput = {
    where: presentation_contentWhereUniqueInput
    create: XOR<presentation_contentCreateWithoutPresentation_structureInput, presentation_contentUncheckedCreateWithoutPresentation_structureInput>
  }

  export type presentation_contentCreateManyPresentation_structureInputEnvelope = {
    data: Enumerable<presentation_contentCreateManyPresentation_structureInput>
    skipDuplicates?: boolean
  }

  export type presentation_contentUpsertWithWhereUniqueWithoutPresentation_structureInput = {
    where: presentation_contentWhereUniqueInput
    update: XOR<presentation_contentUpdateWithoutPresentation_structureInput, presentation_contentUncheckedUpdateWithoutPresentation_structureInput>
    create: XOR<presentation_contentCreateWithoutPresentation_structureInput, presentation_contentUncheckedCreateWithoutPresentation_structureInput>
  }

  export type presentation_contentUpdateWithWhereUniqueWithoutPresentation_structureInput = {
    where: presentation_contentWhereUniqueInput
    data: XOR<presentation_contentUpdateWithoutPresentation_structureInput, presentation_contentUncheckedUpdateWithoutPresentation_structureInput>
  }

  export type presentation_contentUpdateManyWithWhereWithoutPresentation_structureInput = {
    where: presentation_contentScalarWhereInput
    data: XOR<presentation_contentUpdateManyMutationInput, presentation_contentUncheckedUpdateManyWithoutPresentation_contentInput>
  }

  export type presentation_contentScalarWhereInput = {
    AND?: Enumerable<presentation_contentScalarWhereInput>
    OR?: Enumerable<presentation_contentScalarWhereInput>
    NOT?: Enumerable<presentation_contentScalarWhereInput>
    id?: IntFilter | number
    slot_id?: IntFilter | number
    content_type?: StringNullableFilter | string | null
    new_slide?: StringNullableFilter | string | null
    content?: StringNullableFilter | string | null
  }

  export type servicesCreateWithoutResponsibilitiesInput = {
    servicedate?: Date | string | null
    theme?: string | null
    collected_offerings?: collected_offeringsCreateNestedManyWithoutServicesInput
    comments?: commentsCreateNestedManyWithoutServicesInput
    servicesongs?: servicesongsCreateNestedManyWithoutServicesInput
    serviceverses?: serviceversesCreateNestedManyWithoutServicesInput
  }

  export type servicesUncheckedCreateWithoutResponsibilitiesInput = {
    id?: number
    servicedate?: Date | string | null
    theme?: string | null
    collected_offerings?: collected_offeringsUncheckedCreateNestedManyWithoutServicesInput
    comments?: commentsUncheckedCreateNestedManyWithoutServicesInput
    servicesongs?: servicesongsUncheckedCreateNestedManyWithoutServicesInput
    serviceverses?: serviceversesUncheckedCreateNestedManyWithoutServicesInput
  }

  export type servicesCreateOrConnectWithoutResponsibilitiesInput = {
    where: servicesWhereUniqueInput
    create: XOR<servicesCreateWithoutResponsibilitiesInput, servicesUncheckedCreateWithoutResponsibilitiesInput>
  }

  export type servicesUpsertWithoutResponsibilitiesInput = {
    update: XOR<servicesUpdateWithoutResponsibilitiesInput, servicesUncheckedUpdateWithoutResponsibilitiesInput>
    create: XOR<servicesCreateWithoutResponsibilitiesInput, servicesUncheckedCreateWithoutResponsibilitiesInput>
  }

  export type servicesUpdateWithoutResponsibilitiesInput = {
    servicedate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    collected_offerings?: collected_offeringsUpdateManyWithoutServicesNestedInput
    comments?: commentsUpdateManyWithoutServicesNestedInput
    servicesongs?: servicesongsUpdateManyWithoutServicesNestedInput
    serviceverses?: serviceversesUpdateManyWithoutServicesNestedInput
  }

  export type servicesUncheckedUpdateWithoutResponsibilitiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    servicedate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    collected_offerings?: collected_offeringsUncheckedUpdateManyWithoutServicesNestedInput
    comments?: commentsUncheckedUpdateManyWithoutServicesNestedInput
    servicesongs?: servicesongsUncheckedUpdateManyWithoutServicesNestedInput
    serviceverses?: serviceversesUncheckedUpdateManyWithoutServicesNestedInput
  }

  export type collected_offeringsCreateWithoutServicesInput = {
    amount?: Decimal | DecimalJsLike | number | string | null
    offering_goals: offering_goalsCreateNestedOneWithoutCollected_offeringsInput
  }

  export type collected_offeringsUncheckedCreateWithoutServicesInput = {
    id?: number
    target_id: number
    amount?: Decimal | DecimalJsLike | number | string | null
  }

  export type collected_offeringsCreateOrConnectWithoutServicesInput = {
    where: collected_offeringsWhereUniqueInput
    create: XOR<collected_offeringsCreateWithoutServicesInput, collected_offeringsUncheckedCreateWithoutServicesInput>
  }

  export type collected_offeringsCreateManyServicesInputEnvelope = {
    data: Enumerable<collected_offeringsCreateManyServicesInput>
    skipDuplicates?: boolean
  }

  export type commentsCreateWithoutServicesInput = {
    reply_to?: number | null
    content?: string | null
    commentator?: string | null
    theme?: string | null
    comment_time?: Date | string | null
  }

  export type commentsUncheckedCreateWithoutServicesInput = {
    id?: number
    reply_to?: number | null
    content?: string | null
    commentator?: string | null
    theme?: string | null
    comment_time?: Date | string | null
  }

  export type commentsCreateOrConnectWithoutServicesInput = {
    where: commentsWhereUniqueInput
    create: XOR<commentsCreateWithoutServicesInput, commentsUncheckedCreateWithoutServicesInput>
  }

  export type commentsCreateManyServicesInputEnvelope = {
    data: Enumerable<commentsCreateManyServicesInput>
    skipDuplicates?: boolean
  }

  export type responsibilitiesCreateWithoutServicesInput = {
    responsibility?: string | null
    responsible?: string | null
  }

  export type responsibilitiesUncheckedCreateWithoutServicesInput = {
    id?: number
    responsibility?: string | null
    responsible?: string | null
  }

  export type responsibilitiesCreateOrConnectWithoutServicesInput = {
    where: responsibilitiesWhereUniqueInput
    create: XOR<responsibilitiesCreateWithoutServicesInput, responsibilitiesUncheckedCreateWithoutServicesInput>
  }

  export type responsibilitiesCreateManyServicesInputEnvelope = {
    data: Enumerable<responsibilitiesCreateManyServicesInput>
    skipDuplicates?: boolean
  }

  export type servicesongsCreateWithoutServicesInput = {
    id?: bigint | number
    song_title?: string | null
    verses?: string | null
    is_instrumental?: string | null
    song_id?: number | null
    songtype: string
    position?: number | null
  }

  export type servicesongsUncheckedCreateWithoutServicesInput = {
    id?: bigint | number
    song_title?: string | null
    verses?: string | null
    is_instrumental?: string | null
    song_id?: number | null
    songtype: string
    position?: number | null
  }

  export type servicesongsCreateOrConnectWithoutServicesInput = {
    where: servicesongsWhereUniqueInput
    create: XOR<servicesongsCreateWithoutServicesInput, servicesongsUncheckedCreateWithoutServicesInput>
  }

  export type servicesongsCreateManyServicesInputEnvelope = {
    data: Enumerable<servicesongsCreateManyServicesInput>
    skipDuplicates?: boolean
  }

  export type serviceversesCreateWithoutServicesInput = {
    segment_name?: string | null
    testament?: string | null
    startbook?: string | null
    endbook?: string | null
    startchapter?: number | null
    endchapter?: number | null
    startverse?: number | null
    endverse?: number | null
  }

  export type serviceversesUncheckedCreateWithoutServicesInput = {
    id?: number
    segment_name?: string | null
    testament?: string | null
    startbook?: string | null
    endbook?: string | null
    startchapter?: number | null
    endchapter?: number | null
    startverse?: number | null
    endverse?: number | null
  }

  export type serviceversesCreateOrConnectWithoutServicesInput = {
    where: serviceversesWhereUniqueInput
    create: XOR<serviceversesCreateWithoutServicesInput, serviceversesUncheckedCreateWithoutServicesInput>
  }

  export type serviceversesCreateManyServicesInputEnvelope = {
    data: Enumerable<serviceversesCreateManyServicesInput>
    skipDuplicates?: boolean
  }

  export type collected_offeringsUpsertWithWhereUniqueWithoutServicesInput = {
    where: collected_offeringsWhereUniqueInput
    update: XOR<collected_offeringsUpdateWithoutServicesInput, collected_offeringsUncheckedUpdateWithoutServicesInput>
    create: XOR<collected_offeringsCreateWithoutServicesInput, collected_offeringsUncheckedCreateWithoutServicesInput>
  }

  export type collected_offeringsUpdateWithWhereUniqueWithoutServicesInput = {
    where: collected_offeringsWhereUniqueInput
    data: XOR<collected_offeringsUpdateWithoutServicesInput, collected_offeringsUncheckedUpdateWithoutServicesInput>
  }

  export type collected_offeringsUpdateManyWithWhereWithoutServicesInput = {
    where: collected_offeringsScalarWhereInput
    data: XOR<collected_offeringsUpdateManyMutationInput, collected_offeringsUncheckedUpdateManyWithoutCollected_offeringsInput>
  }

  export type commentsUpsertWithWhereUniqueWithoutServicesInput = {
    where: commentsWhereUniqueInput
    update: XOR<commentsUpdateWithoutServicesInput, commentsUncheckedUpdateWithoutServicesInput>
    create: XOR<commentsCreateWithoutServicesInput, commentsUncheckedCreateWithoutServicesInput>
  }

  export type commentsUpdateWithWhereUniqueWithoutServicesInput = {
    where: commentsWhereUniqueInput
    data: XOR<commentsUpdateWithoutServicesInput, commentsUncheckedUpdateWithoutServicesInput>
  }

  export type commentsUpdateManyWithWhereWithoutServicesInput = {
    where: commentsScalarWhereInput
    data: XOR<commentsUpdateManyMutationInput, commentsUncheckedUpdateManyWithoutCommentsInput>
  }

  export type commentsScalarWhereInput = {
    AND?: Enumerable<commentsScalarWhereInput>
    OR?: Enumerable<commentsScalarWhereInput>
    NOT?: Enumerable<commentsScalarWhereInput>
    id?: IntFilter | number
    service_id?: IntFilter | number
    reply_to?: IntNullableFilter | number | null
    content?: StringNullableFilter | string | null
    commentator?: StringNullableFilter | string | null
    theme?: StringNullableFilter | string | null
    comment_time?: DateTimeNullableFilter | Date | string | null
  }

  export type responsibilitiesUpsertWithWhereUniqueWithoutServicesInput = {
    where: responsibilitiesWhereUniqueInput
    update: XOR<responsibilitiesUpdateWithoutServicesInput, responsibilitiesUncheckedUpdateWithoutServicesInput>
    create: XOR<responsibilitiesCreateWithoutServicesInput, responsibilitiesUncheckedCreateWithoutServicesInput>
  }

  export type responsibilitiesUpdateWithWhereUniqueWithoutServicesInput = {
    where: responsibilitiesWhereUniqueInput
    data: XOR<responsibilitiesUpdateWithoutServicesInput, responsibilitiesUncheckedUpdateWithoutServicesInput>
  }

  export type responsibilitiesUpdateManyWithWhereWithoutServicesInput = {
    where: responsibilitiesScalarWhereInput
    data: XOR<responsibilitiesUpdateManyMutationInput, responsibilitiesUncheckedUpdateManyWithoutResponsibilitiesInput>
  }

  export type responsibilitiesScalarWhereInput = {
    AND?: Enumerable<responsibilitiesScalarWhereInput>
    OR?: Enumerable<responsibilitiesScalarWhereInput>
    NOT?: Enumerable<responsibilitiesScalarWhereInput>
    id?: IntFilter | number
    service_id?: IntFilter | number
    responsibility?: StringNullableFilter | string | null
    responsible?: StringNullableFilter | string | null
  }

  export type servicesongsUpsertWithWhereUniqueWithoutServicesInput = {
    where: servicesongsWhereUniqueInput
    update: XOR<servicesongsUpdateWithoutServicesInput, servicesongsUncheckedUpdateWithoutServicesInput>
    create: XOR<servicesongsCreateWithoutServicesInput, servicesongsUncheckedCreateWithoutServicesInput>
  }

  export type servicesongsUpdateWithWhereUniqueWithoutServicesInput = {
    where: servicesongsWhereUniqueInput
    data: XOR<servicesongsUpdateWithoutServicesInput, servicesongsUncheckedUpdateWithoutServicesInput>
  }

  export type servicesongsUpdateManyWithWhereWithoutServicesInput = {
    where: servicesongsScalarWhereInput
    data: XOR<servicesongsUpdateManyMutationInput, servicesongsUncheckedUpdateManyWithoutServicesongsInput>
  }

  export type servicesongsScalarWhereInput = {
    AND?: Enumerable<servicesongsScalarWhereInput>
    OR?: Enumerable<servicesongsScalarWhereInput>
    NOT?: Enumerable<servicesongsScalarWhereInput>
    id?: BigIntFilter | bigint | number
    service_id?: IntFilter | number
    song_title?: StringNullableFilter | string | null
    verses?: StringNullableFilter | string | null
    is_instrumental?: StringNullableFilter | string | null
    song_id?: IntNullableFilter | number | null
    songtype?: StringFilter | string
    position?: IntNullableFilter | number | null
  }

  export type serviceversesUpsertWithWhereUniqueWithoutServicesInput = {
    where: serviceversesWhereUniqueInput
    update: XOR<serviceversesUpdateWithoutServicesInput, serviceversesUncheckedUpdateWithoutServicesInput>
    create: XOR<serviceversesCreateWithoutServicesInput, serviceversesUncheckedCreateWithoutServicesInput>
  }

  export type serviceversesUpdateWithWhereUniqueWithoutServicesInput = {
    where: serviceversesWhereUniqueInput
    data: XOR<serviceversesUpdateWithoutServicesInput, serviceversesUncheckedUpdateWithoutServicesInput>
  }

  export type serviceversesUpdateManyWithWhereWithoutServicesInput = {
    where: serviceversesScalarWhereInput
    data: XOR<serviceversesUpdateManyMutationInput, serviceversesUncheckedUpdateManyWithoutServiceversesInput>
  }

  export type serviceversesScalarWhereInput = {
    AND?: Enumerable<serviceversesScalarWhereInput>
    OR?: Enumerable<serviceversesScalarWhereInput>
    NOT?: Enumerable<serviceversesScalarWhereInput>
    id?: IntFilter | number
    service_id?: IntFilter | number
    segment_name?: StringNullableFilter | string | null
    testament?: StringNullableFilter | string | null
    startbook?: StringNullableFilter | string | null
    endbook?: StringNullableFilter | string | null
    startchapter?: IntNullableFilter | number | null
    endchapter?: IntNullableFilter | number | null
    startverse?: IntNullableFilter | number | null
    endverse?: IntNullableFilter | number | null
  }

  export type servicesCreateWithoutServicesongsInput = {
    servicedate?: Date | string | null
    theme?: string | null
    collected_offerings?: collected_offeringsCreateNestedManyWithoutServicesInput
    comments?: commentsCreateNestedManyWithoutServicesInput
    responsibilities?: responsibilitiesCreateNestedManyWithoutServicesInput
    serviceverses?: serviceversesCreateNestedManyWithoutServicesInput
  }

  export type servicesUncheckedCreateWithoutServicesongsInput = {
    id?: number
    servicedate?: Date | string | null
    theme?: string | null
    collected_offerings?: collected_offeringsUncheckedCreateNestedManyWithoutServicesInput
    comments?: commentsUncheckedCreateNestedManyWithoutServicesInput
    responsibilities?: responsibilitiesUncheckedCreateNestedManyWithoutServicesInput
    serviceverses?: serviceversesUncheckedCreateNestedManyWithoutServicesInput
  }

  export type servicesCreateOrConnectWithoutServicesongsInput = {
    where: servicesWhereUniqueInput
    create: XOR<servicesCreateWithoutServicesongsInput, servicesUncheckedCreateWithoutServicesongsInput>
  }

  export type servicesUpsertWithoutServicesongsInput = {
    update: XOR<servicesUpdateWithoutServicesongsInput, servicesUncheckedUpdateWithoutServicesongsInput>
    create: XOR<servicesCreateWithoutServicesongsInput, servicesUncheckedCreateWithoutServicesongsInput>
  }

  export type servicesUpdateWithoutServicesongsInput = {
    servicedate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    collected_offerings?: collected_offeringsUpdateManyWithoutServicesNestedInput
    comments?: commentsUpdateManyWithoutServicesNestedInput
    responsibilities?: responsibilitiesUpdateManyWithoutServicesNestedInput
    serviceverses?: serviceversesUpdateManyWithoutServicesNestedInput
  }

  export type servicesUncheckedUpdateWithoutServicesongsInput = {
    id?: IntFieldUpdateOperationsInput | number
    servicedate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    collected_offerings?: collected_offeringsUncheckedUpdateManyWithoutServicesNestedInput
    comments?: commentsUncheckedUpdateManyWithoutServicesNestedInput
    responsibilities?: responsibilitiesUncheckedUpdateManyWithoutServicesNestedInput
    serviceverses?: serviceversesUncheckedUpdateManyWithoutServicesNestedInput
  }

  export type servicesCreateWithoutServiceversesInput = {
    servicedate?: Date | string | null
    theme?: string | null
    collected_offerings?: collected_offeringsCreateNestedManyWithoutServicesInput
    comments?: commentsCreateNestedManyWithoutServicesInput
    responsibilities?: responsibilitiesCreateNestedManyWithoutServicesInput
    servicesongs?: servicesongsCreateNestedManyWithoutServicesInput
  }

  export type servicesUncheckedCreateWithoutServiceversesInput = {
    id?: number
    servicedate?: Date | string | null
    theme?: string | null
    collected_offerings?: collected_offeringsUncheckedCreateNestedManyWithoutServicesInput
    comments?: commentsUncheckedCreateNestedManyWithoutServicesInput
    responsibilities?: responsibilitiesUncheckedCreateNestedManyWithoutServicesInput
    servicesongs?: servicesongsUncheckedCreateNestedManyWithoutServicesInput
  }

  export type servicesCreateOrConnectWithoutServiceversesInput = {
    where: servicesWhereUniqueInput
    create: XOR<servicesCreateWithoutServiceversesInput, servicesUncheckedCreateWithoutServiceversesInput>
  }

  export type servicesUpsertWithoutServiceversesInput = {
    update: XOR<servicesUpdateWithoutServiceversesInput, servicesUncheckedUpdateWithoutServiceversesInput>
    create: XOR<servicesCreateWithoutServiceversesInput, servicesUncheckedCreateWithoutServiceversesInput>
  }

  export type servicesUpdateWithoutServiceversesInput = {
    servicedate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    collected_offerings?: collected_offeringsUpdateManyWithoutServicesNestedInput
    comments?: commentsUpdateManyWithoutServicesNestedInput
    responsibilities?: responsibilitiesUpdateManyWithoutServicesNestedInput
    servicesongs?: servicesongsUpdateManyWithoutServicesNestedInput
  }

  export type servicesUncheckedUpdateWithoutServiceversesInput = {
    id?: IntFieldUpdateOperationsInput | number
    servicedate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    collected_offerings?: collected_offeringsUncheckedUpdateManyWithoutServicesNestedInput
    comments?: commentsUncheckedUpdateManyWithoutServicesNestedInput
    responsibilities?: responsibilitiesUncheckedUpdateManyWithoutServicesNestedInput
    servicesongs?: servicesongsUncheckedUpdateManyWithoutServicesNestedInput
  }

  export type songtagsCreateWithoutSongdataInput = {
    tag?: string | null
  }

  export type songtagsUncheckedCreateWithoutSongdataInput = {
    id?: number
    tag?: string | null
  }

  export type songtagsCreateOrConnectWithoutSongdataInput = {
    where: songtagsWhereUniqueInput
    create: XOR<songtagsCreateWithoutSongdataInput, songtagsUncheckedCreateWithoutSongdataInput>
  }

  export type songtagsCreateManySongdataInputEnvelope = {
    data: Enumerable<songtagsCreateManySongdataInput>
    skipDuplicates?: boolean
  }

  export type versedataCreateWithoutSongdataInput = {
    verse?: string | null
    versetype?: string | null
  }

  export type versedataUncheckedCreateWithoutSongdataInput = {
    id?: number
    verse?: string | null
    versetype?: string | null
  }

  export type versedataCreateOrConnectWithoutSongdataInput = {
    where: versedataWhereUniqueInput
    create: XOR<versedataCreateWithoutSongdataInput, versedataUncheckedCreateWithoutSongdataInput>
  }

  export type versedataCreateManySongdataInputEnvelope = {
    data: Enumerable<versedataCreateManySongdataInput>
    skipDuplicates?: boolean
  }

  export type songtagsUpsertWithWhereUniqueWithoutSongdataInput = {
    where: songtagsWhereUniqueInput
    update: XOR<songtagsUpdateWithoutSongdataInput, songtagsUncheckedUpdateWithoutSongdataInput>
    create: XOR<songtagsCreateWithoutSongdataInput, songtagsUncheckedCreateWithoutSongdataInput>
  }

  export type songtagsUpdateWithWhereUniqueWithoutSongdataInput = {
    where: songtagsWhereUniqueInput
    data: XOR<songtagsUpdateWithoutSongdataInput, songtagsUncheckedUpdateWithoutSongdataInput>
  }

  export type songtagsUpdateManyWithWhereWithoutSongdataInput = {
    where: songtagsScalarWhereInput
    data: XOR<songtagsUpdateManyMutationInput, songtagsUncheckedUpdateManyWithoutSongtagsInput>
  }

  export type songtagsScalarWhereInput = {
    AND?: Enumerable<songtagsScalarWhereInput>
    OR?: Enumerable<songtagsScalarWhereInput>
    NOT?: Enumerable<songtagsScalarWhereInput>
    id?: IntFilter | number
    song_id?: IntFilter | number
    tag?: StringNullableFilter | string | null
  }

  export type versedataUpsertWithWhereUniqueWithoutSongdataInput = {
    where: versedataWhereUniqueInput
    update: XOR<versedataUpdateWithoutSongdataInput, versedataUncheckedUpdateWithoutSongdataInput>
    create: XOR<versedataCreateWithoutSongdataInput, versedataUncheckedCreateWithoutSongdataInput>
  }

  export type versedataUpdateWithWhereUniqueWithoutSongdataInput = {
    where: versedataWhereUniqueInput
    data: XOR<versedataUpdateWithoutSongdataInput, versedataUncheckedUpdateWithoutSongdataInput>
  }

  export type versedataUpdateManyWithWhereWithoutSongdataInput = {
    where: versedataScalarWhereInput
    data: XOR<versedataUpdateManyMutationInput, versedataUncheckedUpdateManyWithoutVersedataInput>
  }

  export type versedataScalarWhereInput = {
    AND?: Enumerable<versedataScalarWhereInput>
    OR?: Enumerable<versedataScalarWhereInput>
    NOT?: Enumerable<versedataScalarWhereInput>
    id?: IntFilter | number
    song_id?: IntFilter | number
    verse?: StringNullableFilter | string | null
    versetype?: StringNullableFilter | string | null
  }

  export type songdataCreateWithoutSongtagsInput = {
    title?: string | null
    composer?: string | null
    lyrics?: string | null
    version_description?: string | null
    versedata?: versedataCreateNestedManyWithoutSongdataInput
  }

  export type songdataUncheckedCreateWithoutSongtagsInput = {
    id?: number
    title?: string | null
    composer?: string | null
    lyrics?: string | null
    version_description?: string | null
    versedata?: versedataUncheckedCreateNestedManyWithoutSongdataInput
  }

  export type songdataCreateOrConnectWithoutSongtagsInput = {
    where: songdataWhereUniqueInput
    create: XOR<songdataCreateWithoutSongtagsInput, songdataUncheckedCreateWithoutSongtagsInput>
  }

  export type songdataUpsertWithoutSongtagsInput = {
    update: XOR<songdataUpdateWithoutSongtagsInput, songdataUncheckedUpdateWithoutSongtagsInput>
    create: XOR<songdataCreateWithoutSongtagsInput, songdataUncheckedCreateWithoutSongtagsInput>
  }

  export type songdataUpdateWithoutSongtagsInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    composer?: NullableStringFieldUpdateOperationsInput | string | null
    lyrics?: NullableStringFieldUpdateOperationsInput | string | null
    version_description?: NullableStringFieldUpdateOperationsInput | string | null
    versedata?: versedataUpdateManyWithoutSongdataNestedInput
  }

  export type songdataUncheckedUpdateWithoutSongtagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    composer?: NullableStringFieldUpdateOperationsInput | string | null
    lyrics?: NullableStringFieldUpdateOperationsInput | string | null
    version_description?: NullableStringFieldUpdateOperationsInput | string | null
    versedata?: versedataUncheckedUpdateManyWithoutSongdataNestedInput
  }

  export type songdataCreateWithoutVersedataInput = {
    title?: string | null
    composer?: string | null
    lyrics?: string | null
    version_description?: string | null
    songtags?: songtagsCreateNestedManyWithoutSongdataInput
  }

  export type songdataUncheckedCreateWithoutVersedataInput = {
    id?: number
    title?: string | null
    composer?: string | null
    lyrics?: string | null
    version_description?: string | null
    songtags?: songtagsUncheckedCreateNestedManyWithoutSongdataInput
  }

  export type songdataCreateOrConnectWithoutVersedataInput = {
    where: songdataWhereUniqueInput
    create: XOR<songdataCreateWithoutVersedataInput, songdataUncheckedCreateWithoutVersedataInput>
  }

  export type songdataUpsertWithoutVersedataInput = {
    update: XOR<songdataUpdateWithoutVersedataInput, songdataUncheckedUpdateWithoutVersedataInput>
    create: XOR<songdataCreateWithoutVersedataInput, songdataUncheckedCreateWithoutVersedataInput>
  }

  export type songdataUpdateWithoutVersedataInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    composer?: NullableStringFieldUpdateOperationsInput | string | null
    lyrics?: NullableStringFieldUpdateOperationsInput | string | null
    version_description?: NullableStringFieldUpdateOperationsInput | string | null
    songtags?: songtagsUpdateManyWithoutSongdataNestedInput
  }

  export type songdataUncheckedUpdateWithoutVersedataInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    composer?: NullableStringFieldUpdateOperationsInput | string | null
    lyrics?: NullableStringFieldUpdateOperationsInput | string | null
    version_description?: NullableStringFieldUpdateOperationsInput | string | null
    songtags?: songtagsUncheckedUpdateManyWithoutSongdataNestedInput
  }

  export type ltextversedataCreateManyLtextdataInput = {
    id?: number
    verse?: string | null
  }

  export type ltextversedataUpdateWithoutLtextdataInput = {
    verse?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ltextversedataUncheckedUpdateWithoutLtextdataInput = {
    id?: IntFieldUpdateOperationsInput | number
    verse?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ltextversedataUncheckedUpdateManyWithoutLtextversedataInput = {
    id?: IntFieldUpdateOperationsInput | number
    verse?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type collected_offeringsCreateManyOffering_goalsInput = {
    id?: number
    service_id: number
    amount?: Decimal | DecimalJsLike | number | string | null
  }

  export type collected_offeringsUpdateWithoutOffering_goalsInput = {
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    services?: servicesUpdateOneRequiredWithoutCollected_offeringsNestedInput
  }

  export type collected_offeringsUncheckedUpdateWithoutOffering_goalsInput = {
    id?: IntFieldUpdateOperationsInput | number
    service_id?: IntFieldUpdateOperationsInput | number
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type collected_offeringsUncheckedUpdateManyWithoutCollected_offeringsInput = {
    id?: IntFieldUpdateOperationsInput | number
    service_id?: IntFieldUpdateOperationsInput | number
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type offering_goalsCreateManyOffering_targetsInput = {
    id?: number
    name?: string | null
    description?: string | null
    amount?: Decimal | DecimalJsLike | number | string | null
    is_default?: boolean | null
  }

  export type offering_goalsUpdateWithoutOffering_targetsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_default?: NullableBoolFieldUpdateOperationsInput | boolean | null
    collected_offerings?: collected_offeringsUpdateManyWithoutOffering_goalsNestedInput
  }

  export type offering_goalsUncheckedUpdateWithoutOffering_targetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_default?: NullableBoolFieldUpdateOperationsInput | boolean | null
    collected_offerings?: collected_offeringsUncheckedUpdateManyWithoutOffering_goalsNestedInput
  }

  export type offering_goalsUncheckedUpdateManyWithoutOffering_goalsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_default?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type presentation_contentCreateManyPresentation_structureInput = {
    id?: number
    content_type?: string | null
    new_slide?: string | null
    content?: string | null
  }

  export type presentation_contentUpdateWithoutPresentation_structureInput = {
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    new_slide?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type presentation_contentUncheckedUpdateWithoutPresentation_structureInput = {
    id?: IntFieldUpdateOperationsInput | number
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    new_slide?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type presentation_contentUncheckedUpdateManyWithoutPresentation_contentInput = {
    id?: IntFieldUpdateOperationsInput | number
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    new_slide?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type collected_offeringsCreateManyServicesInput = {
    id?: number
    target_id: number
    amount?: Decimal | DecimalJsLike | number | string | null
  }

  export type commentsCreateManyServicesInput = {
    id?: number
    reply_to?: number | null
    content?: string | null
    commentator?: string | null
    theme?: string | null
    comment_time?: Date | string | null
  }

  export type responsibilitiesCreateManyServicesInput = {
    id?: number
    responsibility?: string | null
    responsible?: string | null
  }

  export type servicesongsCreateManyServicesInput = {
    id?: bigint | number
    song_title?: string | null
    verses?: string | null
    is_instrumental?: string | null
    song_id?: number | null
    songtype: string
    position?: number | null
  }

  export type serviceversesCreateManyServicesInput = {
    id?: number
    segment_name?: string | null
    testament?: string | null
    startbook?: string | null
    endbook?: string | null
    startchapter?: number | null
    endchapter?: number | null
    startverse?: number | null
    endverse?: number | null
  }

  export type collected_offeringsUpdateWithoutServicesInput = {
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    offering_goals?: offering_goalsUpdateOneRequiredWithoutCollected_offeringsNestedInput
  }

  export type collected_offeringsUncheckedUpdateWithoutServicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    target_id?: IntFieldUpdateOperationsInput | number
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type commentsUpdateWithoutServicesInput = {
    reply_to?: NullableIntFieldUpdateOperationsInput | number | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    commentator?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    comment_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type commentsUncheckedUpdateWithoutServicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    reply_to?: NullableIntFieldUpdateOperationsInput | number | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    commentator?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    comment_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type commentsUncheckedUpdateManyWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    reply_to?: NullableIntFieldUpdateOperationsInput | number | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    commentator?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    comment_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type responsibilitiesUpdateWithoutServicesInput = {
    responsibility?: NullableStringFieldUpdateOperationsInput | string | null
    responsible?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type responsibilitiesUncheckedUpdateWithoutServicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    responsibility?: NullableStringFieldUpdateOperationsInput | string | null
    responsible?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type responsibilitiesUncheckedUpdateManyWithoutResponsibilitiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    responsibility?: NullableStringFieldUpdateOperationsInput | string | null
    responsible?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type servicesongsUpdateWithoutServicesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    song_title?: NullableStringFieldUpdateOperationsInput | string | null
    verses?: NullableStringFieldUpdateOperationsInput | string | null
    is_instrumental?: NullableStringFieldUpdateOperationsInput | string | null
    song_id?: NullableIntFieldUpdateOperationsInput | number | null
    songtype?: StringFieldUpdateOperationsInput | string
    position?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type servicesongsUncheckedUpdateWithoutServicesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    song_title?: NullableStringFieldUpdateOperationsInput | string | null
    verses?: NullableStringFieldUpdateOperationsInput | string | null
    is_instrumental?: NullableStringFieldUpdateOperationsInput | string | null
    song_id?: NullableIntFieldUpdateOperationsInput | number | null
    songtype?: StringFieldUpdateOperationsInput | string
    position?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type servicesongsUncheckedUpdateManyWithoutServicesongsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    song_title?: NullableStringFieldUpdateOperationsInput | string | null
    verses?: NullableStringFieldUpdateOperationsInput | string | null
    is_instrumental?: NullableStringFieldUpdateOperationsInput | string | null
    song_id?: NullableIntFieldUpdateOperationsInput | number | null
    songtype?: StringFieldUpdateOperationsInput | string
    position?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type serviceversesUpdateWithoutServicesInput = {
    segment_name?: NullableStringFieldUpdateOperationsInput | string | null
    testament?: NullableStringFieldUpdateOperationsInput | string | null
    startbook?: NullableStringFieldUpdateOperationsInput | string | null
    endbook?: NullableStringFieldUpdateOperationsInput | string | null
    startchapter?: NullableIntFieldUpdateOperationsInput | number | null
    endchapter?: NullableIntFieldUpdateOperationsInput | number | null
    startverse?: NullableIntFieldUpdateOperationsInput | number | null
    endverse?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type serviceversesUncheckedUpdateWithoutServicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    segment_name?: NullableStringFieldUpdateOperationsInput | string | null
    testament?: NullableStringFieldUpdateOperationsInput | string | null
    startbook?: NullableStringFieldUpdateOperationsInput | string | null
    endbook?: NullableStringFieldUpdateOperationsInput | string | null
    startchapter?: NullableIntFieldUpdateOperationsInput | number | null
    endchapter?: NullableIntFieldUpdateOperationsInput | number | null
    startverse?: NullableIntFieldUpdateOperationsInput | number | null
    endverse?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type serviceversesUncheckedUpdateManyWithoutServiceversesInput = {
    id?: IntFieldUpdateOperationsInput | number
    segment_name?: NullableStringFieldUpdateOperationsInput | string | null
    testament?: NullableStringFieldUpdateOperationsInput | string | null
    startbook?: NullableStringFieldUpdateOperationsInput | string | null
    endbook?: NullableStringFieldUpdateOperationsInput | string | null
    startchapter?: NullableIntFieldUpdateOperationsInput | number | null
    endchapter?: NullableIntFieldUpdateOperationsInput | number | null
    startverse?: NullableIntFieldUpdateOperationsInput | number | null
    endverse?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type songtagsCreateManySongdataInput = {
    id?: number
    tag?: string | null
  }

  export type versedataCreateManySongdataInput = {
    id?: number
    verse?: string | null
    versetype?: string | null
  }

  export type songtagsUpdateWithoutSongdataInput = {
    tag?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type songtagsUncheckedUpdateWithoutSongdataInput = {
    id?: IntFieldUpdateOperationsInput | number
    tag?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type songtagsUncheckedUpdateManyWithoutSongtagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    tag?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type versedataUpdateWithoutSongdataInput = {
    verse?: NullableStringFieldUpdateOperationsInput | string | null
    versetype?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type versedataUncheckedUpdateWithoutSongdataInput = {
    id?: IntFieldUpdateOperationsInput | number
    verse?: NullableStringFieldUpdateOperationsInput | string | null
    versetype?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type versedataUncheckedUpdateManyWithoutVersedataInput = {
    id?: IntFieldUpdateOperationsInput | number
    verse?: NullableStringFieldUpdateOperationsInput | string | null
    versetype?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}